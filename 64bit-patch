diff -uNr disksim-4.0/diskmodel/layout_g1.c disksim-4.0-x64/diskmodel/layout_g1.c
--- disksim-4.0/diskmodel/layout_g1.c	2016-03-23 20:10:28.882755948 +0800
+++ disksim-4.0-x64/diskmodel/layout_g1.c	2016-03-23 19:33:21.162649000 +0800
@@ -1939,10 +1939,10 @@
 	    struct dm_layout_zone *result)
 {
   struct dm_layout_g1 *l = (struct dm_layout_g1 *)d->layout;
-  struct dm_layout_g1_band *z;
+  struct dm_layout_g1_band *z = calloc(sizeof(struct dm_layout_g1_band), 1);
 
   // check args  
-  if(z == 0) { return -1; }
+  if(z == NULL) { return -1; }
   if(n < 0 || n >= l->bands_len) { return -1; }
 
   z = &l->bands[n];
diff -uNr disksim-4.0/diskmodel/layout_g1.c~ disksim-4.0-x64/diskmodel/layout_g1.c~
--- disksim-4.0/diskmodel/layout_g1.c~	1970-01-01 08:00:00.000000000 +0800
+++ disksim-4.0-x64/diskmodel/layout_g1.c~	2016-03-23 19:32:52.274645000 +0800
@@ -0,0 +1,2173 @@
+
+/* diskmodel (version 1.0)
+ * Authors: John Bucy, Greg Ganger
+ * Contributors: John Griffin, Jiri Schindler, Steve Schlosser
+ *
+ * Copyright (c) of Carnegie Mellon University, 2001-2008.
+ *
+ * This software is being provided by the copyright holders under the
+ * following license. By obtaining, using and/or copying this
+ * software, you agree that you have read, understood, and will comply
+ * with the following terms and conditions:
+ *
+ * Permission to reproduce, use, and prepare derivative works of this
+ * software is granted provided the copyright and "No Warranty"
+ * statements are included with all reproductions and derivative works
+ * and associated documentation. This software may also be
+ * redistributed without charge provided that the copyright and "No
+ * Warranty" statements are included in all redistributions.
+ *
+ * NO WARRANTY. THIS SOFTWARE IS FURNISHED ON AN "AS IS" BASIS.
+ * CARNEGIE MELLON UNIVERSITY MAKES NO WARRANTIES OF ANY KIND, EITHER
+ * EXPRESSED OR IMPLIED AS TO THE MATTER INCLUDING, BUT NOT LIMITED
+ * TO: WARRANTY OF FITNESS FOR PURPOSE OR MERCHANTABILITY, EXCLUSIVITY
+ * OF RESULTS OR RESULTS OBTAINED FROM USE OF THIS SOFTWARE. CARNEGIE
+ * MELLON UNIVERSITY DOES NOT MAKE ANY WARRANTY OF ANY KIND WITH
+ * RESPECT TO FREEDOM FROM PATENT, TRADEMARK, OR COPYRIGHT
+ * INFRINGEMENT.  COPYRIGHT HOLDERS WILL BEAR NO LIABILITY FOR ANY USE
+ * OF THIS SOFTWARE OR DOCUMENTATION.  
+ */
+
+
+
+#include "layout_g1.h"
+#include "marshal.h"
+
+#define max(x,y) (((x) > (y)) ? (x) : (y))
+
+/*
+ * DiskSim Storage Subsystem Simulation Environment (Version 2.0)
+ * Revision Authors: Greg Ganger
+ * Contributors: Ross Cohen, John Griffin, Steve Schlosser
+ *
+ * Copyright (c) of Carnegie Mellon University, 1999.
+ *
+ * Permission to reproduce, use, and prepare derivative works of
+ * this software for internal use is granted provided the copyright
+ * and "No Warranty" statements are included with all reproductions
+ * and derivative works. This software may also be redistributed
+ * without charge provided that the copyright and "No Warranty"
+ * statements are included in all redistributions.
+ *
+ * NO WARRANTY. THIS SOFTWARE IS FURNISHED ON AN "AS IS" BASIS.
+ * CARNEGIE MELLON UNIVERSITY MAKES NO WARRANTIES OF ANY KIND, EITHER
+ * EXPRESSED OR IMPLIED AS TO THE MATTER INCLUDING, BUT NOT LIMITED
+ * TO: WARRANTY OF FITNESS FOR PURPOSE OR MERCHANTABILITY, EXCLUSIVITY
+ * OF RESULTS OR RESULTS OBTAINED FROM USE OF THIS SOFTWARE. CARNEGIE
+ * MELLON UNIVERSITY DOES NOT MAKE ANY WARRANTY OF ANY KIND WITH RESPECT
+ * TO FREEDOM FROM PATENT, TRADEMARK, OR COPYRIGHT INFRINGEMENT.
+ */
+
+/*
+ * DiskSim Storage Subsystem Simulation Environment
+ * Authors: Greg Ganger, Bruce Worthington, Yale Patt
+ *
+ * Copyright (C) 1993, 1995, 1997 The Regents of the University of Michigan 
+ *
+ * This software is being provided by the copyright holders under the
+ * following license. By obtaining, using and/or copying this software,
+ * you agree that you have read, understood, and will comply with the
+ * following terms and conditions:
+ *
+ * Permission to use, copy, modify, distribute, and sell this software
+ * and its documentation for any purpose and without fee or royalty is
+ * hereby granted, provided that the full text of this NOTICE appears on
+ * ALL copies of the software and documentation or portions thereof,
+ * including modifications, that you make.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS," AND COPYRIGHT HOLDERS MAKE NO
+ * REPRESENTATIONS OR WARRANTIES, EXPRESS OR IMPLIED. BY WAY OF EXAMPLE,
+ * BUT NOT LIMITATION, COPYRIGHT HOLDERS MAKE NO REPRESENTATIONS OR
+ * WARRANTIES OF MERCHANTABILITY OR FITNESS FOR ANY PARTICULAR PURPOSE OR
+ * THAT THE USE OF THE SOFTWARE OR DOCUMENTATION WILL NOT INFRINGE ANY
+ * THIRD PARTY PATENTS, COPYRIGHTS, TRADEMARKS OR OTHER RIGHTS. COPYRIGHT
+ * HOLDERS WILL BEAR NO LIABILITY FOR ANY USE OF THIS SOFTWARE OR
+ * DOCUMENTATION.
+ *
+ *  This software is provided AS IS, WITHOUT REPRESENTATION FROM THE
+ * UNIVERSITY OF MICHIGAN AS TO ITS FITNESS FOR ANY PURPOSE, AND
+ * WITHOUT WARRANTY BY THE UNIVERSITY OF MICHIGAN OF ANY KIND, EITHER
+ * EXPRESSED OR IMPLIED, INCLUDING WITHOUT LIMITATION THE IMPLIED
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE REGENTS
+ * OF THE UNIVERSITY OF MICHIGAN SHALL NOT BE LIABLE FOR ANY DAMAGES,
+ * INCLUDING SPECIAL , INDIRECT, INCIDENTAL, OR CONSEQUENTIAL DAMAGES,
+ * WITH RESPECT TO ANY CLAIM ARISING OUT OF OR IN CONNECTION WITH THE
+ * USE OF OR IN CONNECTION WITH THE USE OF THE SOFTWARE, EVEN IF IT HAS
+ * BEEN OR IS HEREAFTER ADVISED OF THE POSSIBILITY OF SUCH DAMAGES
+ *
+ * The names and trademarks of copyright holders or authors may NOT be
+ * used in advertising or publicity pertaining to the software without
+ * specific, written prior permission. Title to copyright in this software
+ * and any associated documentation will at all times remain with copyright
+ * holders.
+ */
+
+
+
+// Compute start + mult*q and add x for the number of times it 
+// wraps around 0.  This can probably be optimized.
+#ifdef WIN32
+static __inline dm_angle_t 
+#else
+static inline dm_angle_t 
+#endif
+addmult(dm_angle_t start, int mult, dm_angle_t q, dm_angle_t x) 
+{
+  //  int c;
+  dm_angle_t result = start;
+  long long tmp = (long long)start + mult * (long long)q;
+  long long max = (long long)1 << 32;
+  
+
+
+/*    for(c = 0; c < mult; c++) { */
+/*      tmp = result + q; */
+/*      if(tmp < result) { */
+/*        result = tmp + x; */
+/*      } */
+/*      else { */
+/*        result = tmp; */
+/*      } */
+/*    } */
+  
+  return result + mult * q + (tmp / max) * x;
+}
+
+// optimize these someday (binsearch, maybe)
+static struct dm_layout_g1_band *
+find_band_lbn(struct dm_layout_g1 *l, int lbn)
+{
+  struct dm_layout_g1_band *b = &l->bands[0];
+  int bandstart = 0;
+  int bandno = 0;
+
+  while((lbn >= b->blksinband) || (lbn < 0)) {
+    bandstart += b->blksinband;
+    lbn -= b->blksinband;
+    bandno++;
+    b = &l->bands[bandno];
+    ddbg_assert(bandno < l->bands_len);
+    ddbg_assert(lbn >= 0);
+  }
+  
+  return b;
+}
+
+static int 
+g1_st_lbn(struct dm_disk_if *d, int lbn) {
+  struct dm_layout_g1 *l = (struct dm_layout_g1 *)d->layout;
+  struct dm_layout_g1_band *b = find_band_lbn(l, lbn);
+  return b->blkspertrack;
+}
+
+
+static struct dm_layout_g1_band *
+find_band_pbn(struct dm_layout_g1 *l, struct dm_pbn *p)
+{
+  int c;
+  for(c = 0; c < l->bands_len; c++) {
+    if((p->cyl >= l->bands[c].startcyl) &&
+       (p->cyl <= l->bands[c].endcyl)) 
+      {
+	return &l->bands[c];
+      }
+  }
+
+  ddbg_assert2(0, "band not found!");
+  return 0;
+}
+
+
+static int 
+g1_st_pbn(struct dm_disk_if *d, struct dm_pbn *p) {
+  struct dm_layout_g1 *l = (struct dm_layout_g1 *)d->layout;
+  struct dm_pbn p2 = *p;
+  struct dm_layout_g1_band *b;
+
+  while(!(b = find_band_pbn(l, &p2)) && p2.cyl >= 0) { p2.cyl--; }
+  ddbg_assert(b);
+
+
+  return b->blkspertrack;
+}
+
+
+
+
+static int g1_surfno_on_cyl(struct dm_layout_g1 *d,
+			    struct dm_layout_g1_band *b, 
+			    struct dm_pbn *p)
+{
+
+  switch(d->mapping) {
+  case LAYOUT_CYLSWITCHONSURF1:
+    if((p->cyl - b->startcyl) % 2) {
+      return (d->disk->dm_surfaces - p->head - 1);
+    }  
+    break;
+
+  case LAYOUT_CYLSWITCHONSURF2:
+    if(p->cyl % 2) {
+      return (d->disk->dm_surfaces - p->head - 1);
+    }
+    break;
+
+  default: break;
+  }
+  return p->head;
+}
+
+
+static dm_angle_t
+g1_map_pbn_skew(struct dm_disk_if *d, 
+		struct dm_pbn *p)
+{
+  struct dm_layout_g1 *l = (struct dm_layout_g1 *)d->layout;
+  struct dm_pbn pbn = *p;
+  struct dm_layout_g1_band *b = find_band_pbn(l, p);
+  int trackswitches;
+
+  dm_angle_t result = b->firstblkangle;
+
+  int slipoffs = 0;
+
+
+
+  switch (l->mapping) {
+  case LAYOUT_NORMAL:
+  case LAYOUT_CYLSWITCHONSURF1:
+  case LAYOUT_CYLSWITCHONSURF2:
+    {
+      //      int c;
+      // relative to the start of the zone...
+      int cylno = p->cyl - b->startcyl;
+      pbn.cyl -= b->startcyl;
+      pbn.head = g1_surfno_on_cyl(l, b, p);
+      
+      trackswitches = pbn.head + (d->dm_surfaces - 1) * pbn.cyl;
+
+      result = addmult(result, trackswitches, b->trackskew, b->trkspace);
+      result = addmult(result, pbn.cyl, b->cylskew, b->trkspace);
+
+      /* The following assumes that slips also push skew forward in
+       * some schemes 
+       */
+      if ((issectpercyl(l)) 
+	  || (l->sparescheme == SECTPERTRACK_SPARING)) {
+	
+	int tracks = cylno * d->dm_surfaces;
+	int cutoff;
+	int i;
+	
+	if (l->sparescheme == SECTPERTRACK_SPARING) {
+	  tracks += p->head;
+	}
+
+	// not quite accurate; the cutoff should be the lbn
+	// corresponding to p
+	cutoff = tracks * b->blkspertrack;
+	for (i = 0; i < b->numslips; i++) {
+	  if (b->slip[i] < cutoff) {
+	    slipoffs++;
+	  }
+	}
+      }
+      result = addmult(result, slipoffs, b->sector_width, b->trkspace);
+      
+    }
+    break;
+
+
+  default:
+    ddbg_assert(0);
+  }
+
+  result = addmult(result, pbn.sector, b->sector_width, b->trkspace);
+
+  return result;
+}
+		     
+
+static dm_angle_t 
+g1_get_track_0l(struct dm_disk_if *d, 
+		struct dm_mech_state *track)
+{
+  //  struct dm_layout_g1 *l = (struct dm_layout_g1 *)d->layout;
+  struct dm_pbn pbn;
+  //  struct dm_layout_g1_band *b;
+  //  int trackswitches;
+  //  dm_angle_t result;
+  //  int slipoffs = 0;
+  
+  pbn.head = track->head;
+  pbn.cyl = track->cyl;
+  pbn.sector = 0;
+
+  return d->layout->dm_pbn_skew(d, &pbn);
+}
+
+
+
+
+static void
+g1_convert_ptoa(struct dm_disk_if *d, 
+		struct dm_pbn *p,
+		dm_angle_t *angle,
+		dm_angle_t *width)
+{
+  struct dm_layout_g1 *l = (struct dm_layout_g1 *)d->layout;
+  struct dm_pbn pbn = *p;
+  struct dm_layout_g1_band *b = find_band_pbn(l, p);
+
+  dm_angle_t result = b->firstblkangle;
+
+  int slipoffs = 0;
+
+  p = &pbn;
+
+  switch (l->mapping) {
+  case LAYOUT_NORMAL:
+  case LAYOUT_CYLSWITCHONSURF1:
+  case LAYOUT_CYLSWITCHONSURF2:
+    p->cyl -= b->startcyl;
+
+    /* The following assumes that slips also push skew forward in
+     * some schemes 
+     */
+    if ((issectpercyl(l)) 
+	|| (l->sparescheme == SECTPERTRACK_SPARING)) {
+
+      int tracks = p->cyl * d->dm_surfaces;
+      int cutoff;
+      int i;
+ 
+      if (l->sparescheme == SECTPERTRACK_SPARING) {
+	tracks += p->head;
+      }
+      cutoff = tracks * b->blkspertrack;
+      for (i = 0; i < b->numslips; i++) {
+	if (b->slip[i] < cutoff) {
+	  slipoffs++;
+	}
+      }
+    }
+    result = addmult(result, slipoffs, b->sector_width, b->trkspace);
+    break;
+
+
+  default:
+    ddbg_assert(0);
+  }
+
+  result = addmult(result, pbn.sector, b->sector_width, b->trkspace);
+  
+
+  if(angle) *angle = result;
+  ddbg_assert2(width == 0, "unimplemented");
+}
+
+static dm_ptol_result_t
+g1_convert_atop(struct dm_disk_if *d,
+		struct dm_mech_state *a,
+		struct dm_pbn *result)
+{
+  //  int trackswitches;
+  struct dm_pbn track;
+  struct dm_layout_g1_band *b;
+  dm_angle_t angle;
+
+  int slipoffs = 0;
+  struct dm_layout_g1 *l = (struct dm_layout_g1 *)d->layout;
+
+
+  track.cyl = a->cyl;
+  track.head = a->head;
+
+  b = find_band_pbn(l, &track);
+
+  angle = a->theta - b->firstblkangle;
+
+  switch (l->mapping) {
+  case LAYOUT_NORMAL:
+  case LAYOUT_CYLSWITCHONSURF1:
+  case LAYOUT_CYLSWITCHONSURF2:
+
+    /* The following assumes that slips also push skew forward in
+     * some schemes 
+     */
+    if ((issectpercyl(l)) 
+	|| (l->sparescheme == SECTPERTRACK_SPARING)) {
+
+      int tracks = track.cyl * d->dm_surfaces;
+      int cutoff;
+      int i;
+ 
+      if (l->sparescheme == SECTPERTRACK_SPARING) {
+	tracks -= track.head;
+      }
+      // count the slips
+      cutoff = tracks * b->blkspertrack;
+      for (i = 0; i < b->numslips; i++) {
+	if (b->slip[i] < cutoff) {
+	  slipoffs++;
+	}
+      }
+    }
+    // subtract out the slips
+    angle -= addmult(0, slipoffs, b->sector_width, b->trkspace);
+    break;
+
+
+  default:
+    ddbg_assert(0);
+  }
+
+  result->cyl = a->cyl;
+  result->head = a->head;
+  // rounds angle down to lower sector boundary
+  result->sector = (angle / (b->sector_width)) % b->blkspertrack;
+
+  // if skews are not in whole sectors, we need to round up here
+  if((b->trackskew % b->sector_width)
+     || (b->cylskew % b->sector_width)) {
+    if((angle % b->sector_width) > 0) {
+      result->sector = ((result->sector+1) % b->blkspertrack);
+    }
+  }
+
+  // XXX ... check that angle isn't a defect
+  return DM_OK;
+}
+
+
+
+static dm_ptol_result_t
+g1_ptol_0t(struct dm_disk_if *d, 
+	   struct dm_pbn *p,
+	   int *remapsector)
+{
+  dm_angle_t zerol;
+  //  long long max = ((long long)1 << 32);
+
+  struct dm_mech_state a;
+  struct dm_pbn p2;
+    
+  struct dm_layout_g1 *l = (struct dm_layout_g1 *)d->layout;
+  struct dm_layout_g1_band *b = find_band_pbn(l, p);
+
+  a.theta = p->sector * b->sector_width + b->firstblkangle;
+  zerol = d->layout->dm_get_track_zerol(d, (struct dm_mech_state *)p);
+
+  if(zerol > a.theta) {
+    //    a.theta -= b->trkspace;
+  }
+  a.theta -= zerol;
+
+  a.head = p->head;
+  a.cyl = p->cyl;
+
+  d->layout->dm_convert_atop(d, &a, &p2);
+
+  return d->layout->dm_translate_ptol(d, &p2, remapsector);
+}
+
+/*
+ * The next several functions compute the lbn stored in a physical
+ * media sector <cyl, surf, blk>, for different sparing/mapping
+ * schemes.  The returned value is a proper lbn, or DM_REMAPPED if the
+ * sector is a remapped defect, or DM_SLIPPED if the sector is a
+ * slipped defect or an unused spare.
+ */
+
+static dm_ptol_result_t
+g1_ptol_nosparing(struct dm_disk_if *d, 
+		  struct dm_pbn *p,
+		  int *remapsector)
+
+{
+  struct dm_layout_g1 *l = (struct dm_layout_g1 *)d->layout;
+  struct dm_layout_g1_band *b = find_band_pbn(l, p);
+  int lbn = l->band_blknos[b->num];
+  struct dm_pbn pbn = *p;
+
+  p = &pbn;
+
+
+  ddbg_assert(b);
+  ddbg_assert(p->cyl >= 0);
+  ddbg_assert(p->cyl >= b->startcyl);
+  ddbg_assert(p->cyl < d->dm_cyls);
+  ddbg_assert(p->head >= 0);
+  ddbg_assert(p->head < d->dm_surfaces);
+  ddbg_assert(p->sector >= 0);
+  ddbg_assert(p->sector < b->blkspertrack);
+
+
+  p->head = g1_surfno_on_cyl(l, b, p);
+  
+  lbn += (((p->cyl - b->startcyl) * d->dm_surfaces) + p->head) * b->blkspertrack;
+  lbn += p->sector - b->deadspace;
+
+  if(lbn < 0) {
+    return DM_SLIPPED;
+  }
+  else {
+    return lbn;
+  }
+}
+
+
+
+static dm_ptol_result_t
+g1_ptol_sectpertrackspare(struct dm_disk_if *d, 
+			  struct dm_pbn *p,
+			  int *remapsector)
+{
+  int i;
+  int lbnspercyl;
+  int firstblkoncyl;
+  struct dm_layout_g1 *l = (struct dm_layout_g1 *)d->layout;
+  struct dm_layout_g1_band *b = find_band_pbn(l, p);
+  int lbn = l->band_blknos[b->num];
+  struct dm_pbn pbn = *p;
+  p = &pbn;
+
+  ddbg_assert(b);
+  ddbg_assert(p->cyl >= 0);
+  ddbg_assert(p->cyl >= b->startcyl);
+  ddbg_assert(p->cyl < d->dm_cyls);
+  ddbg_assert(p->head >= 0);
+  ddbg_assert(p->head < d->dm_surfaces);
+  ddbg_assert(p->sector >= 0);
+  ddbg_assert(p->sector < b->blkspertrack);
+
+
+  p->head = g1_surfno_on_cyl(l, b, p);
+  firstblkoncyl = (p->cyl - b->startcyl) * d->dm_surfaces * b->blkspertrack;
+  p->sector += firstblkoncyl + (p->head * b->blkspertrack);
+  for (i=(b->numdefects-1); i>=0; i--) {
+    if (p->sector == b->defect[i]) {        /* Remapped bad block */
+      return DM_REMAPPED;
+    }
+    if(p->sector == b->remap[i]) {
+      if(remapsector) *remapsector = 1;
+      p->sector = b->defect[i];
+      break;
+    }
+  }
+  for (i = (b->numslips-1); i >= 0; i--) {
+    if (p->sector == b->slip[i]) {          /* Slipped bad block */
+      return DM_SLIPPED;
+    }
+    if ((p->sector > b->slip[i]) 
+	&& ((b->slip[i] / (b->blkspertrack * d->dm_surfaces)) == (p->cyl - b->startcyl)) 
+	&& ((b->slip[i] % (b->blkspertrack * d->dm_surfaces)) == p->head)) 
+      {
+	p->sector--;
+      }
+  }
+
+  if((p->sector % b->blkspertrack) >= (b->blkspertrack - b->sparecnt)) {   
+    /* Unused spare block */
+    return DM_SLIPPED;
+  }
+
+  /* recompute in case sector was remapped */
+  p->cyl = p->sector / (b->blkspertrack * d->dm_surfaces);
+  p->head = p->sector % (b->blkspertrack * d->dm_surfaces);
+  p->head = p->head / b->blkspertrack;
+  p->sector = p->sector % b->blkspertrack;
+
+  lbnspercyl = (b->blkspertrack - b->sparecnt) * d->dm_surfaces;
+  lbn += p->cyl * lbnspercyl;
+  lbn += p->head * (b->blkspertrack - b->sparecnt);
+  lbn += p->sector - b->deadspace;
+
+
+  if(lbn < 0) {
+    return DM_SLIPPED;
+  }
+  else {
+    return lbn;
+  }
+}
+
+
+
+static dm_ptol_result_t
+g1_ptol_sectpercylspare(struct dm_disk_if *d, 
+			struct dm_pbn *p,
+			int *remapsector)
+{
+  int i;
+  int lbnspercyl;
+  int blkspercyl;
+  int firstblkoncyl;
+
+  struct dm_layout_g1 *l = (struct dm_layout_g1 *)d->layout;
+  struct dm_layout_g1_band *b = find_band_pbn(l, p);
+  int lbn = l->band_blknos[b->num];
+  struct dm_pbn pbn = *p;
+  p = &pbn;
+
+  /*    ddbg_assert(b); */
+  /*    ddbg_assert(p->cyl >= 0); */
+  /*    ddbg_assert(p->cyl >= b->startcyl); */
+  /*    ddbg_assert(p->cyl < d->numcyls); */
+  /*    ddbg_assert(surfaceno >= 0); */
+  /*    ddbg_assert(surfaceno < d->dm_surfaces); */
+  /*    ddbg_assert(p->sector >= 0); */
+  /*    ddbg_assert(p->sector < b->blkspertrack); */
+
+
+  //printf ("ptol_sectpercylspare: p->cyl %d, surfaceno %d, p->sector %d, lbn %d\n", p->cyl, surfaceno, p->sector, lbn);
+
+  p->head = g1_surfno_on_cyl(l, b, p);
+  blkspercyl = b->blkspertrack * d->dm_surfaces;
+  lbnspercyl = blkspercyl - b->sparecnt;
+  firstblkoncyl = (p->cyl - b->startcyl) * blkspercyl;
+  p->sector += firstblkoncyl + (p->head * b->blkspertrack);
+
+  for (i = (b->numdefects - 1); i >= 0; i--) {
+    if (p->sector == b->defect[i]) {        /* Remapped bad block */
+      return DM_REMAPPED;
+    }
+    if (p->sector == b->remap[i]) {
+      if(remapsector) *remapsector = 1;
+      p->sector = b->defect[i];
+      break;
+    }
+  }
+
+  for (i = (b->numslips - 1); i >= 0; i--) {
+    if (p->sector == b->slip[i]) {          /* Slipped bad block */
+      return DM_SLIPPED;
+    }
+    if (p->sector > b->slip[i]) {
+      if ((b->slip[i] / blkspercyl) == (p->cyl - b->startcyl)) {
+	p->sector--;
+      } else if (issliptoend(l)) {
+	lbn--;
+      }
+    }
+  }
+
+  /* check for unused spare blocks */
+  if (((!isspareatfront(l)) && 
+       ((p->sector % blkspercyl) >= lbnspercyl)) 
+      ||
+      ((isspareatfront(l)) && 
+       ((p->sector % blkspercyl) < b->sparecnt)))
+    {
+      return DM_SLIPPED;
+    }
+   
+  /* recompute in case sector was remapped */
+  p->cyl = p->sector / blkspercyl;
+  p->head = p->sector % blkspercyl;
+  p->head = p->head / b->blkspertrack;
+  p->sector = p->sector % b->blkspertrack;
+
+  lbn += p->cyl * lbnspercyl;
+  lbn += p->head * b->blkspertrack;
+  lbn += p->sector - b->deadspace;
+  lbn -= (isspareatfront(l)) ? b->sparecnt : 0;
+
+
+  if(lbn < 0) {
+    return DM_SLIPPED;
+  }
+  else {
+    return lbn;
+  }
+}
+
+
+static dm_ptol_result_t
+g1_ptol_sectperrangespare(struct dm_disk_if *d, 
+			  struct dm_pbn *p,
+			  int *remapsector)
+{
+  int i;
+  int lbnsperrange;
+  int blksperrange;
+  int blkspercyl;
+  int firstblkoncyl;
+  int rangeno;
+  
+  struct dm_layout_g1 *l = (struct dm_layout_g1 *)d->layout;
+  struct dm_layout_g1_band *b = find_band_pbn(l, p);
+  int lbn = l->band_blknos[b->num];
+
+  struct dm_pbn pbn = *p;
+  p = &pbn;
+
+
+  ddbg_assert(b);
+  ddbg_assert(p->cyl >= 0);
+  ddbg_assert(p->cyl >= b->startcyl);
+  ddbg_assert(p->cyl < d->dm_cyls);
+  ddbg_assert(p->head >= 0);
+  ddbg_assert(p->head < d->dm_surfaces);
+  ddbg_assert(p->sector >= 0);
+  ddbg_assert(p->sector < b->blkspertrack);
+
+
+  p->head = g1_surfno_on_cyl(l, b, p);
+  blkspercyl = b->blkspertrack * d->dm_surfaces;
+  blksperrange = blkspercyl * l->rangesize;
+  lbnsperrange = blksperrange - b->sparecnt;
+  rangeno = (p->cyl - b->startcyl) / l->rangesize;
+
+  firstblkoncyl = (p->cyl - b->startcyl) * blkspercyl;
+  p->sector += firstblkoncyl + (p->head * b->blkspertrack);
+
+  for (i=(b->numdefects-1); i>=0; i--) {
+    if (p->sector == b->defect[i]) {        /* Remapped bad block */
+      return DM_REMAPPED;
+    }
+    if (p->sector == b->remap[i]) {
+      if(remapsector) *remapsector = 1;
+      p->sector = b->defect[i];
+      break;
+    }
+  }
+
+  for (i=(b->numslips-1); i>=0; i--) {
+    if (p->sector == b->slip[i]) {          /* Slipped bad block */
+      return DM_SLIPPED;
+    }
+    if (p->sector > b->slip[i]) {
+      if ((b->slip[i] / blksperrange) == rangeno) {
+	p->sector--;
+      }
+    }
+  }
+
+  p->sector = p->sector % blksperrange;
+
+  /* check for unused spare blocks */
+  if (p->sector >= lbnsperrange) {
+    return DM_SLIPPED;
+  }
+
+  lbn += rangeno * lbnsperrange;
+  lbn += p->sector - b->deadspace;
+
+  if(lbn < 0) {
+    return DM_SLIPPED;
+  }
+  else {
+    return lbn;
+  }
+}
+
+
+static dm_ptol_result_t
+g1_ptol_sectperzonespare(struct dm_disk_if *d, 
+			 struct dm_pbn *p,
+			 int *remapsector)
+{
+  int i;
+  int blkspercyl;
+  int firstblkoncyl;
+
+  struct dm_layout_g1 *l = (struct dm_layout_g1 *)d->layout;
+  struct dm_layout_g1_band *b = find_band_pbn(l, p);
+  int lbn = l->band_blknos[b->num];
+
+  struct dm_pbn pbn = *p;
+  p = &pbn;
+
+
+  ddbg_assert(b);
+  ddbg_assert(p->cyl >= 0);
+  ddbg_assert(p->cyl >= b->startcyl);
+  ddbg_assert(p->cyl < d->dm_cyls);
+  ddbg_assert(p->head >= 0);
+  ddbg_assert(p->head < d->dm_surfaces);
+  ddbg_assert(p->sector >= 0);
+  ddbg_assert(p->sector < b->blkspertrack);
+
+
+  //printf ("ptol_sectperzonespare: p->cyl %d, p->head %d, p->sector %d, lbn %d\n", p->cyl, p->head, p->sector, lbn);
+
+  /* compute p->sector within zone 
+   * i.e. counting sectors from start of zone
+   */
+  p->head = g1_surfno_on_cyl(l, b, p);
+  blkspercyl = b->blkspertrack * d->dm_surfaces;
+  firstblkoncyl = (p->cyl - b->startcyl) * blkspercyl;
+  p->sector += firstblkoncyl + (p->head * b->blkspertrack);
+
+  for (i = (b->numdefects - 1); i >= 0; i--) {
+    if (p->sector == b->defect[i]) {        /* Remapped bad block */
+      return DM_REMAPPED;
+    }
+    if (p->sector == b->remap[i]) {
+      if(remapsector) *remapsector = 1;
+      p->sector = b->defect[i];
+      break;
+    }
+  }
+
+  for (i=(b->numslips-1); i>=0; i--) {
+    if (p->sector == b->slip[i]) {          /* Slipped bad block */
+      return DM_SLIPPED;
+    }
+    if (p->sector > b->slip[i]) {
+      p->sector--;
+    }
+  }
+
+  /* check for unused spare blocks */
+  if (p->sector >= b->blksinband) {
+    return DM_SLIPPED;
+  }
+
+  lbn += p->sector - b->deadspace;
+
+  if(lbn < 0) {
+    return DM_SLIPPED;
+  }
+  else {
+    return lbn;
+  }
+}
+
+
+static dm_ptol_result_t
+g1_ptol_trackspare(struct dm_disk_if *d, 
+		   struct dm_pbn *p,
+		   int *remapsector)
+{
+  int i;
+  int trackno;
+  int lasttrack;
+
+  struct dm_layout_g1 *l = (struct dm_layout_g1 *)d->layout;
+  struct dm_layout_g1_band *b = find_band_pbn(l, p);
+  int lbn = l->band_blknos[b->num];
+
+  struct dm_pbn pbn = *p;
+  p = &pbn;
+
+  ddbg_assert(b);
+  ddbg_assert(p->cyl >= 0);
+  ddbg_assert(p->cyl >= b->startcyl);
+  ddbg_assert(p->cyl < d->dm_cyls);
+  ddbg_assert(p->head >= 0);
+  ddbg_assert(p->head < d->dm_surfaces);
+  ddbg_assert(p->sector >= 0);
+  ddbg_assert(p->sector < b->blkspertrack);
+
+
+  p->head = g1_surfno_on_cyl (l, b, p);
+  trackno = (p->cyl - b->startcyl) * d->dm_surfaces + p->head;
+  for (i=(b->numdefects-1); i>=0; i--) {
+    if (trackno == b->defect[i]) {   /* Remapped bad track */
+      return DM_REMAPPED;
+    }
+    if (trackno == b->remap[i]) {
+      trackno = b->defect[i];
+      break;
+    }
+  }
+  for (i=(b->numslips-1); i>=0; i--) {
+    if (trackno == b->slip[i]) {     /* Slipped bad track */
+      return DM_SLIPPED;
+    }
+    if (trackno > b->slip[i]) {
+      trackno--;
+    }
+  }
+  lasttrack = (b->blksinband + b->deadspace) / b->blkspertrack;
+  if (trackno > lasttrack) {                 /* Unused spare track */
+    return DM_SLIPPED;
+  }
+  lbn += p->sector + (trackno * b->blkspertrack) - b->deadspace;
+
+  if(lbn < 0) {
+    return DM_SLIPPED;
+  }
+  else {
+    return lbn;
+  }
+}
+
+
+
+/*
+ *                                                                          
+ * The next several functions compute the lbn boundaries (first and
+ * last) for a given physical track <cyl, surf>, for different
+ * sparing/mapping schemes.  The start and end values are proper lbns,
+ * or DM_REMAPPED if the entire track consists of remapped defects, or
+ * DM_SLIPPED if the entire track consists of slipped defects or
+ * unused spare space.  Note: the lbns returned account for slippage
+ * but purposefully ignore remapping of sectors to other tracks.
+ *                                                                          
+ * Note: the per-scheme functions take a pointer to the relevant band
+ *  and the first lbn in that band, in addition to the basic
+ *  parameters.  
+ *                                                                          
+ * These functions are organized by sparing scheme ... though we could
+ * potentially have the cross-product of sparing and mapping schemes,
+ * normal, cylcswitchonsurf1 and cylswitchonsurf2 all share the per-
+ * sparing-scheme implementations.  (bucy 1/02)
+ * */
+
+/* Assume that we never slip sectors over track boundaries! */
+
+
+
+dm_ptol_result_t
+g1_track_boundaries_nosparing(struct dm_disk_if *d,
+			      struct dm_pbn *p,
+			      int *first_lbn,
+			      int *last_lbn,
+			      int *remapsector)
+{
+
+  struct dm_layout_g1 *l = (struct dm_layout_g1 *)d->layout;
+  struct dm_layout_g1_band *b = find_band_pbn(l, p);
+  int lbn = l->band_blknos[b->num];
+  int temp_lbn = lbn;
+
+  //  int lbnspertrack = b->blkspertrack - b->sparecnt;
+
+  struct dm_pbn pbn = *p;
+  p = &pbn;
+
+  // this implementation lived in disk_get_lbn_boundaries_for_track
+
+  p->head = g1_surfno_on_cyl(l, b, p);
+  lbn += ((((p->cyl - b->startcyl) * d->dm_surfaces) + p->head) * 
+	  b->blkspertrack) - b->deadspace;
+
+  if(first_lbn) {
+    *first_lbn = 
+      ((lbn + b->blkspertrack) <= temp_lbn) 
+      ? DM_SLIPPED
+      : max(lbn, temp_lbn);
+  }
+
+  if(last_lbn) {
+    lbn += (b->blkspertrack - 1);
+    *last_lbn = (lbn <= temp_lbn) ? DM_SLIPPED : lbn;
+  }
+
+  return DM_OK;
+}
+
+dm_ptol_result_t
+g1_track_boundaries_sectpertrackspare(struct dm_disk_if *d,
+				      struct dm_pbn *p,
+				      int *first_lbn,
+				      int *last_lbn,
+				      int *remapsector)
+
+{
+  /* lbn equals first block in band */
+  int i;
+  //  int blkno;
+
+  struct dm_layout_g1 *l = (struct dm_layout_g1 *)d->layout;
+  struct dm_layout_g1_band *b = find_band_pbn(l, p);
+  int lbn = l->band_blknos[b->num];
+  int temp_lbn = lbn;
+
+  int lbnspertrack = b->blkspertrack - b->sparecnt;
+
+  struct dm_pbn pbn = *p;
+  p = &pbn;
+
+
+  p->head = g1_surfno_on_cyl(l, b, p);
+  lbn += ((((p->cyl - b->startcyl) * d->dm_surfaces) + p->head) 
+	  * lbnspertrack) - b->deadspace;
+
+  if (first_lbn) {
+    *first_lbn = ((lbn + lbnspertrack) <= temp_lbn) 
+      ? DM_SLIPPED 
+      : max(temp_lbn, lbn);
+  }
+
+  if (last_lbn) {
+    lbn += (lbnspertrack - 1);
+    *last_lbn = (lbn <= temp_lbn) ? DM_SLIPPED : lbn;
+  }
+
+  p->sector = (((p->cyl - b->startcyl) * d->dm_surfaces) 
+	       + p->head) * b->blkspertrack;
+
+  for (i = 0; i < b->numdefects; i++) {
+    if ((p->sector <= b->defect[i]) 
+	&& ((p->sector + b->blkspertrack) > b->defect[i])) {
+      if(remapsector) *remapsector = 1;
+    }
+  }
+  return DM_OK;
+}
+
+
+dm_ptol_result_t
+g1_track_boundaries_sectpercylspare(struct dm_disk_if *d,
+				    struct dm_pbn *p,
+				    int *first_lbn,
+				    int *last_lbn,
+				    int *remapsector)
+
+{
+  /* lbn equals first block in band */
+  int i;
+  int blkno = 0;
+  int lbnadd;
+
+  struct dm_layout_g1 *l = (struct dm_layout_g1 *)d->layout;
+  struct dm_layout_g1_band *b = find_band_pbn(l, p);
+  int lbn = l->band_blknos[b->num];
+  int temp_lbn = lbn;
+
+  //  int lbnspertrack = b->blkspertrack - b->sparecnt;
+
+  struct dm_pbn pbn = *p;
+  p = &pbn;
+
+
+  if (first_lbn) {
+    lbnadd = 0;
+    // use brute force -- back translate each pbn to figure out startlbn
+    for (blkno = 0; blkno < b->blkspertrack; blkno++) {
+      int remapsector2 = 0;
+      p->sector = blkno;
+      *first_lbn = g1_ptol_sectpercylspare(d, p, &remapsector2);
+					    
+      if ((*first_lbn) == DM_REMAPPED) {
+	lbnadd++;
+      }
+
+      if (remapsector2) {
+      	*first_lbn = DM_SLIPPED;
+      }
+      if ((*first_lbn) >= 0) {
+	*first_lbn = max(((*first_lbn) - lbnadd), temp_lbn);
+	break;
+      }
+    }
+    if (p->sector == b->blkspertrack) {
+      *first_lbn = DM_SLIPPED;
+    }
+  }
+  if (last_lbn) {
+    // was 1, want the last block on this track rather than
+    // the first of the next.  bucy 200208
+    lbnadd = 0;
+    /* use brute force -- back translate each pbn to figure out endlbn */
+    for (p->sector = (b->blkspertrack-1); p->sector >= 0; p->sector--) {
+      int remapsector2 = 0;
+      *last_lbn = g1_ptol_sectpercylspare(d, p, &remapsector2);
+      if ((*last_lbn) == DM_REMAPPED) {
+	lbnadd++;
+      }
+
+      if (remapsector2) {
+      	*last_lbn = DM_SLIPPED;
+      }
+
+      if ((*last_lbn) >= 0) {
+	*last_lbn = (*last_lbn) + lbnadd;
+	break;
+      }
+    }
+    if (p->sector == DM_SLIPPED) {
+      *last_lbn = DM_SLIPPED;
+    }
+  }
+  p->head = g1_surfno_on_cyl(l, b, p);
+  p->sector = (((p->cyl - b->startcyl) * d->dm_surfaces) + p->head) * b->blkspertrack;
+  for (i = 0; i < b->numdefects; i++) {
+    if ((blkno <= b->defect[i]) && 
+	((blkno + b->blkspertrack) > b->defect[i])) {
+      // XXX global/remapsetor
+      if(remapsector) *remapsector = 1;
+    }
+  }
+
+  return DM_OK;
+}
+
+
+dm_ptol_result_t
+g1_track_boundaries_sectperrangespare(struct dm_disk_if *d,
+				      struct dm_pbn *p,
+				      int *first_lbn,
+				      int *last_lbn,
+				      int *remapsector)
+
+{
+  /* lbn equals first block in band */
+  int i;
+  int blkno;
+  int lbnadd;
+
+
+  struct dm_layout_g1 *l = (struct dm_layout_g1 *)d->layout;
+  struct dm_layout_g1_band *b = find_band_pbn(l, p);
+  int lbn = l->band_blknos[b->num];
+  int temp_lbn = lbn;
+
+  //  int lbnspertrack = b->blkspertrack - b->sparecnt;
+
+  struct dm_pbn pbn = *p;
+  p = &pbn;
+
+  if (first_lbn) {
+    lbnadd = 0;
+    /* use brute force -- back translate each pbn to figure out startlbn */
+    for (blkno = 0; blkno < b->blkspertrack; blkno++) {
+      int remapsector2 = 0;
+      p->sector = blkno;
+      *first_lbn = g1_ptol_sectperrangespare(d,p,&remapsector2);
+      if ((*first_lbn) == DM_REMAPPED) {
+	lbnadd++;
+      }
+
+      if (remapsector2) {
+      	*first_lbn = DM_SLIPPED;
+      }
+      if ((*first_lbn) >= 0) {
+	*first_lbn = max(((*first_lbn) - lbnadd), temp_lbn);
+	break;
+      }
+    }
+    if (blkno == b->blkspertrack) {
+      *first_lbn = DM_SLIPPED;
+    }
+  }
+  if (last_lbn) {
+    // was 1, want the last block on this track rather than
+    // the first of the next.  bucy 200208
+    lbnadd = 0;
+    /* use brute force -- back translate each pbn to figure out endlbn */
+    for (p->sector = (b->blkspertrack-1); p->sector >= 0; p->sector--) {
+      int remapsector2 = 0;
+      *last_lbn = g1_ptol_sectperrangespare(d,p,&remapsector2);
+					    
+      if ((*last_lbn) == DM_REMAPPED) {
+	lbnadd++;
+      }
+      if (remapsector2) {
+      	*last_lbn = DM_SLIPPED;
+      }
+      if ((*last_lbn) >= 0) {
+	*last_lbn = (*last_lbn) + lbnadd;
+	break;
+      }
+    }
+    if (blkno == DM_SLIPPED) {
+      *last_lbn = DM_SLIPPED;
+    }
+  }
+  p->head = g1_surfno_on_cyl(l, b, p);
+  p->sector = (((p->cyl - b->startcyl) * d->dm_surfaces) + p->head) * b->blkspertrack;
+  for (i = 0; i < b->numdefects; i++) {
+    if ((p->sector <= b->defect[i]) && ((p->sector + b->blkspertrack) > b->defect[i])) {
+      if(remapsector) *remapsector = 1;
+    }
+  }
+  return DM_OK;
+}
+
+
+
+dm_ptol_result_t
+g1_track_boundaries_sectperzonespare(struct dm_disk_if *d,
+				     struct dm_pbn *p,
+				     int *first_lbn,
+				     int *last_lbn,
+				     int *remapsector)
+{
+  /* lbn equals first block in band */
+  int i;
+  //  int blkno;
+  int lbnadd;
+
+  struct dm_layout_g1 *l = (struct dm_layout_g1 *)d->layout;
+  struct dm_layout_g1_band *b = find_band_pbn(l, p);
+  int lbn = l->band_blknos[b->num];
+  int temp_lbn = lbn;
+
+  //  int lbnspertrack = b->blkspertrack - b->sparecnt;
+
+  struct dm_pbn pbn = *p;
+  p = &pbn;
+
+
+  if (first_lbn) {
+    lbnadd = 0;
+    /* use brute force -- back translate each pbn to figure out startlbn */
+    for (p->sector = 0; p->sector < b->blkspertrack; p->sector++) {
+      int remapsector2 = 0;
+      *first_lbn = g1_ptol_sectperzonespare(d, p, &remapsector2);
+      if ((*first_lbn) == DM_REMAPPED) {
+	lbnadd++;
+      }
+      if (remapsector2) {
+      	*first_lbn = DM_SLIPPED;
+      }
+      if ((*first_lbn) >= 0) {
+	*first_lbn = max(((*first_lbn) - lbnadd), temp_lbn);
+	break;
+      }
+    }
+
+    if(p->sector == b->blkspertrack) {
+      *first_lbn = DM_SLIPPED;
+    }
+
+  } // find first_lbn
+
+  if (last_lbn) {
+    // was 1, want the last block on this track rather than
+    // the first of the next.  bucy 200208
+    lbnadd = 0;
+    /* use brute force -- back translate each pbn to figure out endlbn */
+    for (p->sector = (b->blkspertrack - 1); p->sector >= 0; p->sector--) 
+      {
+	// XXX global/remapsector
+	int remapsector2 = 0;
+	*last_lbn = g1_ptol_sectperzonespare(d,p,&remapsector2);
+	if ((*last_lbn) == DM_REMAPPED) {
+	  lbnadd++;
+	}
+
+	if (remapsector2) {
+	  *last_lbn = DM_SLIPPED;
+	}
+	if ((*last_lbn) >= 0) {
+	  *last_lbn = (*last_lbn) + lbnadd;
+	  break;
+	}
+      }
+
+    //    if (blkno == DM_SLIPPED) {
+    //      *last_lbn = DM_SLIPPED;
+    //    }
+
+  } // find last_lbn
+
+  p->head = g1_surfno_on_cyl(l,b,p);
+  p->sector = (((p->cyl - b->startcyl) * d->dm_surfaces) + p->head) * b->blkspertrack;
+  for (i = 0; i < b->numdefects; i++) {
+    if ((p->sector <= b->defect[i]) && 
+	((p->sector + b->blkspertrack) > b->defect[i])) 
+      {
+	if(remapsector) *remapsector = 1;
+      }
+  }
+  return DM_OK;
+}
+
+
+dm_ptol_result_t
+g1_track_boundaries_trackspare(struct dm_disk_if *d,
+			       struct dm_pbn *p,
+			       int *first_lbn,
+			       int *last_lbn,
+			       int *remapsector)
+{
+  int i;
+  int trackno;
+  int lasttrack;
+  //  int blkno;
+
+  struct dm_layout_g1 *l = (struct dm_layout_g1 *)d->layout;
+  struct dm_layout_g1_band *b = find_band_pbn(l, p);
+  int lbn = l->band_blknos[b->num];
+
+  //  int lbnspertrack = b->blkspertrack - b->sparecnt;
+
+  struct dm_pbn pbn = *p;
+  p = &pbn;
+
+
+  p->head = g1_surfno_on_cyl(l,b,p);
+  trackno = ((p->cyl - b->startcyl) * d->dm_surfaces) + p->head;
+
+  for(i = (b->numdefects - 1); i >= 0; i--) {
+    if(trackno == b->defect[i]) {   /* Remapped bad track */
+      lbn = DM_REMAPPED;
+    }
+    if(trackno == b->remap[i]) {
+      trackno = b->defect[i];
+      break;
+    }
+  }
+
+  for(i = (b->numslips-1); i >= 0; i--) {
+    if(trackno == b->slip[i]) {     /* Slipped bad track */
+      lbn = DM_SLIPPED;
+    }
+    if(trackno > b->slip[i]) {
+      trackno--;
+    }
+  }
+
+  lasttrack = (b->blksinband + b->deadspace) / b->blkspertrack;
+
+  if(trackno > lasttrack) {                 /* Unused spare track */
+    lbn = DM_SLIPPED;
+  }
+
+  p->sector = lbn + (trackno * b->blkspertrack) - b->deadspace;
+
+
+
+  if(first_lbn) {
+    if(lbn < 0) {
+      *first_lbn = lbn;
+    }
+    else {
+      *first_lbn = ((p->sector + b->blkspertrack) <= lbn) 
+	? DM_SLIPPED 
+	: max(p->sector, lbn);
+    }
+  }
+
+  if(last_lbn) {
+    p->sector += (b->blkspertrack - 1);
+    if(lbn < 0) {
+      *last_lbn = lbn;
+    }
+    else {
+      *last_lbn = (p->sector <= lbn) 
+	? DM_SLIPPED 
+	: p->sector;
+    }
+  }
+
+
+
+  return DM_OK;
+}
+
+
+
+static dm_ptol_result_t
+g1_ltop_0t(struct dm_disk_if *d, 
+		  int lbn, 
+		  dm_layout_maptype maptype,
+		  struct dm_pbn *result,
+		  int *remapsector)
+{
+  //  long long max = (long long)1 << 32;
+  dm_angle_t a;
+
+  struct dm_layout_g1 *l = (struct dm_layout_g1 *)d->layout;
+  struct dm_layout_g1_band *b = find_band_lbn(l, lbn);  
+
+  d->layout->dm_translate_ltop(d,lbn,maptype,result,remapsector);
+  a = d->layout->dm_pbn_skew(d,result);
+
+  result->sector = (a / b->sector_width) % b->blkspertrack;
+  if((a % b->sector_width) > 0) {
+    result->sector = (result->sector + 1) % b->blkspertrack;
+  }
+  return DM_OK;
+}
+
+
+/*
+ * The next several functions compute the physical media location to
+ * which a given lbn (blkno) is mapped for different sparing/mapping
+ * schemes.  The returned value is a proper lbn, or DM_REMAPPED if the
+ * sector is a remapped defect, or DM_SLIPPED if the sector is a slipped
+ * defect or an unused spare.
+ */
+
+/*
+ * NOTE: No slipping beyond the end of a track is allowed.  The
+ * following code will produce incorrect results if this rule is
+ * violated.  To fix this, trackno needs to be recomputed after slips
+ * and slips on immediately previous tracks need to be accounted for.
+ * Low Priority.  
+ */
+
+static dm_ptol_result_t
+g1_ltop_nosparing(struct dm_disk_if *d, 
+		  int lbn, 
+		  dm_layout_maptype maptype,
+		  struct dm_pbn *result,
+		  int *remapsector)
+{
+  int blkspertrack;
+  struct dm_layout_g1 *l = (struct dm_layout_g1 *)d->layout;
+  struct dm_layout_g1_band *b = find_band_lbn(l, lbn);
+  struct dm_pbn pbn = *result;
+  result = &pbn;
+
+  lbn -= l->band_blknos[b->num];
+  lbn += b->deadspace;
+
+  blkspertrack = b->blkspertrack;
+  result->cyl = lbn / (blkspertrack * d->dm_surfaces) + b->startcyl;
+
+  result->cyl = (lbn / blkspertrack) % d->dm_surfaces;
+  result->cyl = g1_surfno_on_cyl(l,b,result);
+  result->sector = lbn % blkspertrack;
+
+  return DM_OK;
+}
+
+
+static dm_ptol_result_t
+g1_ltop_sectpertrackspare(struct dm_disk_if *d, 
+			  int lbn, 
+			  dm_layout_maptype maptype,
+			  struct dm_pbn *result,
+			  int *remapsector)
+{
+  int i, trackno;
+  int firstblkontrack = -1;
+  
+
+  struct dm_layout_g1 *l = (struct dm_layout_g1 *)d->layout;
+  struct dm_layout_g1_band *b = find_band_lbn(l, lbn);
+
+  int blkspertrack = b->blkspertrack;
+  int lbnspertrack = blkspertrack - b->sparecnt;
+
+  lbn -= l->band_blknos[b->num];
+  lbn += b->deadspace;
+
+  trackno = lbn / lbnspertrack;
+
+
+
+
+  lbn %= lbnspertrack;
+  if ((maptype == MAP_ADDSLIPS) || (maptype == MAP_FULL)) {
+    firstblkontrack = blkspertrack * trackno;
+    for (i=0; i<b->numslips; i++) {
+      if ((b->slip[i] >= firstblkontrack) && 
+	  ((b->slip[i] - firstblkontrack) <= lbn)) 
+	{
+	  lbn++;
+	}
+    }
+  }
+  if(maptype == MAP_FULL) {
+    for(i = 0; i < b->numdefects; i++) {
+      if(b->defect[i] == (firstblkontrack + lbn)) {
+	if(remapsector) *remapsector = 1;
+	trackno = b->remap[i] / blkspertrack;
+	firstblkontrack = blkspertrack * trackno;
+	lbn = b->remap[i] % blkspertrack;
+      }
+    }
+  }
+
+  result->cyl = trackno/d->dm_surfaces + b->startcyl;
+
+  result->head = trackno % d->dm_surfaces;
+  result->head = g1_surfno_on_cyl(l,b,result);
+  
+  
+  if(lbn >= blkspertrack) {
+    //printf("Somehow computed a blkno that crosses to another track\n");
+    //printf("This could be the result of too many slips, or of a bug\n");
+    //printf("in the defect-related computations...\n");
+    ddbg_assert(0);
+  }
+  else {
+    result->sector = lbn;
+  }
+
+  return DM_OK;
+}
+
+
+static dm_ptol_result_t
+g1_ltop_sectpercylspare(struct dm_disk_if *d, 
+			int lbn, 
+			dm_layout_maptype maptype,
+			struct dm_pbn *result,
+			int *remapsector)
+
+{
+  int i;
+  int blkspertrack;
+  int blkspercyl;
+  int lbnspercyl;
+  int firstblkoncyl = 0;
+  int cyl;
+  int slips = 0;
+
+
+  struct dm_layout_g1 *l = (struct dm_layout_g1 *)d->layout;
+  struct dm_layout_g1_band *b = find_band_lbn(l, lbn);
+
+  lbn -= l->band_blknos[b->num];
+  lbn += b->deadspace;
+
+  blkspertrack = b->blkspertrack;
+  blkspercyl = blkspertrack * d->dm_surfaces;
+  lbnspercyl = blkspercyl - b->sparecnt;
+
+  cyl = lbn / lbnspercyl;
+  lbn = lbn % lbnspercyl;
+
+  if ((maptype == MAP_ADDSLIPS) || (maptype == MAP_FULL)) {
+    firstblkoncyl = cyl * blkspertrack * d->dm_surfaces;
+    for (i=0; i<b->numslips; i++) {
+      if (((issliptoend(l)) && 
+	   ((b->slip[i]/blkspercyl) < cyl)) || 
+	  ((b->slip[i] >= firstblkoncyl) && 
+	   ((b->slip[i] - firstblkoncyl) <= (lbn+slips)))) 
+	{
+	  slips++;
+	}
+    }
+  }
+  lbn += slips;
+  if (maptype == MAP_FULL) {
+    for (i=0; i<b->numdefects; i++) {
+      if ((b->defect[i] == (firstblkoncyl + lbn)) && 
+	  (b->remap[i] != b->defect[i])) 
+	{
+	  if(remapsector) *remapsector = 1;
+	  lbn = b->remap[i];
+	  cyl = lbn / blkspercyl;
+	  lbn = lbn % blkspercyl;
+	  goto g1_ltop_sectpercylspare_done;
+	}
+    }
+  }
+   
+  cyl += lbn / lbnspercyl;
+  lbn = lbn % lbnspercyl;
+
+ g1_ltop_sectpercylspare_done:
+  
+  result->cyl = cyl + b->startcyl;
+  result->head = lbn / blkspertrack;
+  result->head = g1_surfno_on_cyl(l,b,result);
+  result->sector = lbn % blkspertrack;
+
+  return DM_OK;
+}
+
+
+/* Assume no remapping/slipping out of a range. */
+
+static dm_ptol_result_t
+g1_ltop_sectperrangespare(struct dm_disk_if *d, 
+			  int lbn, 
+			  dm_layout_maptype maptype,
+			  struct dm_pbn *result,
+			  int *remapsector)
+{
+  int i;
+  int blksperrange;
+  int blkspercyl;
+  int lbnsperrange;
+  int firstblkinrange = 0;
+  int rangeno;
+  int slips = 0;
+
+
+  struct dm_layout_g1 *l = (struct dm_layout_g1 *)d->layout;
+  struct dm_layout_g1_band *b = find_band_lbn(l, lbn);
+
+  lbn -= l->band_blknos[b->num];
+  lbn += b->deadspace;
+
+  blkspercyl = b->blkspertrack * d->dm_surfaces;
+  blksperrange = blkspercyl * l->rangesize;
+  lbnsperrange = blksperrange - b->sparecnt;
+  rangeno = lbn / lbnsperrange;
+
+  lbn = lbn % lbnsperrange;
+
+  if ((maptype == MAP_ADDSLIPS) || (maptype == MAP_FULL)) {
+    firstblkinrange = rangeno * blksperrange;
+    for (i=0; i<b->numslips; i++) {
+      if ((b->slip[i] >= firstblkinrange) && 
+	  ((b->slip[i] - firstblkinrange) <= (lbn+slips))) {
+	slips++;
+      }
+    }
+  }
+  lbn += slips;
+  if (maptype == MAP_FULL) {
+    for (i=0; i<b->numdefects; i++) {
+      if ((b->defect[i] == (firstblkinrange + lbn)) && 
+	  (b->remap[i] != b->defect[i])) {
+	// XXX global/remapsetor
+	if(remapsector) *remapsector = 1;
+	lbn = b->remap[i];
+	lbn = lbn % blksperrange;
+	break;
+      }
+    }
+  }
+
+  
+  result->cyl = b->startcyl + 
+    (rangeno * l->rangesize) + (lbn / blkspercyl);
+
+  result->head = (lbn % blkspercyl) / b->blkspertrack;
+  result->head = g1_surfno_on_cyl(l,b,result);
+  result->sector = lbn % b->blkspertrack;
+
+  return DM_OK;
+}
+
+
+static dm_ptol_result_t
+g1_ltop_sectperzonespare(struct dm_disk_if *d, 
+			 int lbn, 
+			 dm_layout_maptype maptype,
+			 struct dm_pbn *result,
+			 int *remapsector)
+{
+  int i;
+  int blkspercyl;
+  int slips = 0;
+
+  struct dm_layout_g1 *l = (struct dm_layout_g1 *)d->layout;
+  struct dm_layout_g1_band *b = find_band_lbn(l, lbn);
+  lbn -= l->band_blknos[b->num];
+  lbn += b->deadspace;
+
+  if ((maptype == MAP_ADDSLIPS) || (maptype == MAP_FULL)) {
+    for (i=0; i<b->numslips; i++) {
+      if (b->slip[i] <= (lbn+slips)) {
+	slips++;
+      }
+    }
+  }
+  lbn += slips;
+
+  if (maptype == MAP_FULL) {
+    for (i=0; i<b->numdefects; i++) {
+      if ((b->defect[i] == lbn) && 
+	  (b->remap[i] != b->defect[i])) {
+
+	if(remapsector) *remapsector = 1;
+	lbn = b->remap[i];
+	break;
+      }
+    }
+  }
+
+  blkspercyl = b->blkspertrack * d->dm_surfaces;
+
+  result->cyl = b->startcyl + lbn / blkspercyl;
+  result->head = (lbn % blkspercyl) / b->blkspertrack;
+  result->head = g1_surfno_on_cyl(l,b,result);
+  result->sector = lbn % b->blkspertrack;
+
+  return DM_OK;
+}
+
+
+/*
+ * NOTE: The total number of allowable slips and remaps per band is
+ * equal to the number of spare tracks per band.  The following code
+ * will produce incorrect results if this rule is violated.  To fix
+ * this, b needs to be re-calculated after the detection of a
+ * slip or spare.  Also, slips on immediately previous bands need to
+ * be accounted for.  Lastly, the mismatch in sectors per track
+ * between zones must be handled.  
+ * Extremely low priority.  
+ */
+
+static dm_ptol_result_t
+g1_ltop_trackspare(struct dm_disk_if *d, 
+		   int lbn, 
+		   dm_layout_maptype maptype,
+		   struct dm_pbn *result,
+ 		   int *remapsector)
+
+{
+  int i;
+  int blkspertrack;
+  int trackno;
+
+
+  struct dm_layout_g1 *l = (struct dm_layout_g1 *)d->layout;
+  struct dm_layout_g1_band *b = find_band_lbn(l, lbn);
+  lbn -= l->band_blknos[b->num];
+  lbn += b->deadspace;
+
+  blkspertrack = b->blkspertrack;
+  trackno = lbn/blkspertrack;
+  if ((maptype == MAP_ADDSLIPS) || (maptype == MAP_FULL)) {
+    for (i=0; i<b->numslips; i++) {
+      if (b->slip[i] <= trackno) {
+	trackno++;
+      }
+    }
+  }
+  if (maptype == MAP_FULL) {
+    for (i=0; i<b->numdefects; i++) {
+      if (b->defect[i] == trackno) {
+	trackno = b->remap[i];
+	break;
+      }
+    }
+  }
+
+  result->cyl = (trackno/d->dm_surfaces) + b->startcyl;
+  result->head = trackno % d->dm_surfaces;
+  result->head = g1_surfno_on_cyl(l,b,result);
+  result->sector = lbn % blkspertrack;
+
+  return DM_OK;
+}
+
+
+static dm_ptol_result_t
+g1_seek_distance(struct dm_disk_if *d,
+		 int start_lbn,
+		 int end_lbn)
+{
+  struct dm_pbn p1, p2;
+  int rv;
+
+  rv = d->layout->dm_translate_ltop(d, start_lbn, MAP_NONE, &p1, 0);
+  if(rv != DM_OK) {
+    return rv;
+  }
+
+  rv = d->layout->dm_translate_ltop(d, end_lbn, MAP_NONE, &p2, 0);
+  if(rv != DM_OK) {
+    return rv;
+  }
+
+  
+  return abs(p2.cyl - p1.cyl);
+}
+
+
+static dm_angle_t
+g1_get_sector_width(struct dm_disk_if *d,
+		    struct dm_pbn *track,
+		    int num)
+{
+  struct dm_layout_g1 *l = (struct dm_layout_g1 *)d->layout;
+  struct dm_layout_g1_band *b = find_band_pbn(l, track);
+
+  dm_angle_t result;
+
+  if(num > b->blkspertrack) {
+    return 0;
+  }
+
+  result = b->sector_width;
+  result *=  num;
+  return result;
+}
+
+static dm_angle_t
+g1_lbn_offset(struct dm_disk_if *d, int lbn1, int lbn2)
+{
+  struct dm_pbn pbn1, pbn2;
+  dm_angle_t a1, a2;
+
+  //  struct dm_layout_g1 *l = (struct dm_layout_g1 *)d->layout;
+  //  struct dm_layout_g1_band *b1 = find_band_lbn(l, lbn1);
+  //  struct dm_layout_g1_band *b2 = find_band_lbn(l, lbn2);
+  
+  d->layout->dm_translate_ltop(d, lbn1, MAP_FULL, &pbn1, 0);
+  d->layout->dm_translate_ltop(d, lbn2, MAP_FULL, &pbn2, 0);
+
+  a1 = d->layout->dm_pbn_skew(d, &pbn1);
+  a2 = d->layout->dm_pbn_skew(d, &pbn2);
+
+  return a2 - a1;
+}
+
+
+
+static int 
+layout_g1_marshaled_len(struct dm_disk_if *d) {
+  int c;
+  struct dm_layout_g1 *l = (struct dm_layout_g1 *)d->layout;
+  int result = sizeof(struct dm_marshal_hdr) + sizeof(struct dm_layout_g1); 
+
+  // band blknos
+  result += l->bands_len * sizeof(int);
+
+  // add the zones
+  result += l->bands_len * sizeof(struct dm_layout_g1_band);
+  for(c = 0; c < l->bands_len; c++) {
+    struct dm_layout_g1_band *b = &l->bands[c];
+    result += b->numslips * sizeof(int);
+    // defects and remapped locations
+    result += b->numdefects * 2 * sizeof(int);
+  }
+  
+  return result;
+}
+
+static void *
+layout_g1_marshal(struct dm_disk_if *d, char *buff) {
+  int c;
+  struct dm_layout_g1 *l = (struct dm_layout_g1 *)d->layout;
+  char *ptr = buff;
+  struct dm_marshal_hdr *hdr = (struct dm_marshal_hdr *)buff;
+  hdr->type = DM_LAYOUT_G1_TYP;
+  hdr->len = layout_g1_marshaled_len(d);
+  
+  ptr += sizeof(struct dm_marshal_hdr);
+  memcpy(ptr, d->layout, sizeof(struct dm_layout_g1));
+
+  // fix function pointers here
+  marshal_fns((void **)&l->hdr, 
+	       sizeof(l->hdr) / sizeof(void *),
+	       ptr,
+	       DM_LAYOUT_G1_TYP);
+
+  ptr += sizeof(struct dm_layout_g1);
+
+ 
+  // now do the zones
+  for(c = 0; c < l->bands_len; c++) {
+    struct dm_layout_g1_band *b = &l->bands[c];
+    memcpy(ptr, b, sizeof(struct dm_layout_g1_band));
+    ptr += sizeof(struct dm_layout_g1_band);
+
+    // slips
+    memcpy(ptr, b->slip, b->numslips * sizeof(int));
+    ptr += b->numslips * sizeof(int);
+
+    // defect locations
+    memcpy(ptr, b->defect, b->numdefects * sizeof(int));
+    ptr += b->numdefects * sizeof(int);
+
+    // defect remaps
+    memcpy(ptr, b->remap, b->numdefects * sizeof(int));
+    ptr += b->numdefects * sizeof(int);
+  }
+
+  // do the band blknos array
+  memcpy(ptr, l->band_blknos, l->bands_len * sizeof(int));
+  ptr += l->bands_len * sizeof(int);
+
+  return ptr;
+}
+
+char *
+layout_g1_unmarshal(struct dm_marshal_hdr *hdr, 
+		     void **result,
+		     void *parent)
+{
+  int c;
+  struct dm_layout_g1 *l = malloc(sizeof(struct dm_layout_g1));
+  char *ptr = (char *)hdr;
+  
+  ddbg_assert(hdr->type == DM_LAYOUT_G1_TYP);
+  
+  ptr += sizeof(struct dm_marshal_hdr);
+
+  memcpy(l, ptr, sizeof(struct dm_layout_g1));
+  unmarshal_fns((void **)&l->hdr,
+		 sizeof(l->hdr) / sizeof(void*),
+		 ptr,
+		 DM_LAYOUT_G1_TYP);
+
+  ptr += sizeof(struct dm_layout_g1);
+  
+  l->bands = malloc(l->bands_len * sizeof(struct dm_layout_g1_band));
+
+  // now do the zones
+  for(c = 0; c < l->bands_len; c++) {
+    struct dm_layout_g1_band *b = &l->bands[c];
+    memcpy(b, ptr, sizeof(struct dm_layout_g1_band));
+    ptr += sizeof(struct dm_layout_g1_band);
+
+    // slips
+    if(b->numslips != 0) {
+      b->slip = malloc(b->numslips * sizeof(int));
+      memcpy(b->slip, ptr, b->numslips * sizeof(int));
+      ptr += b->numslips * sizeof(int);
+    }
+
+    // defect locations
+    if(b->numdefects != 0) {
+      b->defect = malloc(b->numdefects * sizeof(int));
+      memcpy(b->defect, ptr, b->numdefects * sizeof(int));
+      ptr += b->numdefects * sizeof(int);
+
+      // defect remaps
+      b->remap = malloc(b->numdefects * sizeof(int));
+      memcpy(b->remap, ptr, b->numdefects * sizeof(int));
+      ptr += b->numdefects * sizeof(int);
+    }
+  }
+
+  // do the band blknos array
+  l->band_blknos = malloc(l->bands_len * sizeof(int));
+  memcpy(l->band_blknos, ptr, l->bands_len * sizeof(int));
+  ptr += l->bands_len * sizeof(int);
+
+
+  l->disk = parent;
+
+  *result = l;
+  return ptr;
+}
+
+
+// returns the number of zones for the layout
+static int 
+g1_get_numzones(struct dm_disk_if *d) 
+{
+  struct dm_layout_g1 *l = (struct dm_layout_g1 *)d->layout;
+  return l->bands_len;
+}
+
+// Fetch the info about the nth zone and store it in the result
+// parameter z.  Returns 0 on success, -1 on error (bad n)
+// n should be within 0 and (dm_get_numzones() - 1)
+static int 
+g1_get_zone(struct dm_disk_if *d, 
+	    int n, 
+	    struct dm_layout_zone *result)
+{
+  struct dm_layout_g1 *l = (struct dm_layout_g1 *)d->layout;
+  struct dm_layout_g1_band *z = calloc(sizeof(struct dm_layout_g1_band), 1);
+
+  // check args  
+  if(z == 0) { return -1; }
+  if(n < 0 || n >= l->bands_len) { return -1; }
+
+  z = &l->bands[n];
+
+  result->spt = z->blkspertrack;
+  result->lbn_low = l->band_blknos[n];
+  result->lbn_high = l->band_blknos[n] + z->blksinband - 1;
+
+  result->cyl_low = z->startcyl;
+  result->cyl_high = z->endcyl;
+
+  return 0;
+}
+
+
+// any function that appears in the interface must be listed here
+void *layout_g1_fns[] = {
+  g1_ltop_nosparing,
+  g1_ltop_sectpertrackspare,  
+  g1_ltop_sectpercylspare,
+  g1_ltop_sectperrangespare,
+  g1_ltop_sectperzonespare,
+  g1_ltop_trackspare,
+
+  g1_ltop_0t,
+
+  g1_ptol_nosparing,
+  g1_ptol_sectpertrackspare,
+  g1_ptol_sectpercylspare,
+  g1_ptol_sectperrangespare,
+  g1_ptol_sectperzonespare,
+  g1_ptol_trackspare,
+
+  g1_ptol_0t,
+
+  g1_st_lbn,
+  g1_st_pbn,
+
+  g1_track_boundaries_nosparing,
+  g1_track_boundaries_sectpertrackspare,
+  g1_track_boundaries_sectpercylspare,
+  g1_track_boundaries_sectperrangespare,
+  g1_track_boundaries_sectperzonespare,
+  g1_track_boundaries_trackspare,
+
+  g1_seek_distance,
+  g1_map_pbn_skew,
+  g1_get_track_0l,
+  g1_convert_ptoa,
+  g1_convert_atop,
+  g1_get_sector_width,
+  layout_g1_marshaled_len,
+  layout_g1_marshal,
+  g1_lbn_offset,
+  g1_get_numzones,
+  g1_get_zone
+};
+
+struct dm_marshal_module dm_layout_g1_marshal_mod =
+{ 
+  layout_g1_unmarshal, 
+  layout_g1_fns, 
+  sizeof(layout_g1_fns) / sizeof(void *) 
+};
+
+
+// instances of interface struct for the various sparing schemes
+
+struct dm_layout_if g1_layout_nosparing = {
+  g1_ltop_nosparing,
+  g1_ltop_0t,
+  g1_ptol_nosparing,
+  g1_ptol_0t,
+  g1_st_lbn,
+  g1_st_pbn,
+  g1_track_boundaries_nosparing,
+  g1_seek_distance,
+  g1_map_pbn_skew,
+  g1_get_track_0l,
+  g1_convert_ptoa, // ptoa
+  g1_convert_atop, // atop
+  g1_get_sector_width,
+  g1_lbn_offset,
+  layout_g1_marshaled_len,
+  layout_g1_marshal,
+  g1_get_numzones,
+  g1_get_zone
+};
+
+struct dm_layout_if g1_layout_tracksparing = {
+  g1_ltop_trackspare,
+  g1_ltop_0t,
+  g1_ptol_trackspare,
+  g1_ptol_0t,
+  g1_st_lbn,
+  g1_st_pbn,
+  g1_track_boundaries_trackspare,
+  g1_seek_distance,
+  g1_map_pbn_skew,
+  g1_get_track_0l,
+  g1_convert_ptoa, // ptoa
+  g1_convert_atop, // atop
+  g1_get_sector_width,
+  g1_lbn_offset,
+  layout_g1_marshaled_len,
+  layout_g1_marshal,
+  g1_get_numzones,
+  g1_get_zone
+};
+
+struct dm_layout_if g1_layout_sectpertrackspare = {
+  g1_ltop_sectpertrackspare,
+  g1_ltop_0t,
+  g1_ptol_sectpertrackspare,
+  g1_ptol_0t,
+  g1_st_lbn,
+  g1_st_pbn,
+  g1_track_boundaries_sectpertrackspare,
+  g1_seek_distance,
+  g1_map_pbn_skew,
+  g1_get_track_0l,
+  g1_convert_ptoa, // ptoa
+  g1_convert_atop, // atop
+  g1_get_sector_width,
+  g1_lbn_offset,
+  layout_g1_marshaled_len,
+  layout_g1_marshal,
+  g1_get_numzones,
+  g1_get_zone
+};
+
+struct dm_layout_if g1_layout_sectpercylspare = {
+  g1_ltop_sectpercylspare,
+  g1_ltop_0t,
+  g1_ptol_sectpercylspare,
+  g1_ptol_0t,
+  g1_st_lbn,
+  g1_st_pbn,
+  g1_track_boundaries_sectpercylspare,
+  g1_seek_distance,
+  g1_map_pbn_skew,
+  g1_get_track_0l,
+  g1_convert_ptoa, // ptoa
+  g1_convert_atop, // atop
+  g1_get_sector_width,
+  g1_lbn_offset,
+  layout_g1_marshaled_len,
+  layout_g1_marshal,
+  g1_get_numzones,
+  g1_get_zone
+};
+
+struct dm_layout_if g1_layout_sectperrangespare = {
+  g1_ltop_sectperrangespare,
+  g1_ltop_0t,
+  g1_ptol_sectperrangespare,
+  g1_ptol_0t,
+  g1_st_lbn,
+  g1_st_pbn,
+  g1_track_boundaries_sectperrangespare,
+  g1_seek_distance,
+  g1_map_pbn_skew,
+  g1_get_track_0l,
+  g1_convert_ptoa,  // ptoa
+  g1_convert_atop,  // atop
+  g1_get_sector_width,
+  g1_lbn_offset,
+  layout_g1_marshaled_len,
+  layout_g1_marshal,
+  g1_get_numzones,
+  g1_get_zone
+};
+
+struct dm_layout_if g1_layout_sectperzonespare = {
+  g1_ltop_sectperzonespare,
+  g1_ltop_0t,
+  g1_ptol_sectperzonespare,
+  g1_ptol_0t,
+  g1_st_lbn,
+  g1_st_pbn,
+  g1_track_boundaries_sectperzonespare,
+  g1_seek_distance,
+  g1_map_pbn_skew,
+  g1_get_track_0l,
+  g1_convert_ptoa, // ptoa
+  g1_convert_atop,  // atop
+  g1_get_sector_width,
+  g1_lbn_offset,
+  layout_g1_marshaled_len,
+  layout_g1_marshal,
+  g1_get_numzones,
+  g1_get_zone
+};
+
+
+
+
+#if 0
+
+// the old old old disksim loader code used this
+static void bandcopy(struct dm_layout_g1_band **destbands, 
+		     struct dm_layout_g1_band *srcbands, 
+		     int numbands)
+{
+   int i;
+   *destbands = malloc(numbands * sizeof(struct dm_layout_g1_band));
+   memcpy(*destbands,srcbands,sizeof(struct dm_layout_g1_band));
+
+   for (i=0; i<numbands; i++) {
+      (*destbands)[i].slip = malloc (srcbands[i].numslips * sizeof(int));
+      (*destbands)[i].defect = malloc (srcbands[i].numdefects * sizeof(int));
+      (*destbands)[i].remap = malloc (srcbands[i].numdefects * sizeof(int));
+
+      memcpy((*destbands)[i].slip, 
+	     srcbands[i].slip, 
+	     srcbands[i].numslips * sizeof(int));
+      memcpy((*destbands)[i].defect, 
+	     srcbands[i].defect, 
+	     srcbands[i].numdefects * sizeof(int));
+      memcpy((*destbands)[i].remap, 
+	     srcbands[i].remap, 
+	     srcbands[i].numdefects * sizeof(int));
+   }
+}
+
+#endif 
+
+
diff -uNr disksim-4.0/diskmodel/layout_g2.c disksim-4.0-x64/diskmodel/layout_g2.c
--- disksim-4.0/diskmodel/layout_g2.c	2007-01-09 12:58:48.000000000 +0800
+++ disksim-4.0-x64/diskmodel/layout_g2.c	2016-03-23 19:34:32.074652000 +0800
@@ -248,7 +248,7 @@
 
   // return st for the nearest (lower) zone if this cyl is unmapped
   while(!(z = find_zone_pbn(d, &p2)) && p2.cyl >= 0) { p2.cyl--; }
-  ddbg_assert(z);
+  ddbg_assert(z != NULL);
 
   return z->st;
 }
@@ -283,6 +283,7 @@
       *l2 = d->layout->dm_translate_ptol(d, &p2, remapsector);
     } while((*l2 == DM_NX) && p2.sector);
   }
+  return DM_OK;
 }
 
 static dm_angle_t
diff -uNr disksim-4.0/diskmodel/layout_g2.c~ disksim-4.0-x64/diskmodel/layout_g2.c~
--- disksim-4.0/diskmodel/layout_g2.c~	1970-01-01 08:00:00.000000000 +0800
+++ disksim-4.0-x64/diskmodel/layout_g2.c~	2016-03-23 19:33:53.874650000 +0800
@@ -0,0 +1,493 @@
+/* diskmodel (version 1.1)
+ * Authors: John Bucy, Greg Ganger
+ * Contributors: John Griffin, Jiri Schindler, Steve Schlosser
+ *
+ * Copyright (c) of Carnegie Mellon University, 2003-2005
+ *
+ * This software is being provided by the copyright holders under the
+ * following license. By obtaining, using and/or copying this
+ * software, you agree that you have read, understood, and will comply
+ * with the following terms and conditions:
+ *
+ * Permission to reproduce, use, and prepare derivative works of this
+ * software is granted provided the copyright and "No Warranty"
+ * statements are included with all reproductions and derivative works
+ * and associated documentation. This software may also be
+ * redistributed without charge provided that the copyright and "No
+ * Warranty" statements are included in all redistributions.
+ *
+ * NO WARRANTY. THIS SOFTWARE IS FURNISHED ON AN "AS IS" BASIS.
+ * CARNEGIE MELLON UNIVERSITY MAKES NO WARRANTIES OF ANY KIND, EITHER
+ * EXPRESSED OR IMPLIED AS TO THE MATTER INCLUDING, BUT NOT LIMITED
+ * TO: WARRANTY OF FITNESS FOR PURPOSE OR MERCHANTABILITY, EXCLUSIVITY
+ * OF RESULTS OR RESULTS OBTAINED FROM USE OF THIS SOFTWARE. CARNEGIE
+ * MELLON UNIVERSITY DOES NOT MAKE ANY WARRANTY OF ANY KIND WITH
+ * RESPECT TO FREEDOM FROM PATENT, TRADEMARK, OR COPYRIGHT
+ * INFRINGEMENT.  COPYRIGHT HOLDERS WILL BEAR NO LIABILITY FOR ANY USE
+ * OF THIS SOFTWARE OR DOCUMENTATION.  
+ */
+
+#include "layout_g2.h"
+
+#include <stdlib.h>
+
+
+#define min(x,y) (x) < (y) ? (x) : (y)
+
+
+static struct dm_layout_g2_zone *
+find_zone_lbn(struct dm_disk_if *d,
+	      int lbn)
+{
+  int c;
+  struct dm_layout_g2 *l = (struct dm_layout_g2 *)d->layout;
+  for(c = 0; c < l->zones_len; c++) {
+    if((l->zones[c].lbnlow <= lbn) 
+       && (lbn <= l->zones[c].lbnhigh)) 
+      {
+	return &l->zones[c];
+      }
+  }
+  ddbg_assert(0);
+
+  return 0;
+}
+
+
+static struct dm_layout_g2_zone *
+find_zone_pbn(struct dm_disk_if *d,
+	      struct dm_pbn *p)
+{
+  int c;
+  struct dm_layout_g2 *l = (struct dm_layout_g2 *)d->layout;
+  for(c = 0; c < l->zones_len; c++) {
+    if((l->zones[c].cyllow <= p->cyl) 
+       && (p->cyl <= l->zones[c].cylhigh)) 
+      {
+	return &l->zones[c];
+      }
+  }
+  ddbg_assert(0);
+
+  return 0;
+}
+
+
+// return 1 if they overlap, ..
+static int
+g2_nodecmp(const void *p1, const void *p2) 
+{
+  struct dm_layout_g2_node *n1 = (struct dm_layout_g2_node *)p1;
+  struct dm_layout_g2_node *n2 = (struct dm_layout_g2_node *)p2;
+
+  if(n1->lbn >= (n2->lbn + n2->len)) {
+    return 1;
+  }
+  else if(n2->lbn >= (n1->lbn + n1->len)) {
+    return -1;
+  }
+  else return 0;
+}
+
+
+static dm_ptol_result_t
+ltop(struct dm_disk_if *d, 
+     int lbn, 
+     dm_layout_maptype mt,
+     struct dm_pbn *result,
+     int *remapsector)
+{
+  struct dm_layout_g2_node keynode, *rn;
+  struct dm_layout_g2_zone *z = find_zone_lbn(d,lbn);
+  struct dm_layout_g2 *l = (struct dm_layout_g2 *)d->layout;
+
+  memset(&keynode, 0, sizeof(keynode));
+  keynode.lbn = lbn;
+  keynode.len = 1;
+
+  rn = bsearch(&keynode, 
+	       l->ltop_map, 
+	       l->ltop_map_len, 
+	       sizeof(struct dm_layout_g2_node),
+	       g2_nodecmp);
+
+  if(!rn) {
+    return DM_NX;
+  }
+  else {
+    *result = rn->loc;
+    result->sector += (lbn - rn->lbn);
+    return DM_OK;
+  }
+}
+
+
+static dm_ptol_result_t
+ltop_0t(struct dm_disk_if *d, 
+	int lbn, 
+	dm_layout_maptype mt,
+	struct dm_pbn *result,
+	int *remapsector)
+{
+  ddbg_assert(0);
+  return 0;
+}
+
+  
+static dm_ptol_result_t
+ptol(struct dm_disk_if *d, 
+     struct dm_pbn *p,
+     int *remapsector)
+{
+  int i;
+  struct dm_layout_g2_node *curr;
+
+  struct dm_layout_g2_surf *track;
+  struct dm_layout_g2 *l = (struct dm_layout_g2 *)d->layout;
+
+  ddbg_assert(p->cyl < d->dm_cyls);
+  ddbg_assert(p->head < d->dm_surfaces);
+
+  curr = &l->ptol_map[p->cyl].surfaces[p->head].extents[0];
+  for(i = 0; 
+      i < l->ptol_map[p->cyl].surfaces[p->head].extents_len; 
+      i++, curr++) 
+  {
+    if((curr->loc.cyl == p->cyl)
+       && (curr->loc.head == p->head)
+       && (p->sector >= curr->loc.sector)
+       && (p->sector < (curr->loc.sector + curr->len)))
+      
+    {
+      return curr->lbn + (p->sector - curr->loc.sector);
+    }
+  } 
+
+  return DM_NX;
+}
+
+static dm_ptol_result_t
+ptol_0t(struct dm_disk_if *d, 
+	struct dm_pbn *p,
+	int *remapsector)
+{
+  ddbg_assert(0);
+  return 0;
+}
+
+
+
+
+static int 
+trkcmp(const void *ptr1, const void *ptr2)
+{
+  const struct dm_pbn *p1 = ptr1;
+  const struct dm_pbn *p2 = ptr2;
+
+  if(p1->cyl < p2->cyl) return -1;
+  else if(p2->cyl < p1->cyl) return 1;
+
+  if(p1->head < p2->head) return -1;
+  else if(p2->head < p1->head) return 1;
+
+  return 0;
+}
+
+
+static dm_ptol_result_t
+g2_defect_count(struct dm_disk_if *d,
+		struct dm_pbn *track,
+		int *result)
+{
+  struct dm_layout_g2 *l = (struct dm_layout_g2 *)d->layout;
+  struct dm_pbn *p, *p1, *p2;
+
+  if(!l->defects_len) {
+    *result = 0;
+    goto out;
+  }
+
+  p = bsearch(track,
+	      l->defects, 
+	      l->defects_len, 
+	      sizeof(struct dm_pbn), 
+	      trkcmp);
+
+  if(!p) {
+    *result = 0;
+  }
+  else {
+    p1 = p2 = p;
+    
+    while(!trkcmp(p1, p)) p1--;  
+    while(!trkcmp(p2, p)) p2++;  
+    
+    *result = p2 - p1 - 1;
+  }
+
+ out:
+
+  return DM_OK;
+}
+
+
+static int
+st_lbn(struct dm_disk_if *d,
+       int lbn)
+{
+  struct dm_layout_g2_zone *z = find_zone_lbn(d, lbn);
+  return z->st;
+}
+
+static int
+st_pbn(struct dm_disk_if *d,
+       struct dm_pbn *p)
+{
+  struct dm_pbn p2 = *p;
+  struct dm_layout_g2_zone *z;
+
+  // return st for the nearest (lower) zone if this cyl is unmapped
+  while(!(z = find_zone_pbn(d, &p2)) && p2.cyl >= 0) { p2.cyl--; }
+  ddbg_assert(z != NULL);
+
+  return z->st;
+}
+
+
+static void
+track_boundaries(struct dm_disk_if *d,
+		 struct dm_pbn *p,
+		 int *l1,
+		 int *l2,
+		 int *remapsector)
+{
+  struct dm_pbn p1, p2;
+  struct dm_layout_g2_zone *z = find_zone_pbn(d, p);
+
+  p1 = *p;
+  p2 = *p;
+
+  p1.sector = 0;
+  p2.sector = z->st;
+  
+  if(l1) {
+    do { 
+      *l1 = d->layout->dm_translate_ptol(d, &p1, remapsector);
+      p1.sector++;
+    } while((*l1 == DM_NX) && (p1.sector < z->st));
+  }
+
+  if(l2) {
+    do {
+      p2.sector--;
+      *l2 = d->layout->dm_translate_ptol(d, &p2, remapsector);
+    } while((*l2 == DM_NX) && p2.sector);
+  }
+}
+
+static dm_angle_t
+sector_width(struct dm_disk_if *d,
+	     struct dm_pbn *track,
+	     int num)
+{
+  struct dm_layout_g2_zone *z = find_zone_pbn(d, track);
+  return z->sector_width * num;
+}
+
+
+
+static dm_angle_t
+pbn_skew_new(struct dm_disk_if *d,
+	 struct dm_pbn *p)
+{
+  int i;
+  int lasthead, lastcyl;
+
+  struct dm_layout_g2 *l = (struct dm_layout_g2 *)d->layout;
+  struct dm_layout_g2_zone *z = find_zone_pbn(d, p);
+  int fltop_ext = l->ptol_map[p->cyl].first_ltop_extent;
+
+  dm_angle_t result = l->ptol_map[p->cyl].skew;
+
+
+  lastcyl = l->ltop_map[fltop_ext].loc.cyl;
+  lasthead = l->ltop_map[fltop_ext].loc.head;
+
+  for(i = fltop_ext; i < l->ltop_map_len; i++) {
+    if(l->ltop_map[i].loc.cyl != lastcyl) { 
+      result += z->csskew;
+      lastcyl = l->ltop_map[i].loc.cyl;
+    }
+    if(l->ltop_map[i].loc.head != lasthead) {
+      result += z->hsskew;
+      lasthead = l->ltop_map[i].loc.head;
+    }
+
+    if((l->ltop_map[i].loc.cyl == p->cyl)
+       && (l->ltop_map[i].loc.head == p->head)) goto done;
+  }
+  ddbg_assert(0);
+
+ done:
+
+  result += p->sector * z->sector_width;
+
+  return result;
+}
+
+
+static dm_angle_t
+pbn_skew(struct dm_disk_if *d,
+	 struct dm_pbn *p)
+{
+  int i;
+  int lastcyl, lasthead;
+  dm_angle_t result = 0;
+  struct dm_layout_g2 *l = (struct dm_layout_g2 *)d->layout;
+  struct dm_layout_g2_zone *z = find_zone_pbn(d, p);
+
+  // count headswitch/cylswitch
+  // find start of zone in ltop map
+  // slooooow
+  // precompute -- table of first index per zone
+  for(i = 0; i < l->ltop_map_len; i++) {
+    if(l->ltop_map[i].loc.cyl == z->cyllow) break;
+  }
+
+  if((l->ltop_map[i].loc.cyl == p->cyl)
+     && (l->ltop_map[i].loc.head == p->head)) goto done;
+
+  lastcyl = l->ltop_map[i].loc.cyl;
+  lasthead = l->ltop_map[i].loc.head;
+  
+  // walk forward until we get to p
+  // precompute: skew per cylinder
+  for( ; i < l->ltop_map_len; i++) {
+    if(l->ltop_map[i].loc.cyl != lastcyl) result += z->csskew;
+    if(l->ltop_map[i].loc.head != lasthead) result += z->hsskew;
+    if((l->ltop_map[i].loc.cyl == p->cyl)
+       && (l->ltop_map[i].loc.head == p->head)) goto done;
+  }
+  ddbg_assert(0);
+ done:
+  result += p->sector * z->sector_width;
+
+  return result;
+}
+
+static void
+ptoa(struct dm_disk_if *d,
+     struct dm_pbn *p,
+     dm_angle_t *start,
+     dm_angle_t *width)
+{
+  struct dm_layout_g2_zone *z = find_zone_pbn(d, p);
+
+  if(start)
+    *start = z->sector_width * p->sector;
+
+  if(width)
+    *start = z->sector_width;
+}
+
+
+static dm_ptol_result_t
+atop(struct dm_disk_if *d,
+     struct dm_mech_state *a,
+     struct dm_pbn *result)
+{
+  struct dm_pbn pbn;
+  struct dm_layout_g2_zone *z;
+  result->head = a->head;
+  result->cyl = a->cyl;
+
+  pbn.head = a->head;
+  pbn.cyl = a->cyl;
+
+  z = find_zone_pbn(d, &pbn);
+
+  result->sector = (a->theta / z->sector_width) % z->st;
+
+  return DM_OK;
+}
+
+
+static dm_ptol_result_t
+g2_seek_distance(struct dm_disk_if *d,
+		 int start_lbn,
+		 int end_lbn)
+{
+  struct dm_pbn p1, p2;
+  int rv;
+
+  rv = d->layout->dm_translate_ltop(d, start_lbn, MAP_NONE, &p1, 0);
+  if(rv != DM_OK) {
+    return rv;
+  }
+
+  rv = d->layout->dm_translate_ltop(d, end_lbn, MAP_NONE, &p2, 0);
+  if(rv != DM_OK) {
+    return rv;
+  }
+
+  
+  return abs(p2.cyl - p1.cyl);
+}
+
+
+  // returns the number of zones for the layout
+static int 
+g2_get_numzones(struct dm_disk_if *d)
+{
+  struct dm_layout_g2 *l = (struct dm_layout_g2 *)d->layout;
+  return l->zones_len;
+}
+
+// Fetch the info about the nth zone and store it in the result
+// parameter z.  Returns 0 on success, -1 on error (bad n)
+// n should be within 0 and (dm_get_numzones() - 1)
+static int 
+g2_get_zone(struct dm_disk_if *d, int n, struct dm_layout_zone *result)
+{
+  struct dm_layout_g2 *l = (struct dm_layout_g2 *)d->layout;
+  struct dm_layout_g2_zone *z;
+
+  if(result == 0) { return -1; }
+  if(n < 0 || n >= l->zones_len) { return -1; }
+  
+  z = &l->zones[n];
+
+  result->spt = z->st;
+
+  result->lbn_low = z->lbnlow;
+  result->lbn_high = z->lbnhigh;
+
+  result->cyl_low = z->cyllow;
+  result->cyl_high = z->cylhigh;
+
+  
+  return 0;
+}
+
+
+struct dm_layout_if layout_g2 = {
+  ltop,
+  ltop_0t,
+  ptol,
+  ptol_0t,
+  st_lbn,
+  st_pbn,
+  track_boundaries,
+  g2_seek_distance, //  seekdist,
+  pbn_skew_new,
+  0, // get_zerol
+  ptoa, // ptoa
+  atop, // atop
+  sector_width,
+  0, // lbn offset
+  0, // marshall -- probably not implemented for g2
+  0, // unmarshall
+  g2_get_numzones,
+  g2_get_zone,
+  g2_defect_count
+};
diff -uNr disksim-4.0/diskmodel/Makefile disksim-4.0-x64/diskmodel/Makefile
--- disksim-4.0/diskmodel/Makefile	2008-05-12 06:09:28.000000000 +0800
+++ disksim-4.0-x64/diskmodel/Makefile	2016-03-23 19:58:22.274721000 +0800
@@ -80,13 +80,13 @@
 libdiskmodel.a:	$(DM_OBJ) $(DM_USERSPACE_OBJ) 
 	$(MAKE) -C modules
 	@echo "Linking libdiskmodel.a $(DM_USERSPACE_OBJ)"
-	ar cru $@ $(DM_OBJ) $(DM_USERSPACE_OBJ)
+	ar crus $@ $(DM_OBJ) $(DM_USERSPACE_OBJ)
 	mkdir -p lib
 	$(CP) libdiskmodel.a lib
 
 # for kernel
 #libdiskmodel.a: modules $(DM_OBJ)
-#	ar cru $@ $(DM_OBJ)
+#	ar crus $@ $(DM_OBJ)
 
 clean:
 	rm -f *.o
diff -uNr disksim-4.0/diskmodel/Makefile~ disksim-4.0-x64/diskmodel/Makefile~
--- disksim-4.0/diskmodel/Makefile~	1970-01-01 08:00:00.000000000 +0800
+++ disksim-4.0-x64/diskmodel/Makefile~	2008-05-12 06:09:28.000000000 +0800
@@ -0,0 +1,103 @@
+# diskmodel (version 1.0)
+# Authors: John Bucy, Greg Ganger
+# Contributors: John Griffin, Jiri Schindler, Steve Schlosser
+#
+# Copyright (c) of Carnegie Mellon University, 2001-2008.
+#
+# This software is being provided by the copyright holders under the
+# following license. By obtaining, using and/or copying this
+# software, you agree that you have read, understood, and will comply
+# with the following terms and conditions:
+#
+# Permission to reproduce, use, and prepare derivative works of this
+# software is granted provided the copyright and "No Warranty"
+# statements are included with all reproductions and derivative works
+# and associated documentation. This software may also be
+# redistributed without charge provided that the copyright and "No
+# Warranty" statements are included in all redistributions.
+#
+# NO WARRANTY. THIS SOFTWARE IS FURNISHED ON AN "AS IS" BASIS.
+# CARNEGIE MELLON UNIVERSITY MAKES NO WARRANTIES OF ANY KIND, EITHER
+# EXPRESSED OR IMPLIED AS TO THE MATTER INCLUDING, BUT NOT LIMITED
+# TO: WARRANTY OF FITNESS FOR PURPOSE OR MERCHANTABILITY, EXCLUSIVITY
+# OF RESULTS OR RESULTS OBTAINED FROM USE OF THIS SOFTWARE. CARNEGIE
+# MELLON UNIVERSITY DOES NOT MAKE ANY WARRANTY OF ANY KIND WITH
+# RESPECT TO FREEDOM FROM PATENT, TRADEMARK, OR COPYRIGHT
+# INFRINGEMENT.  COPYRIGHT HOLDERS WILL BEAR NO LIABILITY FOR ANY USE
+# OF THIS SOFTWARE OR DOCUMENTATION.  
+
+CC=gcc 
+CXX=g++
+
+# must provide LIBPARAM_ and LIBDDBG_ vars
+include .paths
+
+# -D_DISKMODEL_FREEBSD for the freebsd kernel (malloc foo)
+# -D_BSD_SOURCE for bsd-ish userspace to get uint32 and friends from the
+# right place
+CFLAGS = -g -I. $(LIBPARAM_CFLAGS) $(LIBDDBG_CFLAGS) -D_DM_SOURCE -Wall -Wshadow -Wno-unused -MD  # -O6  -fomit-frame-pointer -fexpensive-optimizations -fschedule-insns2 -march=pentium4
+
+CXXFLAGS = -g -I. $(LIBPARAM_CFLAGS) $(LIBDDBG_CFLAGS) -D_DM_SOURCE -Wall -Wno-unused  -MD
+
+CC-DEP = $(CC)
+CP = cp -p
+all: modules libdiskmodel.a
+	$(MAKE) -C tests
+
+merge_skews: merge_skews.o libdiskmodel.a
+	$(CC) -o $@ $^ $(LIBPARAM_LDFLAGS) $(LIBDDBG_LDFLAGS)
+
+.PHONY: modules
+modules: modules/*.o ;
+
+modules/modules.h modules/*.o:
+	$(MAKE) -C modules
+	mkdir -p include/diskmodel/modules
+	$(CP) dm.h dm_types.h dm_config.h marshal.h include/diskmodel
+	$(CP) modules/*.h include/diskmodel/modules
+
+# modules/modules.h modules/*.h modules/*.c: modules
+
+-include *.d
+
+DM_SRC = mech_g1_seektime.c mech_g1.c \
+	 layout_g1.c sqrt.c marshal.c layout_g2.c \
+	 layout_g4.c
+
+# source for libparam loaders; separate for things like kernel
+# which don't have libparam 
+DM_USERSPACE_SRC = mech_g1_load.c layout_g1_load.c dm_load.c \
+  convert.c layout_g2_load.c layout_g4_load.c
+
+DM_OBJ = $(DM_SRC:.c=.o) 
+
+DM_LOADER_OBJ = modules/*.o
+
+DM_USERSPACE_OBJ =  $(DM_LOADER_OBJ) $(DM_USERSPACE_SRC:.c=.o)
+
+
+# for userspace
+libdiskmodel.a:	$(DM_OBJ) $(DM_USERSPACE_OBJ) 
+	$(MAKE) -C modules
+	@echo "Linking libdiskmodel.a $(DM_USERSPACE_OBJ)"
+	ar cru $@ $(DM_OBJ) $(DM_USERSPACE_OBJ)
+	mkdir -p lib
+	$(CP) libdiskmodel.a lib
+
+# for kernel
+#libdiskmodel.a: modules $(DM_OBJ)
+#	ar cru $@ $(DM_OBJ)
+
+clean:
+	rm -f *.o
+	$(MAKE) -C modules clean
+	$(MAKE) -C layout_g4_tools clean
+	$(MAKE) -C tests clean
+
+distclean: clean
+	rm -f *.d *~
+	rm -f libdiskmodel.a dm_testsuite
+	rm -rf lib include 
+	$(MAKE) -C modules distclean
+	$(MAKE) -C layout_g4_tools distclean
+	$(MAKE) -C tests distclean
diff -uNr disksim-4.0/libddbg/Makefile disksim-4.0-x64/libddbg/Makefile
--- disksim-4.0/libddbg/Makefile	2008-05-12 06:09:29.000000000 +0800
+++ disksim-4.0-x64/libddbg/Makefile	2016-03-23 19:59:57.182725000 +0800
@@ -50,7 +50,7 @@
 	rm -f *~
 
 libddbg.a: $(LT_OBJ)
-	ar cru $@ $^
+	ar crus $@ $^
 
 
 #test: test.c libddbg.a libddbg.h
diff -uNr disksim-4.0/libddbg/Makefile~ disksim-4.0-x64/libddbg/Makefile~
--- disksim-4.0/libddbg/Makefile~	1970-01-01 08:00:00.000000000 +0800
+++ disksim-4.0-x64/libddbg/Makefile~	2008-05-12 06:09:29.000000000 +0800
@@ -0,0 +1,58 @@
+
+# libddbg (version 1.0)
+# Authors: John Bucy, Greg Ganger
+# Contributors: John Griffin, Jiri Schindler, Steve Schlosser
+#
+# Copyright (c) of Carnegie Mellon University, 2001-2008.
+#
+# This software is being provided by the copyright holders under the
+# following license. By obtaining, using and/or copying this
+# software, you agree that you have read, understood, and will comply
+# with the following terms and conditions:
+#
+# Permission to reproduce, use, and prepare derivative works of this
+# software is granted provided the copyright and "No Warranty"
+# statements are included with all reproductions and derivative works
+# and associated documentation. This software may also be
+# redistributed without charge provided that the copyright and "No
+# Warranty" statements are included in all redistributions.
+#
+# NO WARRANTY. THIS SOFTWARE IS FURNISHED ON AN "AS IS" BASIS.
+# CARNEGIE MELLON UNIVERSITY MAKES NO WARRANTIES OF ANY KIND, EITHER
+# EXPRESSED OR IMPLIED AS TO THE MATTER INCLUDING, BUT NOT LIMITED
+# TO: WARRANTY OF FITNESS FOR PURPOSE OR MERCHANTABILITY, EXCLUSIVITY
+# OF RESULTS OR RESULTS OBTAINED FROM USE OF THIS SOFTWARE. CARNEGIE
+# MELLON UNIVERSITY DOES NOT MAKE ANY WARRANTY OF ANY KIND WITH
+# RESPECT TO FREEDOM FROM PATENT, TRADEMARK, OR COPYRIGHT
+# INFRINGEMENT.  COPYRIGHT HOLDERS WILL BEAR NO LIABILITY FOR ANY USE
+# OF THIS SOFTWARE OR DOCUMENTATION.  
+
+
+
+
+# needs bitvector.h
+# -D_LIBDDBG_FREEBSD for freebsd kernel
+CFLAGS = -g -I../libparam
+
+all: libddbg.a
+	mkdir -p include/libddbg lib
+	cp -p libddbg.h include/libddbg
+	cp -p libddbg.a lib 
+
+LT_SRC = ddbg_assert.c ddbg_trace.c
+LT_OBJ = $(LT_SRC:.c=.o) 
+
+clean: 
+	rm -f $(LT_OBJ) libddbg.a
+	rm -rf include lib
+
+distclean: clean
+	rm -f *~
+
+libddbg.a: $(LT_OBJ)
+	ar cru $@ $^
+
+
+#test: test.c libddbg.a libddbg.h
+#	$(CC) -g -o $@ test.c -L. -lddbg
+
diff -uNr disksim-4.0/libparam/Makefile disksim-4.0-x64/libparam/Makefile
--- disksim-4.0/libparam/Makefile	2008-05-12 06:09:29.000000000 +0800
+++ disksim-4.0-x64/libparam/Makefile	2016-03-23 20:00:22.410726000 +0800
@@ -53,7 +53,7 @@
 LIBPARAM_OBJ = $(LIBPARAM_SRC:.c=.o)
 
 libparam.a: $(LIBPARAM_OBJ)
-	ar cru $@ $^ 
+	ar crus $@ $^ 
 
 
 dump_tlts: dump_tlts.o libparam.a
diff -uNr disksim-4.0/libparam/Makefile~ disksim-4.0-x64/libparam/Makefile~
--- disksim-4.0/libparam/Makefile~	1970-01-01 08:00:00.000000000 +0800
+++ disksim-4.0-x64/libparam/Makefile~	2008-05-12 06:09:29.000000000 +0800
@@ -0,0 +1,68 @@
+
+# libparam (version 1.0)
+# Authors: John Bucy, Greg Ganger
+# Contributors: John Griffin, Jiri Schindler, Steve Schlosser
+#
+# Copyright (c) of Carnegie Mellon University, 2001-2008.
+#
+# This software is being provided by the copyright holders under the
+# following license. By obtaining, using and/or copying this
+# software, you agree that you have read, understood, and will comply
+# with the following terms and conditions:
+#
+# Permission to reproduce, use, and prepare derivative works of this
+# software is granted provided the copyright and "No Warranty"
+# statements are included with all reproductions and derivative works
+# and associated documentation. This software may also be
+# redistributed without charge provided that the copyright and "No
+# Warranty" statements are included in all redistributions.
+#
+# NO WARRANTY. THIS SOFTWARE IS FURNISHED ON AN "AS IS" BASIS.
+# CARNEGIE MELLON UNIVERSITY MAKES NO WARRANTIES OF ANY KIND, EITHER
+# EXPRESSED OR IMPLIED AS TO THE MATTER INCLUDING, BUT NOT LIMITED
+# TO: WARRANTY OF FITNESS FOR PURPOSE OR MERCHANTABILITY, EXCLUSIVITY
+# OF RESULTS OR RESULTS OBTAINED FROM USE OF THIS SOFTWARE. CARNEGIE
+# MELLON UNIVERSITY DOES NOT MAKE ANY WARRANTY OF ANY KIND WITH
+# RESPECT TO FREEDOM FROM PATENT, TRADEMARK, OR COPYRIGHT
+# INFRINGEMENT.  COPYRIGHT HOLDERS WILL BEAR NO LIABILITY FOR ANY USE
+# OF THIS SOFTWARE OR DOCUMENTATION.  
+
+
+
+include .paths
+all: libparam.a
+	mkdir -p lib include/libparam
+	cp -p libparam.a lib
+	cp -p bitvector.h libparam.h include/libparam
+
+FLEX=flex
+BISON=bison
+YACC=$(BISON)
+
+CFLAGS=-g -I$(LIBDDBG_INCL) -Wall
+
+# input file parser
+lex.libparam.c:	libparam.lex libparam.tab.h libparam.h
+	$(FLEX) -Plibparam $<
+
+libparam.c libparam.tab.c libparam.tab.h: libparam.y libparam.h
+	$(BISON) -plibparam --defines $<
+
+LIBPARAM_SRC =  util.c libparam.tab.c  lex.libparam.c 
+
+LIBPARAM_OBJ = $(LIBPARAM_SRC:.c=.o)
+
+libparam.a: $(LIBPARAM_OBJ)
+	ar cru $@ $^ 
+
+
+dump_tlts: dump_tlts.o libparam.a
+	$(CC) -o $@ $^ -L. -lparam $(LIBDDBG_LDFLAGS)
+
+
+clean: 
+	rm -f lex.libparam.c libparam.tab.c libparam.tab.h libparam.a *.o dump_tlts
+	rm -rf lib include
+
+distclean: clean
+
diff -uNr disksim-4.0/libparam/myutil.c disksim-4.0-x64/libparam/myutil.c
--- disksim-4.0/libparam/myutil.c	2008-05-12 06:09:29.000000000 +0800
+++ disksim-4.0-x64/libparam/myutil.c	2016-03-23 19:35:02.874654000 +0800
@@ -150,7 +150,7 @@
 {
   struct lp_param *result = calloc(1, sizeof(struct lp_param));
   result->source_file = source;
-  result->name = name;
+  result->name = strdup(name);
   result->v = v;
   
 
diff -uNr disksim-4.0/libparam/myutil.c~ disksim-4.0-x64/libparam/myutil.c~
--- disksim-4.0/libparam/myutil.c~	1970-01-01 08:00:00.000000000 +0800
+++ disksim-4.0-x64/libparam/myutil.c~	2008-05-12 06:09:29.000000000 +0800
@@ -0,0 +1,1396 @@
+
+/* libparam (version 1.0)
+ * Authors: John Bucy, Greg Ganger
+ * Contributors: John Griffin, Jiri Schindler, Steve Schlosser
+ *
+ * Copyright (c) of Carnegie Mellon University, 2001-2008.
+ *
+ * This software is being provided by the copyright holders under the
+ * following license. By obtaining, using and/or copying this
+ * software, you agree that you have read, understood, and will comply
+ * with the following terms and conditions:
+ *
+ * Permission to reproduce, use, and prepare derivative works of this
+ * software is granted provided the copyright and "No Warranty"
+ * statements are included with all reproductions and derivative works
+ * and associated documentation. This software may also be
+ * redistributed without charge provided that the copyright and "No
+ * Warranty" statements are included in all redistributions.
+ *
+ * NO WARRANTY. THIS SOFTWARE IS FURNISHED ON AN "AS IS" BASIS.
+ * CARNEGIE MELLON UNIVERSITY MAKES NO WARRANTIES OF ANY KIND, EITHER
+ * EXPRESSED OR IMPLIED AS TO THE MATTER INCLUDING, BUT NOT LIMITED
+ * TO: WARRANTY OF FITNESS FOR PURPOSE OR MERCHANTABILITY, EXCLUSIVITY
+ * OF RESULTS OR RESULTS OBTAINED FROM USE OF THIS SOFTWARE. CARNEGIE
+ * MELLON UNIVERSITY DOES NOT MAKE ANY WARRANTY OF ANY KIND WITH
+ * RESPECT TO FREEDOM FROM PATENT, TRADEMARK, OR COPYRIGHT
+ * INFRINGEMENT.  COPYRIGHT HOLDERS WILL BEAR NO LIABILITY FOR ANY USE
+ * OF THIS SOFTWARE OR DOCUMENTATION.  
+ */
+
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <ctype.h>
+#include <stdlib.h>
+#include <string.h>
+#include <libddbg/libddbg.h>
+
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <unistd.h>
+
+#include <unistd.h>
+#include <fcntl.h>
+
+#include <libgen.h>
+
+#include "libparam.h"
+#include "bitvector.h"
+
+static lp_topoloader_t topoloader = 0;
+
+void lp_register_topoloader(lp_topoloader_t l) 
+{
+  topoloader = l;
+}
+
+
+
+
+char *lp_builtin_names[] = {
+  0,
+  "Block",
+  "String",
+  "Int",
+  "Double",
+  "List", 
+  "Topospec"
+};
+
+// FILE *libparamin = 0;
+struct lp_subtype **lp_typetbl;
+int lp_typetbl_len;
+
+struct lp_tlt **lp_tlts;
+int lp_tlts_len;
+
+//extern char lp_filename[];
+//extern char lp_cwd[];
+
+char **lp_searchpath = 0;
+int lp_searchpath_len = 0;
+
+
+extern int lp_lineno;
+
+static void destroy_block(struct lp_block *b);
+static void destroy_value(struct lp_value *v);
+static void destroy_param(struct lp_param *p);
+static void destroy_list(struct lp_list *l);
+static void destroy_topospec(struct lp_topospec *t);
+
+int dumb_split(char *s, char **t, int *i);
+int dumb_split2(char *s, char **s1, char **s2);
+
+
+static int lp_max_mod = 0;
+static int lp_mod_size = 0;
+struct lp_mod **lp_modules = 0;
+
+static char **overrides = 0;
+static int overrides_len = 0;
+
+#define outputfile stdout
+
+
+struct lp_value *lp_new_intv(int i) 
+{
+  struct lp_value *v = calloc(1, sizeof(struct lp_value));
+  v->v.i = i;
+  v->t = I;
+  return v;
+}
+
+struct lp_value *lp_new_doublev(double d) 
+{
+  struct lp_value *v = calloc(1, sizeof(struct lp_value));
+  v->v.d = d;
+  v->t = D;
+  return v;
+}
+
+struct lp_value *lp_new_stringv(char *s) 
+{
+  struct lp_value *v = calloc(1, sizeof(struct lp_value));
+  v->v.s = s;
+  v->t = S;
+  return v;
+}
+
+struct lp_value *lp_new_listv(struct lp_list *l)
+{
+  struct lp_value *v = calloc(1, sizeof(struct lp_value));
+  v->v.l = l;
+  v->t = LIST;
+  return v;
+}
+
+struct lp_value *lp_new_blockv(struct lp_block *b)
+{
+  struct lp_value *v = calloc(1, sizeof(struct lp_value));
+  v->v.b = b;
+  v->t = b->type;
+  return v;
+}
+
+
+struct lp_param *
+lp_new_param(char *name, char *source, struct lp_value *v)
+{
+  struct lp_param *result = calloc(1, sizeof(struct lp_param));
+  result->source_file = source;
+  result->name = name;
+  result->v = v;
+  
+
+  return result;
+}
+
+struct lp_list *
+lp_new_list(void) 
+{
+  struct lp_list *l = calloc(1, sizeof(struct lp_list));
+  l->values = calloc(8, sizeof(struct lp_value *));
+  l->values_len = 8;
+  l->values_pop = 0;
+  l->linelen = 1;
+  return l;
+}
+
+struct lp_block *
+lp_new_block(void)
+{
+  struct lp_block *b = calloc(1, sizeof(struct lp_block));
+  b->params = calloc(8, sizeof(struct lp_param *));
+  b->params_len = 8;
+  return b;
+}
+
+struct lp_list *
+lp_new_intlist(int *intarr, int len)
+{
+  int i;
+  struct lp_list *l = lp_new_list();
+
+  for(i = 0; i < len; i++) {
+    lp_list_add(l, lp_new_intv(intarr[i]));
+  }
+  return l;
+}
+
+
+
+int lp_register_module(struct lp_mod *m) {
+  int c;
+  for(c = 0; c < lp_max_mod; c++) {
+    if(!strcmp(m->name, lp_modules[c]->name)) {
+      return -1;
+    }
+  }
+  if(c >= lp_mod_size) {
+    lp_mod_size *= 2; lp_mod_size++;
+    lp_modules = realloc(lp_modules, lp_mod_size * sizeof(int *));
+  }
+  if(c > 0) 
+    lp_modules[c] = m;
+  else 
+    lp_modules[0] = m;
+
+  lp_max_mod++;
+
+  return c;
+}
+
+
+
+
+static void die(char *msg) {
+  fprintf(stderr, "*** error: FATAL: %s\n", msg);
+  exit(1);
+}
+
+static void destroy_param(struct lp_param *p)
+{
+  free(p->name);
+  destroy_value(p->v);
+  free(p);
+}
+
+
+static void destroy_list(struct lp_list *l) {
+  int c;
+  for(c = 0; c < l->values_len; c++)
+    if(l->values[c])
+      destroy_value(l->values[c]);
+
+  free(l->values);
+  free(l);
+}
+
+
+static void destroy_value(struct lp_value *v) {
+  int d;
+  switch(v->t) {
+  case S:
+    free(v->v.s); 
+    break;
+    
+  case LIST:
+    destroy_list(v->v.l);
+    break;
+    
+  case I: 
+  case D: break;
+
+  case TOPOSPEC:
+    for(d = 0; d < v->v.t.len; d++)
+      destroy_topospec(&v->v.t.l[d]);
+
+    free(v->v.t.l);
+    break;
+      
+  default:
+    destroy_block(v->v.b);
+  }
+
+  free(v);
+}
+
+
+static void destroy_block(struct lp_block *b) {
+  int c;
+  for(c = 0; c < b->params_len; c++) {
+    if(b->params[c]) {
+      destroy_param(b->params[c]);
+    } 
+  }
+
+  free(b->name);
+  free(b->params);
+  free(b);
+}
+
+static void destroy_topospec(struct lp_topospec *t)
+{
+  free(t->type);
+  free(t->name);
+  destroy_list(t->l);
+}
+
+
+static struct lp_block *copy_block(struct lp_block *);
+static struct lp_list *copy_list(struct lp_list *);
+static struct lp_value *copy_value(struct lp_value *);
+static struct lp_param *copy_param(struct lp_param *);
+
+static struct lp_block *copy_block(struct lp_block *b)
+{
+  int c;
+  struct lp_block *result = calloc(1, sizeof(*result));
+  memcpy(result, b, sizeof(struct lp_block));
+  result->params = calloc(b->params_len, sizeof(result->params[0]));
+
+  if(b->name) {
+    result->name = strdup(b->name);
+  }
+
+  for(c = 0; c < b->params_len; c++) {
+    if(b->params[c]) {
+      result->params[c] = copy_param(b->params[c]);
+    }
+  }
+
+  return result;
+}
+
+
+static struct lp_list *copy_list(struct lp_list *l) {
+  int c;
+  struct lp_list *result = calloc(1, sizeof(*result));
+  memcpy(result, l, sizeof(struct lp_list));
+  result->values = calloc(l->values_len, sizeof(result->values[0]));
+  memcpy(result->values, l->values, l->values_len * sizeof(int *));
+  for(c = 0; c < l->values_len; c++) {
+    if(l->values[c]) {
+      result->values[c] = copy_value(l->values[c]);
+    }
+  }
+  return result;
+}
+
+
+static struct lp_value *copy_value(struct lp_value *v) {
+  struct lp_value *result = calloc(1, sizeof(struct lp_value));
+  memcpy(result, v, sizeof(struct lp_value));
+  switch(v->t) {
+  case S:
+    result->v.s = strdup(v->v.s);
+    break;
+
+  case LIST:
+    result->v.l = copy_list(v->v.l);
+    break;
+
+  case BLOCK:
+    result->v.b = copy_block(v->v.b);
+    break;
+
+  default:
+    break;
+  }
+  
+  return result;
+}
+
+static struct lp_param *copy_param(struct lp_param *p) {
+  struct lp_param *result = calloc(1, sizeof(struct lp_param));
+  result->name = strdup(p->name);
+  result->v = copy_value(p->v);
+  return result;
+}
+
+
+static int indent_level = 0;
+
+static void indent(FILE *f) {
+  char *space = calloc(1, 3*indent_level+1);
+  memset(space, (int)' ', 3*indent_level);
+  space[3*indent_level] = 0;
+  fprintf(f, "%s", space);
+  free(space);
+}
+
+void unparse_source(char *source, FILE *outfile) {
+  fprintf(outfile, "source %s", source);
+}
+
+void unparse_type(int t, FILE *outfile) {
+  if(t < 0) {
+    fprintf(outfile, "%s", lp_builtin_names[abs(t)]);
+  }
+  else {
+    if(t > lp_max_mod) {
+      fprintf(outfile, "<UNKNOWN TYPE>");
+    }
+    else {
+      fprintf(outfile, "%s", lp_modules[t]->name);
+    }
+  }
+}
+
+void unparse_param(struct lp_param *p, FILE *outfile) {
+  fprintf(outfile, "%s = ", p->name);
+  if(p->source_file && p->v->source_file) {
+    if(strcmp(p->source_file, p->v->source_file)) {
+      unparse_source(p->v->source_file, outfile);
+      return;
+    }
+  }
+
+  unparse_value(p->v, outfile);
+}
+
+void unparse_value(struct lp_value *v, FILE *outfile) {
+  int c;
+  switch(v->t) {
+  case I:
+    fprintf(outfile, "%d", v->v.i);
+    break;
+  case D:
+    if(v->v.d == 0.0) {
+      fprintf(outfile, "0.0");
+    }
+    else {
+      fprintf(outfile, "%f", v->v.d);
+    }
+    break;
+  case S:
+    fprintf(outfile, "%s", v->v.s);
+    break;
+  case LIST:
+    unparse_list(v->v.l, outfile);
+    break;
+  case TOPOSPEC:
+    for(c = 0; c < v->v.t.len; c++)
+      unparse_topospec(&v->v.t.l[c], outfile);
+    break;
+  default:
+  case BLOCK:
+    unparse_block(v->v.b, outfile);
+    break;
+  }
+}
+
+void unparse_list(struct lp_list *l, FILE *outfile) {
+  int printed = 0;
+  int c;
+
+/*    indent(outfile); */
+
+  fprintf(outfile, "[ ");
+  indent_level++;
+  for(c = 0; c < l->values_len; c++) { 
+    if(!l->values[c]) 
+      continue;
+
+    if(c) {
+      fprintf(outfile, ", ");
+      if(!(c % l->linelen)) {
+	fprintf(outfile, "\n");
+	indent(outfile);
+      }
+    }
+    else {
+      fprintf(outfile, "\n");
+      indent(outfile);
+    }
+
+    printed++;
+    unparse_value(l->values[c], outfile);
+  }
+  indent_level--;
+
+  if((c > 0) && printed) {
+    fprintf(outfile, "\n");
+    indent(outfile);
+  }
+  fprintf(outfile, "]");
+}
+
+
+void unparse_block(struct lp_block *b, FILE *outfile) {
+  int c;
+/*    indent(outfile); */
+  if(b->name) {
+    /* a block definition */
+    fprintf(outfile, "%s %s {\n", lp_modules[b->type]->name, b->name);
+  }
+  else {
+    /* a block value */
+    fprintf(outfile, "%s {\n", lp_modules[b->type]->name);
+
+  }
+
+  indent_level++;
+  for(c = 0; c < b->params_len; c++) {
+    if(!b->params[c]) continue;
+
+    if(c) fprintf(outfile, ",\n");
+
+    unparse_param(b->params[c], outfile);
+  }
+  indent_level--;
+  fprintf(outfile, "\n");
+  indent(outfile);
+  fprintf(outfile, "}");
+  if(b->name) {
+    fprintf(outfile, " # end of %s spec", b->name);
+    fprintf(outfile, "\n\n");
+  }
+}
+
+void unparse_topospec(struct lp_topospec *t, FILE *outfile) {
+  fprintf(outfile, "%s %s ", t->type, t->name);
+  unparse_list(t->l, outfile);
+  // unparse_list() prints a trailing newline...
+  //  fprintf(outputfile, "\n"); 
+}
+
+// somewhat of a hack
+void unparse_tl_topospec(struct lp_topospec *t, FILE *outfile) 
+{
+  fprintf(outfile, "topospec ");
+  unparse_topospec(t, outfile);
+  fprintf(outfile, "\n\n");
+}
+
+void unparse_inst(struct lp_inst *i, FILE *outfile) {
+  fprintf(outfile, "instantiate ");
+  unparse_list(i->l, outfile);
+  fprintf(outfile, " as %s\n\n", i->name);
+}
+
+void unparse_tlt(struct lp_tlt *tlt, FILE *outfile, char *infile) {
+
+  if(tlt->source_file && infile) {
+    if(strcmp(tlt->source_file, infile)) {
+      unparse_source(tlt->source_file, outfile);
+      return;
+    }
+  }
+  
+  switch(tlt->what) {
+  case TLT_BLOCK: unparse_block(tlt->it.block, outfile); break;
+  case TLT_TOPO:  unparse_tl_topospec(tlt->it.topo, outfile); break;
+  case TLT_INST:  unparse_inst(tlt->it.inst, outfile); break;
+  default:        ddbg_assert(0); break;
+  };
+  
+}
+
+void lp_unparse_tlts(struct lp_tlt **tlts, 
+		     int tlts_len, 
+		     FILE *outfile, 
+		     char *infile) 
+{
+  int c;
+  for(c = 0; c < tlts_len; c++) {
+    if(tlts[c] != 0) {
+      unparse_tlt(tlts[c], outfile, infile);
+    }
+  }
+}
+
+
+
+/* instantiate all the elements of <l> as <name> */
+int lp_inst_list(struct lp_inst *i)
+{
+  int c;
+  
+  /*      unparse_block(spec, outputfile); */
+
+  for(c = 0; c < i->l->values_len; c++) {
+    if(!i->l->values[c]) continue;
+    
+    ddbg_assert3(i->l->values[c]->t == S, 
+	       ("bad type for component %s", i->l->values[c]->v.s));
+    
+    lp_instantiate(i->l->values[c]->v.s, i->name);
+  }
+  
+  return 0;
+}
+
+/* instantiate <targ> as <name> */
+int *lp_instantiate(char *targ, char *name) {
+  char *nametmp;
+  struct lp_block *spec;
+  int *obj;
+    
+/*    unparse_block(b, outputfile); */
+
+  spec = lp_lookup_spec(name);
+  ddbg_assert3(spec != 0, ("no such type %s.\n", name));
+
+  // this is a bit of a hack; we swap the name of the component
+  // being instantiated with the name of the module that's being
+  // instantiated so that the loader function sees the target
+  // name
+  nametmp = spec->name;
+  spec->name = targ;
+  
+  //  fprintf(stderr, "*** Instantiating %s as %s\n", targ, name);
+
+  obj = lp_override_inst(spec, 
+			 targ,
+			 lp_modules[spec->type]->fn,
+			 overrides, 
+			 overrides_len);
+
+  // swap the name back
+  spec->name = nametmp;
+
+
+  if(!obj) {
+    return 0;
+  }
+  
+  if(lp_modules[spec->type]->callback) {
+    lp_modules[spec->type]->callback(lp_modules[spec->type]->ctx, obj);
+  }
+
+  return obj;
+}
+
+/* 0 on success, nonzero on error */
+int check_types(struct lp_block *b) {
+  int c = 0;
+
+  /* we'll do all of the type checking here so that 
+   * the per-mod loaders only have to sanitize values */
+
+  for(c = 0; c < b->params_len; c++) {
+    if(b->params[c]) {
+      if(lp_param_name(b->type, b->params[c]->name) == -1) {
+
+	fprintf(stderr, "*** warning: parameter %s not valid in context %s\n",
+		b->params[c]->name, lp_modules[b->type]->name);
+	
+      }
+
+      else if(lp_modules[b->type]->modvars[lp_param_name(b->type, b->params[c]->name)].type
+	 != PTYPE(b->params[c])) {
+
+	/* implicitly convert ints to doubles */
+	if((lp_modules[b->type]->modvars[lp_param_name(b->type, b->params[c]->name)].type
+	    == D)
+	   && (PTYPE(b->params[c]) == I)) {
+	  b->params[c]->v->t = D;
+	  DVAL(b->params[c]) = (double) IVAL(b->params[c]);
+	}
+	  
+	else { 
+	  fprintf(stderr, "*** error: type error: %s::\"%s\" cannot take type ",
+		  lp_modules[b->type]->name,
+		  b->params[c]->name);
+	  
+/*  	  unparse_type(PTYPE(b->params[c]), stderr); */
+	  fprintf(stderr, "\n");
+
+	  die("check_types() failed");
+	}
+      }
+      
+
+
+      if(PTYPE(b->params[c]) >= BLOCK) {
+	check_types(BVAL(b->params[c]));
+      }
+      else if(PTYPE(b->params[c]) == LIST) {
+	int d;
+	struct lp_list *l = LVAL(b->params[c]);
+	for(d = 0; d < l->values_len; d++) {
+	  if(l->values[d]) {
+	    if(l->values[d]->t >= BLOCK) {
+	      check_types(l->values[d]->v.b);
+	    }
+	  }
+	}
+      }
+
+    }
+  }
+  return 0;
+}
+
+void load_block(struct lp_block *b) {
+  int n;
+
+  lp_lookup_type(b->name, &n);
+  lp_typetbl[n]->spec = b;
+}
+
+
+
+
+void load_topo(struct lp_topospec *t, int len) 
+{
+/*    unparse_topospec(t, outputfile); */
+  topoloader(t, len);
+}
+
+
+
+
+
+void printvars(void) {
+  int c, d;
+  for(c = 0; c < lp_max_mod; c++) {
+    for(d = 0; d < lp_modules[c]->modvars_len; d++) {
+      printf("%s::%s\n", lp_modules[c]->name, 
+	     lp_modules[c]->modvars[d].name);
+    }
+  }
+}
+
+
+
+void dummy (struct lp_block *b) { 
+  fprintf(stderr, "*** error: %s cannot be declared at top-level.\n",
+	  b->name);
+  exit(1);
+}
+
+
+struct lp_list *lp_list_add(struct lp_list *l, 
+			    struct lp_value *v)
+{
+  int c, newlen;
+  for(c = 0; c < l->values_len; c++) {
+    if(!l->values[c]) goto done;
+  }
+  newlen = 2 * c * sizeof(struct lp_value *);
+  l->values = realloc(l->values, newlen);
+  bzero(l->values + c, newlen / 2);
+  l->values_len *= 2;
+
+ done:
+  l->values_pop++;
+  l->values[c] = v;
+  
+  return l;
+}
+
+
+
+
+
+/* maps a modtype and parameter name to a nonnegative numeric
+ * representation.  -1 returned on error */
+
+int lp_param_name(int m, char *n)
+{
+  int c = 0;
+  if(!RANGE(m,0,lp_max_mod)) return -1;
+  if(!n) return -1;
+
+  while((c < lp_modules[m]->modvars_len)
+	&& strcmp(lp_modules[m]->modvars[c].name, n)) c++;
+
+  if(c >= lp_modules[m]->modvars_len) {
+    return -1;
+  }
+  else {
+    return c;
+  }
+}
+
+
+int lp_mod_name(char *n) {
+  int c = 0;
+  if(!n) return -1;
+
+  while((c < lp_max_mod) && strcmp(lp_modules[c]->name, n)) c++;
+
+  if(c >= lp_max_mod) {
+    return -1;
+  }
+  else {
+    return c;
+  }
+}
+
+/* get the base type of name */
+char *lp_lookup_base_type(char *name, int *n) {
+  int c;
+  for(c = 0; c < lp_typetbl_len; c++) {
+    if(lp_typetbl[c]) {
+      if(!strcmp(name, lp_typetbl[c]->sub)) {
+	if(lp_typetbl[c]->super) {
+	  return lp_lookup_base_type(lp_typetbl[c]->super, n);
+	}
+	else {
+	  break;
+	}
+      }
+    }
+  }
+
+  if(n) *n = c;
+  return name;
+}
+
+char *lp_lookup_type(char *name, int *n) {
+  int c;
+  for(c = 0; c < lp_typetbl_len; c++) {
+    if(lp_typetbl[c]) {
+      if(!strcmp(name, lp_typetbl[c]->sub)) {
+	if(n) *n = c;
+	return lp_typetbl[c]->super;
+      }
+    }
+  }
+  return 0;
+}
+
+
+
+/* find the specification for name or return 0 if it doesn't exist.
+ * New "wildcard" behavior: if name is null, return the first
+ * spec in the typetbl with non-zero parent -- i.e. only 
+ * match a user-provided spec, not a builtin type!
+ */
+struct lp_block *lp_lookup_spec(char *name) {
+  int c;
+
+  for(c = 0; c < lp_typetbl_len; c++) 
+    if(lp_typetbl[c]) {
+      if(!name) {
+	if(lp_typetbl[c]->super) {
+	  return lp_typetbl[c]->spec;
+	}
+      }
+      else if(!strcmp(name, lp_typetbl[c]->sub)) {
+	return lp_typetbl[c]->spec;
+      }
+    }
+
+  return 0;
+}
+
+
+struct lp_tlt *lp_new_tl_topo(struct lp_topospec *t, char *source_file)
+{
+  struct lp_tlt *result = calloc(1, sizeof(*result));
+  result->source_file = source_file;
+  result->what = TLT_TOPO;
+  result->it.topo = t;
+  lp_add_tlt(result);
+  return result;
+}
+
+struct lp_tlt *lp_new_tl_inst(struct lp_inst *i, char *source_file)
+{
+  struct lp_tlt *result = calloc(1, sizeof(*result));
+  result->source_file = source_file;
+  result->what = TLT_INST;
+  result->it.inst = i;
+  lp_add_tlt(result);
+  return result;
+}
+
+struct lp_tlt *lp_new_tl_block(struct lp_block *b, char *source_file)
+{
+  struct lp_tlt *result = calloc(1, sizeof(*result));
+  result->source_file = source_file;
+  result->what = TLT_BLOCK;
+  result->it.block = b;
+  lp_add_tlt(result);
+  return result;
+}
+
+
+void lp_add_tlt(struct lp_tlt *tlt) {
+  int c;
+  int found = 0;
+
+  for(c = 0; c < lp_tlts_len; c++) {
+    if(!lp_tlts[c]) {
+      found = c; break;
+    }
+  }
+
+  if(!found) {
+    int newlen = lp_tlts_len ? 2 * lp_tlts_len : 2;
+    int zerocnt = lp_tlts_len ? lp_tlts_len : 2;
+    
+    int newsize = newlen * sizeof(struct lp_tlts *);
+    zerocnt *= sizeof(struct lp_tlts *);
+
+    lp_tlts = realloc(lp_tlts, newsize);
+    memset(lp_tlts + lp_tlts_len, 0, zerocnt);
+    found = lp_tlts_len;
+    lp_tlts_len = newlen;
+  }
+
+  lp_tlts[c] = tlt;
+}
+
+
+int lp_add_type(char *newt, char *parent) {
+  int c;
+  int newlen;
+  struct lp_subtype *st = calloc(1, sizeof(*st));
+  st->super = strdup(parent); st->sub = strdup(newt);
+
+  if(!lp_lookup_type(newt,0)) {
+    for(c = 0; c < lp_typetbl_len; c++) 
+      if(!lp_typetbl[c]) {
+	goto done;
+      }
+
+
+    newlen = lp_typetbl_len ? 2 * lp_typetbl_len : 2;
+
+    lp_typetbl = realloc(lp_typetbl, newlen * sizeof(int *));
+
+    bzero(lp_typetbl + c, c * sizeof(int *));
+    lp_typetbl_len = newlen;
+  }
+  else return -1;
+  
+  done:
+  lp_typetbl[c] = st;
+  return 0;
+}
+
+
+int lp_add_param(struct lp_param ***b, int *plen,
+		 struct lp_param *p)
+{
+  int c;
+
+  /* look for dupe params */
+  for(c = 0; c < *plen; c++) {
+    if(!(*b)[c]) continue;
+    if(!strcmp((*b)[c]->name, p->name)) {
+      fprintf(stderr, "*** error: redefined %s\n", p->name);
+      return -1;
+    }
+  }
+
+
+  for(c = 0; c < *plen; c++) {
+    if(!(*b)[c]) {
+      (*b)[c] = p;
+      break;
+    }
+  }
+  if(c == *plen) {
+    /* didn't find a free slot -- double the array */
+    int newlen = 2 * (*plen) + 1;
+    (*b) = realloc((*b), newlen * sizeof(int *));
+    bzero((int *)(*b) + *plen, ((*plen) + 1) * sizeof(int*));
+    (*b)[(*plen)] = p;
+    *plen = newlen;
+  }
+
+  return 0;
+}
+
+/* copy all of the params in parent not defined in child into
+ * child */
+int lp_setup_subtype(struct lp_block *parent,
+		     struct lp_block *child)
+{
+  int c, d;
+
+  for(c = 0; c < parent->params_len; c++) {
+    int found = 0;
+    for(d = 0; d < child->params_len; d++) {
+      if(!strcmp(child->params[d]->name, parent->params[c]->name)) {
+	found = 1;
+      }
+    }
+    if(!found) {
+      lp_add_param(&child->params, &child->params_len, parent->params[c]);
+    }
+  }
+
+  return 0;
+}
+
+
+
+
+void lp_init_typetbl(void) {
+  int c;
+  lp_typetbl = calloc(lp_max_mod, sizeof(struct subtype *));
+
+
+  for(c = 0; c < lp_max_mod; c++) {
+
+    lp_typetbl[c] = malloc(sizeof(struct lp_subtype));
+    bzero(lp_typetbl[c], sizeof(struct lp_subtype));
+    lp_typetbl[c]->sub = strdup(lp_modules[c]->name);
+  }
+
+  lp_typetbl_len = lp_max_mod;
+}
+
+void lp_release_typetbl(void) {
+  int c;
+
+  for(c = 0; c < lp_typetbl_len; c++) {
+    if(!lp_typetbl[c]) continue;
+
+    if(lp_typetbl[c]->spec)
+      destroy_block(lp_typetbl[c]->spec);
+
+    if(lp_typetbl[c]->sub)
+      free(lp_typetbl[c]->sub);
+
+    if(lp_typetbl[c]->super) 
+      free(lp_typetbl[c]->super); 
+
+    free(lp_typetbl[c]);
+  }
+
+  free(lp_typetbl);
+}
+
+
+
+/* splits s into a trailing number (i) and the leading part */
+int dumb_split(char *s, char **t, int *i) {
+  int c = strlen(s) - 1;
+  
+  while(c && isdigit(s[c])) c--;
+  if(!c) return -1;
+  c++;
+  (*i) = atoi(&s[c]);
+  *t = strdup(s);
+  (*t)[c] = 0;
+  return 0;
+}
+
+/* separate 'foo:bar' into 'foo' and 'bar' */
+int dumb_split2(char *s, char **s1, char **s2) {
+  int c = 0;
+  (*s1) = strdup(s);
+  while(s[c] && (s[c] != ':')) c++;
+  (*s1)[c] = 0;
+  if(s[c]) (*s2) = strdup(s + c + 1);
+  else return -1;
+
+  return 0;
+}
+
+
+
+
+
+static int param_override(struct lp_block *b, 
+			  char *pname,
+			  char *pval) 
+{
+  int c;
+  
+  for(c = 0; c < b->params_len; c++) {
+    if(!b->params[c]) continue;
+    if(!strcmp(b->params[c]->name, pname)) {
+      switch(b->params[c]->v->t) {
+      case I:
+	b->params[c]->v->v.i = atoi(pval);
+	break;
+      case D:
+	b->params[c]->v->v.d = atof(pval);
+	break;
+      case S:
+	free(b->params[c]->v->v.s);
+	b->params[c]->v->v.s = strdup(pval);
+	return 0;
+	break;
+
+      default:
+	ddbg_assert(0);
+      }
+
+      return -1;
+    } 
+  }
+
+  
+  return -1;
+}
+
+			  
+
+int range_match(char *range, char *name) {
+  char *base1, *base2, *base3;
+  char r1[128], r2[128];
+  int i1, i2, i3;
+
+  if(!strcmp(range, name)) { return 1; }
+
+  if(!strcmp(range, "*")) return 1;
+
+  if(sscanf(range, "%s .. %s", r1, r2) != 2) { 
+    char *prefix; int junk;
+
+    dumb_split(name, &prefix, &junk);
+
+    /* i.e. driver* matches driver2 and driver and driver2344 but not
+     * driverqux 
+     */
+    if((strlen(range) == ( strlen(prefix) + 1)) &&
+       !strncmp(range,prefix,strlen(prefix)) &&
+       (range[strlen(prefix)] == '*')) return 1;
+
+    return 0; 
+  }
+
+  
+  dumb_split(r1, &base1, &i1);
+  dumb_split(r2, &base2, &i2);
+  if(strcmp(base1, base2) || (i1 < 0) || (i2 < i1)) {
+    fprintf(stderr, "*** error: bad range \"%s .. %s\"\n", r1, r2);
+    return 0;
+  }
+
+  dumb_split(name, &base3, &i3);
+  if(!strcmp(base3, base2) && (i3 >= i1) && (i3 <= i2)) {
+    return 1;
+  }
+  else {
+    return 0;
+  }
+}
+
+
+/* instantiate a component with overrides 
+ * tname type to instantiate,
+ * cname name of instantiated component
+ * loader is the module loader function for tname
+ */
+int *lp_override_inst(struct lp_block *spec, 
+		  char *cname, 
+		  lp_modloader_t loader,
+		  char **overrides,
+		  int overrides_len)
+{
+  int c, d;
+  struct lp_block *spec_copy;
+  char *p1, *p2; 
+  int *result;
+  
+  spec_copy = copy_block(spec);
+
+  for(c = 0; c < overrides_len; c += 3) {
+    if(range_match(overrides[c], cname)) {
+      
+      /* overrides[c+2] could be an int, a real, a string or a list or
+       * a block.  need parser to deal with lists and blocks
+       * reasonably so we aren't going to deal with them here */
+     
+      if(!dumb_split2(overrides[c+1], &p1, &p2)) {
+	/* descend hierarchy */
+	for(d = 0; d < spec_copy->params_len; d++) {
+	  if(!spec_copy->params[d]) continue;
+	  if(!strcmp(p1, spec_copy->params[d]->name)) {
+	    if(spec_copy->params[d]->v->t != BLOCK) {
+	      fprintf(stderr, "*** error: tried to recurse through non-block parameter.\n");
+	      return 0;
+	    }
+	    else {
+	      param_override(spec_copy->params[d]->v->v.b, p2, 
+			     overrides[c+2]);
+	    }
+	  }
+	}
+
+      }
+      else {
+	param_override(spec_copy, 
+		       overrides[c+1], 
+		       overrides[c+2]);
+	
+      }
+    }
+  }
+
+
+
+  if(!check_types(spec_copy)) {
+    result = loader(spec_copy, 0);
+  }
+
+  // XXX don't leak (segfaults)
+  //  destroy_block(spec_copy);
+  return result; 
+}
+
+extern void libparamparse(void);
+extern void libparamlex(void);
+
+int lp_loadfile(FILE *in, 
+		struct lp_tlt ***tlts, 
+		int *tlts_len, 
+		char *infile,
+		char **cli_overrides,
+		int cli_overrides_len) {
+
+  char *lp_sp;
+  char *dirc;
+  char *dir;
+  
+  int stdout_save;
+  int devnull;
+  top_file = 0;
+  lp_lineno = 1;
+
+  dirc = strdup(infile);
+  dir = dirname(dirc);
+
+  lp_filename = infile;
+  lp_cwd = dir;
+  libparamin = in;
+
+  overrides = cli_overrides;
+  overrides_len = cli_overrides_len;
+
+  // do the searchpath
+  lp_sp = getenv("LP_PATH");
+  if(lp_sp) {
+    char *p = lp_sp;
+    char *colon;
+    
+    lp_searchpath = calloc(LP_MAX_SP, sizeof(char*));
+
+    while(*p) {
+      colon = strchr(p, ':');
+      if(colon) {
+	char *next;
+
+  	*colon = 0;
+
+	next = colon+1;
+	lp_searchpath[lp_searchpath_len++] = strdup(p);
+
+  	p = next;
+      }
+      else {
+	lp_searchpath[lp_searchpath_len++] = strdup(p);
+	break;
+      }
+    }
+  }
+
+  // this creates a fresh array every time its run so caller 
+  // is responsible for freeing it
+  lp_tlts = 0;
+  lp_tlts_len = 0;
+  
+  fflush(stdout);
+  stdout_save = dup(1);
+  devnull = open("/dev/null", O_RDONLY);
+  dup2(devnull, 1);
+
+  libparamparse();
+
+  fflush(stdout);
+  dup2(stdout_save, 1);
+
+  close(devnull);
+  close(stdout_save);
+
+
+  if(tlts) {
+    *tlts = lp_tlts;
+  }
+  if(tlts_len) {
+    *tlts_len = lp_tlts_len;
+  }
+
+  return 0;
+}
+
+
+
+#define LP_STACK_MAX 32
+int
+lp_loadparams(void *it, struct lp_block *b, struct lp_mod *m) {
+  int c;
+  int needed = 0;
+  int param_stack[LP_STACK_MAX];
+  int stack_ptr = 0;  // index of first free slot
+  // XXX not static size
+  char *paramvec = calloc(m->modvars_len, sizeof(char));
+
+
+  // This is pretty gross; there should be a better solution.
+  // dirname() munges its operand.  Its result may also be a static
+  // buffer somewhere, hence the 2 copies.
+  char *tmp = strdup(b->source_file);
+  lp_cwd = strdup(dirname(tmp));
+  //  free(tmp);
+ 
+  for(c = 0; c < b->params_len; c++) {
+    int pnum, deps;
+    
+    if(!b->params[c]) continue;
+    
+  TOP:
+    pnum = lp_param_name(lp_mod_name(m->name), b->params[c]->name);
+    
+    // Don't initialize things more than once.
+    // Should warn here, probably.
+    if(BIT_TEST(paramvec, pnum)) continue;
+    
+    
+    if(stack_ptr > 0) {
+      for(c = 0; c < b->params_len; c++) {
+	if(lp_param_name(lp_mod_name(m->name), b->params[c]->name) == needed)
+	  goto FOUND;
+      }
+      break;
+    }
+
+
+  FOUND:
+  
+    deps = m->param_deps[pnum](paramvec);
+    if(deps > -1) {
+      ddbg_assert(stack_ptr < LP_STACK_MAX);
+      param_stack[stack_ptr++] = c;
+      needed = deps;
+      continue;
+    }
+    else {
+      switch(PTYPE(b->params[c])) {
+      case I:     
+	((lp_paramloader_int)m->param_loaders[pnum])(it, IVAL(b->params[c])); 
+	break; 
+      case D:     
+	((lp_paramloader_double)m->param_loaders[pnum])(it, DVAL(b->params[c])); 
+	break; 
+      case S:     
+	((lp_paramloader_string)m->param_loaders[pnum])(it, SVAL(b->params[c])); 
+	break; 
+      case LIST:  
+	((lp_paramloader_list)m->param_loaders[pnum])(it, LVAL(b->params[c])); 
+	 break; 
+	 
+      case BLOCK:
+      default:    
+	((lp_paramloader_block)m->param_loaders[pnum])(it, BVAL(b->params[c])); 
+	break; 
+      }
+    }
+
+    BIT_SET(paramvec, pnum);
+    if(stack_ptr > 0) { 
+      c = param_stack[--stack_ptr]; 
+      goto TOP;  
+    }
+  }
+
+  for(c = 0; c < m->modvars_len; c++) {
+    if(m->modvars[c].req && !BIT_TEST(paramvec,c)) {
+      fprintf(stderr, "*** error: in %s spec -- missing required parameter %s\n", m->name, m->modvars[c].name);
+      break;
+    }
+  }
+
+  free(paramvec);
+
+  return 0; // ???
+}
+
+
+char *
+lp_search_path(char *cwd, char *name)
+{
+  char *cand = calloc(LP_PATH_MAX, sizeof(char));
+  struct stat s;
+  int i;
+  
+  if(name[0] == '/')
+    if(stat(name, &s))
+      goto fail;
+
+  snprintf(cand, LP_PATH_MAX, "%s/%s", cwd, name);
+
+  if(!stat(cand, &s))
+    goto succ;
+    
+  for(i = 0; i < lp_searchpath_len; i++) {
+    snprintf(cand, LP_PATH_MAX, 
+	     "%s/%s", lp_searchpath[i], name);
+
+    if(!stat(cand, &s)) {
+      goto succ;
+    }
+  }
+
+ fail:
+  free(cand);
+  return 0;
+
+ succ:
+  return cand;
+
+}
+
diff -uNr disksim-4.0/libparam/util.c disksim-4.0-x64/libparam/util.c
--- disksim-4.0/libparam/util.c	2016-03-23 20:10:28.886755949 +0800
+++ disksim-4.0-x64/libparam/util.c	2016-03-23 19:39:45.198667000 +0800
@@ -47,7 +47,7 @@
 
 #include <fcntl.h>
 
-//#include <libgen.h>
+#include <libgen.h>
 
 #include "libparam.h"
 #include "bitvector.h"
@@ -941,12 +941,15 @@
       (*b)[c] = p;
       break;
     }
+    printf("%d: name = %s\n", c, (*b)[c]->name);
   }
+  fflush(stdout);
   if(c == *plen) {
     /* didn't find a free slot -- double the array */
     int newlen = 2 * (*plen) + 1;
-    (*b) = realloc((*b), newlen * sizeof(int *));
-    bzero((int *)(*b) + *plen, ((*plen) + 1) * sizeof(int*));
+   struct lp_param **new = calloc(newlen, sizeof(struct lp_param *));
+   memcpy(new, *b, (*plen) * sizeof(struct lp_param *));
+   (*b) = new;
     (*b)[(*plen)] = p;
     *plen = newlen;
   }
@@ -986,7 +989,7 @@
 
   for(c = 0; c < lp_max_mod; c++) {
 
-    lp_typetbl[c] = malloc(sizeof(struct lp_subtype));
+    lp_typetbl[c] = calloc(sizeof(struct lp_subtype),1);
     bzero(lp_typetbl[c], sizeof(struct lp_subtype));
     lp_typetbl[c]->sub = strdup(lp_modules[c]->name);
   }
@@ -1395,21 +1398,21 @@
   int i;
   
 #ifndef _WIN32
-  if(name[0] == '/')
+  if(name[0] == '/'){
     if(stat(name, &s))
       goto fail;
     else
       goto succ;
-
+}
   snprintf(cand, LP_PATH_MAX, "%s/%s", cwd, name);
   
 #else
-  if(name[0] == '\\')
+  if(name[0] == '\\'){
     if(stat(name, &s))
       goto fail;
     else
       goto succ;
-
+}
   if (strcmp(cwd, "") == 0)
       cwd = ".";
   
diff -uNr disksim-4.0/libparam/util.c~ disksim-4.0-x64/libparam/util.c~
--- disksim-4.0/libparam/util.c~	1970-01-01 08:00:00.000000000 +0800
+++ disksim-4.0-x64/libparam/util.c~	2016-03-23 19:38:43.826664000 +0800
@@ -0,0 +1,1452 @@
+
+/* libparam (version 1.0)
+ * Authors: John Bucy, Greg Ganger
+ * Contributors: John Griffin, Jiri Schindler, Steve Schlosser
+ *
+ * Copyright (c) of Carnegie Mellon University, 2001-2008.
+ *
+ * This software is being provided by the copyright holders under the
+ * following license. By obtaining, using and/or copying this
+ * software, you agree that you have read, understood, and will comply
+ * with the following terms and conditions:
+ *
+ * Permission to reproduce, use, and prepare derivative works of this
+ * software is granted provided the copyright and "No Warranty"
+ * statements are included with all reproductions and derivative works
+ * and associated documentation. This software may also be
+ * redistributed without charge provided that the copyright and "No
+ * Warranty" statements are included in all redistributions.
+ *
+ * NO WARRANTY. THIS SOFTWARE IS FURNISHED ON AN "AS IS" BASIS.
+ * CARNEGIE MELLON UNIVERSITY MAKES NO WARRANTIES OF ANY KIND, EITHER
+ * EXPRESSED OR IMPLIED AS TO THE MATTER INCLUDING, BUT NOT LIMITED
+ * TO: WARRANTY OF FITNESS FOR PURPOSE OR MERCHANTABILITY, EXCLUSIVITY
+ * OF RESULTS OR RESULTS OBTAINED FROM USE OF THIS SOFTWARE. CARNEGIE
+ * MELLON UNIVERSITY DOES NOT MAKE ANY WARRANTY OF ANY KIND WITH
+ * RESPECT TO FREEDOM FROM PATENT, TRADEMARK, OR COPYRIGHT
+ * INFRINGEMENT.  COPYRIGHT HOLDERS WILL BEAR NO LIABILITY FOR ANY USE
+ * OF THIS SOFTWARE OR DOCUMENTATION.  
+ */
+
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <ctype.h>
+#include <stdlib.h>
+#include <string.h>
+#include <libddbg/libddbg.h>
+
+#include <sys/types.h>
+#include <sys/stat.h>
+
+#ifndef WIN32
+#include <unistd.h>
+#else
+#include <io.h>
+#endif
+
+#include <fcntl.h>
+
+#include <libgen.h>
+
+#include "libparam.h"
+#include "bitvector.h"
+
+static lp_topoloader_t topoloader = 0;
+
+void lp_register_topoloader(lp_topoloader_t l) 
+{
+  topoloader = l;
+}
+
+
+
+
+char *lp_builtin_names[] = {
+  0,
+  "Block",
+  "String",
+  "Int",
+  "Double",
+  "List", 
+  "Topospec"
+};
+
+// FILE *libparamin = 0;
+struct lp_subtype **lp_typetbl;
+int lp_typetbl_len;
+
+struct lp_tlt **lp_tlts;
+int lp_tlts_len;
+
+//extern char lp_filename[];
+//extern char lp_cwd[];
+
+char **lp_searchpath = 0;
+int lp_searchpath_len = 0;
+
+
+extern int lp_lineno;
+
+static void destroy_block(struct lp_block *b);
+static void destroy_value(struct lp_value *v);
+static void destroy_param(struct lp_param *p);
+static void destroy_list(struct lp_list *l);
+static void destroy_topospec(struct lp_topospec *t);
+
+int dumb_split(char *s, char **t, int *i);
+int dumb_split2(char *s, char **s1, char **s2);
+
+
+static int lp_max_mod = 0;
+static int lp_mod_size = 0;
+struct lp_mod **lp_modules = 0;
+
+static char **overrides = 0;
+static int overrides_len = 0;
+
+#define outputfile stdout
+
+
+struct lp_value *lp_new_intv(int i) 
+{
+  struct lp_value *v = calloc(1, sizeof(struct lp_value));
+  v->v.i = i;
+  v->t = I;
+  return v;
+}
+
+struct lp_value *lp_new_doublev(double d) 
+{
+  struct lp_value *v = calloc(1, sizeof(struct lp_value));
+  v->v.d = d;
+  v->t = D;
+  return v;
+}
+
+struct lp_value *lp_new_stringv(char *s) 
+{
+  struct lp_value *v = calloc(1, sizeof(struct lp_value));
+  v->v.s = s;
+  v->t = S;
+  return v;
+}
+
+struct lp_value *lp_new_listv(struct lp_list *l)
+{
+  struct lp_value *v = calloc(1, sizeof(struct lp_value));
+  v->v.l = l;
+  v->t = LIST;
+  return v;
+}
+
+struct lp_value *lp_new_blockv(struct lp_block *b)
+{
+  struct lp_value *v = calloc(1, sizeof(struct lp_value));
+  v->v.b = b;
+  v->t = b->type;
+  return v;
+}
+
+
+struct lp_param *
+lp_new_param(char *name, char *source, struct lp_value *v)
+{
+  struct lp_param *result = calloc(1, sizeof(struct lp_param));
+  result->source_file = source;
+  result->name = name;
+  result->v = v;
+  
+
+  return result;
+}
+
+struct lp_list *
+lp_new_list(void) 
+{
+  struct lp_list *l = calloc(1, sizeof(struct lp_list));
+  l->values = calloc(8, sizeof(struct lp_value *));
+  l->values_len = 8;
+  l->values_pop = 0;
+  l->linelen = 1;
+  return l;
+}
+
+struct lp_block *
+lp_new_block(void)
+{
+  struct lp_block *b = calloc(1, sizeof(struct lp_block));
+  b->params = calloc(8, sizeof(struct lp_param *));
+  b->params_len = 8;
+  return b;
+}
+
+struct lp_list *
+lp_new_intlist(int *intarr, int len)
+{
+  int i;
+  struct lp_list *l = lp_new_list();
+
+  for(i = 0; i < len; i++) {
+    lp_list_add(l, lp_new_intv(intarr[i]));
+  }
+  return l;
+}
+
+
+
+int lp_register_module(struct lp_mod *m) {
+  int c;
+  for(c = 0; c < lp_max_mod; c++) {
+    if(!strcmp(m->name, lp_modules[c]->name)) {
+      return -1;
+    }
+  }
+  if(c >= lp_mod_size) {
+    lp_mod_size *= 2; lp_mod_size++;
+    lp_modules = realloc(lp_modules, lp_mod_size * sizeof(int *));
+  }
+  if(c > 0) 
+    lp_modules[c] = m;
+  else 
+    lp_modules[0] = m;
+
+  lp_max_mod++;
+
+  return c;
+}
+
+
+
+
+static void die(char *msg) {
+  fprintf(stderr, "*** error: FATAL: %s\n", msg);
+  exit(1);
+}
+
+static void destroy_param(struct lp_param *p)
+{
+  free(p->name);
+  destroy_value(p->v);
+  free(p);
+}
+
+
+static void destroy_list(struct lp_list *l) {
+  int c;
+  for(c = 0; c < l->values_len; c++)
+    if(l->values[c])
+      destroy_value(l->values[c]);
+
+  free(l->values);
+  free(l);
+}
+
+
+static void destroy_value(struct lp_value *v) {
+  int d;
+  switch(v->t) {
+  case S:
+    free(v->v.s); 
+    break;
+    
+  case LIST:
+    destroy_list(v->v.l);
+    break;
+    
+  case I: 
+  case D: break;
+
+  case TOPOSPEC:
+    for(d = 0; d < v->v.t.len; d++)
+      destroy_topospec(&v->v.t.l[d]);
+
+    free(v->v.t.l);
+    break;
+      
+  default:
+    destroy_block(v->v.b);
+  }
+
+  free(v);
+}
+
+
+static void destroy_block(struct lp_block *b) {
+  int c;
+  for(c = 0; c < b->params_len; c++) {
+    if(b->params[c]) {
+      destroy_param(b->params[c]);
+    } 
+  }
+
+  free(b->name);
+  free(b->params);
+  free(b);
+}
+
+static void destroy_topospec(struct lp_topospec *t)
+{
+  free(t->type);
+  free(t->name);
+  destroy_list(t->l);
+}
+
+
+static struct lp_block *copy_block(struct lp_block *);
+static struct lp_list *copy_list(struct lp_list *);
+static struct lp_value *copy_value(struct lp_value *);
+static struct lp_param *copy_param(struct lp_param *);
+
+static struct lp_block *copy_block(struct lp_block *b)
+{
+  int c;
+  struct lp_block *result = calloc(1, sizeof(*result));
+  memcpy(result, b, sizeof(struct lp_block));
+  result->params = calloc(b->params_len, sizeof(result->params[0]));
+
+  if(b->name) {
+    result->name = strdup(b->name);
+  }
+
+  for(c = 0; c < b->params_len; c++) {
+    if(b->params[c]) {
+      result->params[c] = copy_param(b->params[c]);
+    }
+  }
+
+  return result;
+}
+
+
+static struct lp_list *copy_list(struct lp_list *l) {
+  int c;
+  struct lp_list *result = calloc(1, sizeof(*result));
+  memcpy(result, l, sizeof(struct lp_list));
+  result->values = calloc(l->values_len, sizeof(result->values[0]));
+  memcpy(result->values, l->values, l->values_len * sizeof(int *));
+  for(c = 0; c < l->values_len; c++) {
+    if(l->values[c]) {
+      result->values[c] = copy_value(l->values[c]);
+    }
+  }
+  return result;
+}
+
+
+static struct lp_value *copy_value(struct lp_value *v) {
+  struct lp_value *result = calloc(1, sizeof(struct lp_value));
+  memcpy(result, v, sizeof(struct lp_value));
+  switch(v->t) {
+  case S:
+    result->v.s = strdup(v->v.s);
+    break;
+
+  case LIST:
+    result->v.l = copy_list(v->v.l);
+    break;
+
+  case BLOCK:
+    result->v.b = copy_block(v->v.b);
+    break;
+
+  default:
+    break;
+  }
+  
+  return result;
+}
+
+static struct lp_param *copy_param(struct lp_param *p) {
+  struct lp_param *result = calloc(1, sizeof(struct lp_param));
+  result->name = strdup(p->name);
+  result->v = copy_value(p->v);
+  return result;
+}
+
+
+static int indent_level = 0;
+
+static void indent(FILE *f) {
+  char *space = calloc(1, 3*indent_level+1);
+  memset(space, (int)' ', 3*indent_level);
+  space[3*indent_level] = 0;
+  fprintf(f, "%s", space);
+  free(space);
+}
+
+void unparse_source(char *source, FILE *outfile) {
+  fprintf(outfile, "source %s", source);
+}
+
+void unparse_type(int t, FILE *outfile) {
+  if(t < 0) {
+    fprintf(outfile, "%s", lp_builtin_names[abs(t)]);
+  }
+  else {
+    if(t > lp_max_mod) {
+      fprintf(outfile, "<UNKNOWN TYPE>");
+    }
+    else {
+      fprintf(outfile, "%s", lp_modules[t]->name);
+    }
+  }
+}
+
+void unparse_param(struct lp_param *p, FILE *outfile) {
+  fprintf(outfile, "%s = ", p->name);
+  if(p->source_file && p->v->source_file) {
+    if(strcmp(p->source_file, p->v->source_file)) {
+      unparse_source(p->v->source_file, outfile);
+      return;
+    }
+  }
+
+  unparse_value(p->v, outfile);
+}
+
+void unparse_value(struct lp_value *v, FILE *outfile) {
+  int c;
+  switch(v->t) {
+  case I:
+    fprintf(outfile, "%d", v->v.i);
+    break;
+  case D:
+    if(v->v.d == 0.0) {
+      fprintf(outfile, "0.0");
+    }
+    else {
+      fprintf(outfile, "%f", v->v.d);
+    }
+    break;
+  case S:
+    fprintf(outfile, "%s", v->v.s);
+    break;
+  case LIST:
+    unparse_list(v->v.l, outfile);
+    break;
+  case TOPOSPEC:
+    for(c = 0; c < v->v.t.len; c++)
+      unparse_topospec(&v->v.t.l[c], outfile);
+    break;
+  default:
+  case BLOCK:
+    unparse_block(v->v.b, outfile);
+    break;
+  }
+}
+
+void unparse_list(struct lp_list *l, FILE *outfile) {
+  int printed = 0;
+  int c;
+
+/*    indent(outfile); */
+
+  fprintf(outfile, "[ ");
+  indent_level++;
+  for(c = 0; c < l->values_len; c++) { 
+    if(!l->values[c]) 
+      continue;
+
+    if(c) {
+      fprintf(outfile, ", ");
+      if(!(c % l->linelen)) {
+	fprintf(outfile, "\n");
+	indent(outfile);
+      }
+    }
+    else {
+      fprintf(outfile, "\n");
+      indent(outfile);
+    }
+
+    printed++;
+    unparse_value(l->values[c], outfile);
+  }
+  indent_level--;
+
+  if((c > 0) && printed) {
+    fprintf(outfile, "\n");
+    indent(outfile);
+  }
+  fprintf(outfile, "]");
+}
+
+
+void unparse_block(struct lp_block *b, FILE *outfile) {
+  int c;
+/*    indent(outfile); */
+  if(b->name) {
+    /* a block definition */
+    fprintf(outfile, "%s %s {\n", lp_modules[b->type]->name, b->name);
+  }
+  else {
+    /* a block value */
+    fprintf(outfile, "%s {\n", lp_modules[b->type]->name);
+
+  }
+
+  indent_level++;
+  for(c = 0; c < b->params_len; c++) {
+    if(!b->params[c]) continue;
+
+    if(c) fprintf(outfile, ",\n");
+
+    unparse_param(b->params[c], outfile);
+  }
+  indent_level--;
+  fprintf(outfile, "\n");
+  indent(outfile);
+  fprintf(outfile, "}");
+  if(b->name) {
+    fprintf(outfile, " # end of %s spec", b->name);
+    fprintf(outfile, "\n\n");
+  }
+}
+
+void unparse_topospec(struct lp_topospec *t, FILE *outfile) {
+  fprintf(outfile, "%s %s ", t->type, t->name);
+  unparse_list(t->l, outfile);
+  // unparse_list() prints a trailing newline...
+  //  fprintf(outputfile, "\n"); 
+}
+
+// somewhat of a hack
+void unparse_tl_topospec(struct lp_topospec *t, FILE *outfile) 
+{
+  fprintf(outfile, "topospec ");
+  unparse_topospec(t, outfile);
+  fprintf(outfile, "\n\n");
+}
+
+void unparse_inst(struct lp_inst *i, FILE *outfile) {
+  fprintf(outfile, "instantiate ");
+  unparse_list(i->l, outfile);
+  fprintf(outfile, " as %s\n\n", i->name);
+}
+
+void unparse_tlt(struct lp_tlt *tlt, FILE *outfile, char *infile) {
+
+  if(tlt->source_file && infile) {
+    if(strcmp(tlt->source_file, infile)) {
+      unparse_source(tlt->source_file, outfile);
+      return;
+    }
+  }
+  
+  switch(tlt->what) {
+  case TLT_BLOCK: unparse_block(tlt->it.block, outfile); break;
+  case TLT_TOPO:  unparse_tl_topospec(tlt->it.topo, outfile); break;
+  case TLT_INST:  unparse_inst(tlt->it.inst, outfile); break;
+  default:        ddbg_assert(0); break;
+  };
+  
+}
+
+void lp_unparse_tlts(struct lp_tlt **tlts, 
+		     int tlts_len, 
+		     FILE *outfile, 
+		     char *infile) 
+{
+  int c;
+  for(c = 0; c < tlts_len; c++) {
+    if(tlts[c] != 0) {
+      unparse_tlt(tlts[c], outfile, infile);
+    }
+  }
+}
+
+
+
+/* instantiate all the elements of <l> as <name> */
+int lp_inst_list(struct lp_inst *i)
+{
+  int c;
+  
+  /*      unparse_block(spec, outputfile); */
+
+  for(c = 0; c < i->l->values_len; c++) {
+    if(!i->l->values[c]) continue;
+    
+    ddbg_assert3(i->l->values[c]->t == S, 
+	       ("bad type for component %s", i->l->values[c]->v.s));
+    
+    lp_instantiate(i->l->values[c]->v.s, i->name);
+  }
+  
+  return 0;
+}
+
+/* instantiate <targ> as <name> */
+int *lp_instantiate(char *targ, char *name) {
+  char *nametmp;
+  struct lp_block *spec;
+  int *obj;
+    
+/*    unparse_block(b, outputfile); */
+
+  spec = lp_lookup_spec(name);
+  ddbg_assert3(spec != 0, ("no such type %s.\n", name));
+
+  // this is a bit of a hack; we swap the name of the component
+  // being instantiated with the name of the module that's being
+  // instantiated so that the loader function sees the target
+  // name
+  nametmp = spec->name;
+  spec->name = targ;
+  
+  //  fprintf(stderr, "*** Instantiating %s as %s\n", targ, name);
+
+  obj = lp_override_inst(spec, 
+			 targ,
+			 lp_modules[spec->type]->fn,
+			 overrides, 
+			 overrides_len);
+
+  // swap the name back
+  spec->name = nametmp;
+
+
+  if(!obj) {
+    return 0;
+  }
+  
+  if(lp_modules[spec->type]->callback) {
+    lp_modules[spec->type]->callback(lp_modules[spec->type]->ctx, obj);
+  }
+
+  return obj;
+}
+
+/* 0 on success, nonzero on error */
+int check_types(struct lp_block *b) {
+  int c = 0;
+
+  /* we'll do all of the type checking here so that 
+   * the per-mod loaders only have to sanitize values */
+
+  for(c = 0; c < b->params_len; c++) {
+    if(b->params[c]) {
+      if(lp_param_name(b->type, b->params[c]->name) == -1) {
+
+	fprintf(stderr, "*** warning: parameter %s not valid in context %s\n",
+		b->params[c]->name, lp_modules[b->type]->name);
+	
+      }
+
+      else if(lp_modules[b->type]->modvars[lp_param_name(b->type, b->params[c]->name)].type
+	 != PTYPE(b->params[c])) {
+
+	/* implicitly convert ints to doubles */
+	if((lp_modules[b->type]->modvars[lp_param_name(b->type, b->params[c]->name)].type
+	    == D)
+	   && (PTYPE(b->params[c]) == I)) {
+	  b->params[c]->v->t = D;
+	  DVAL(b->params[c]) = (double) IVAL(b->params[c]);
+	}
+	  
+	else { 
+	  fprintf(stderr, "*** error: type error: %s::\"%s\" cannot take type ",
+		  lp_modules[b->type]->name,
+		  b->params[c]->name);
+	  
+/*  	  unparse_type(PTYPE(b->params[c]), stderr); */
+	  fprintf(stderr, "\n");
+
+	  die("check_types() failed");
+	}
+      }
+      
+
+
+      if(PTYPE(b->params[c]) >= BLOCK) {
+	check_types(BVAL(b->params[c]));
+      }
+      else if(PTYPE(b->params[c]) == LIST) {
+	int d;
+	struct lp_list *l = LVAL(b->params[c]);
+	for(d = 0; d < l->values_len; d++) {
+	  if(l->values[d]) {
+	    if(l->values[d]->t >= BLOCK) {
+	      check_types(l->values[d]->v.b);
+	    }
+	  }
+	}
+      }
+
+    }
+  }
+  return 0;
+}
+
+void load_block(struct lp_block *b) {
+  int n;
+
+  lp_lookup_type(b->name, &n);
+  lp_typetbl[n]->spec = b;
+}
+
+
+
+
+void load_topo(struct lp_topospec *t, int len) 
+{
+/*    unparse_topospec(t, outputfile); */
+  topoloader(t, len);
+}
+
+
+
+
+
+void printvars(void) {
+  int c, d;
+  for(c = 0; c < lp_max_mod; c++) {
+    for(d = 0; d < lp_modules[c]->modvars_len; d++) {
+      printf("%s::%s\n", lp_modules[c]->name, 
+	     lp_modules[c]->modvars[d].name);
+    }
+  }
+}
+
+
+
+void dummy (struct lp_block *b) { 
+  fprintf(stderr, "*** error: %s cannot be declared at top-level.\n",
+	  b->name);
+  exit(1);
+}
+
+
+struct lp_list *lp_list_add(struct lp_list *l, 
+			    struct lp_value *v)
+{
+  int c, newlen;
+  for(c = 0; c < l->values_len; c++) {
+    if(!l->values[c]) goto done;
+  }
+  newlen = 2 * c * sizeof(struct lp_value *);
+  l->values = realloc(l->values, newlen);
+  bzero(l->values + c, newlen / 2);
+  l->values_len *= 2;
+
+ done:
+  l->values_pop++;
+  l->values[c] = v;
+  
+  return l;
+}
+
+
+
+
+
+/* maps a modtype and parameter name to a nonnegative numeric
+ * representation.  -1 returned on error */
+
+int lp_param_name(int m, char *n)
+{
+  int c = 0;
+  if(!RANGE(m,0,lp_max_mod)) return -1;
+  if(!n) return -1;
+
+  while((c < lp_modules[m]->modvars_len)
+	&& strcmp(lp_modules[m]->modvars[c].name, n)) c++;
+
+  if(c >= lp_modules[m]->modvars_len) {
+    return -1;
+  }
+  else {
+    return c;
+  }
+}
+
+
+int lp_mod_name(char *n) {
+  int c = 0;
+  if(!n) return -1;
+
+  while((c < lp_max_mod) && strcmp(lp_modules[c]->name, n)) c++;
+
+  if(c >= lp_max_mod) {
+    return -1;
+  }
+  else {
+    return c;
+  }
+}
+
+/* get the base type of name */
+char *lp_lookup_base_type(char *name, int *n) {
+  int c;
+  for(c = 0; c < lp_typetbl_len; c++) {
+    if(lp_typetbl[c]) {
+      if(!strcmp(name, lp_typetbl[c]->sub)) {
+	if(lp_typetbl[c]->super) {
+	  return lp_lookup_base_type(lp_typetbl[c]->super, n);
+	}
+	else {
+	  break;
+	}
+      }
+    }
+  }
+
+  if(n) *n = c;
+  return name;
+}
+
+char *lp_lookup_type(char *name, int *n) {
+  int c;
+  for(c = 0; c < lp_typetbl_len; c++) {
+    if(lp_typetbl[c]) {
+      if(!strcmp(name, lp_typetbl[c]->sub)) {
+	if(n) *n = c;
+	return lp_typetbl[c]->super;
+      }
+    }
+  }
+  return 0;
+}
+
+
+
+/* find the specification for name or return 0 if it doesn't exist.
+ * New "wildcard" behavior: if name is null, return the first
+ * spec in the typetbl with non-zero parent -- i.e. only 
+ * match a user-provided spec, not a builtin type!
+ */
+struct lp_block *lp_lookup_spec(char *name) {
+  int c;
+
+  for(c = 0; c < lp_typetbl_len; c++) 
+    if(lp_typetbl[c]) {
+      if(!name) {
+	if(lp_typetbl[c]->super) {
+	  return lp_typetbl[c]->spec;
+	}
+      }
+      else if(!strcmp(name, lp_typetbl[c]->sub)) {
+	return lp_typetbl[c]->spec;
+      }
+    }
+
+  return 0;
+}
+
+
+struct lp_tlt *lp_new_tl_topo(struct lp_topospec *t, char *source_file)
+{
+  struct lp_tlt *result = calloc(1, sizeof(*result));
+  result->source_file = source_file;
+  result->what = TLT_TOPO;
+  result->it.topo = t;
+  lp_add_tlt(result);
+  return result;
+}
+
+struct lp_tlt *lp_new_tl_inst(struct lp_inst *i, char *source_file)
+{
+  struct lp_tlt *result = calloc(1, sizeof(*result));
+  result->source_file = source_file;
+  result->what = TLT_INST;
+  result->it.inst = i;
+  lp_add_tlt(result);
+  return result;
+}
+
+struct lp_tlt *lp_new_tl_block(struct lp_block *b, char *source_file)
+{
+  struct lp_tlt *result = calloc(1, sizeof(*result));
+  result->source_file = source_file;
+  result->what = TLT_BLOCK;
+  result->it.block = b;
+  lp_add_tlt(result);
+  return result;
+}
+
+
+void lp_add_tlt(struct lp_tlt *tlt) {
+  int c;
+  int found = 0;
+
+  for(c = 0; c < lp_tlts_len; c++) {
+    if(!lp_tlts[c]) {
+      found = c; break;
+    }
+  }
+
+  if(!found) {
+    int newlen = lp_tlts_len ? 2 * lp_tlts_len : 2;
+    int zerocnt = lp_tlts_len ? lp_tlts_len : 2;
+    
+    int newsize = newlen * sizeof(struct lp_tlts *);
+    zerocnt *= sizeof(struct lp_tlts *);
+
+    lp_tlts = realloc(lp_tlts, newsize);
+    memset(lp_tlts + lp_tlts_len, 0, zerocnt);
+    found = lp_tlts_len;
+    lp_tlts_len = newlen;
+  }
+
+  lp_tlts[c] = tlt;
+}
+
+
+int lp_add_type(char *newt, char *parent) {
+  int c;
+  int newlen;
+  struct lp_subtype *st = calloc(1, sizeof(*st));
+  st->super = strdup(parent); st->sub = strdup(newt);
+
+  if(!lp_lookup_type(newt,0)) {
+    for(c = 0; c < lp_typetbl_len; c++) 
+      if(!lp_typetbl[c]) {
+	goto done;
+      }
+
+
+    newlen = lp_typetbl_len ? 2 * lp_typetbl_len : 2;
+
+    lp_typetbl = realloc(lp_typetbl, newlen * sizeof(int *));
+
+    bzero(lp_typetbl + c, c * sizeof(int *));
+    lp_typetbl_len = newlen;
+  }
+  else return -1;
+  
+  done:
+  lp_typetbl[c] = st;
+  return 0;
+}
+
+
+int lp_add_param(struct lp_param ***b, int *plen,
+		 struct lp_param *p)
+{
+  int c;
+
+  /* look for dupe params */
+  for(c = 0; c < *plen; c++) {
+    if(!(*b)[c]) continue;
+    if(!strcmp((*b)[c]->name, p->name)) {
+      fprintf(stderr, "*** error: redefined %s\n", p->name);
+      return -1;
+    }
+  }
+
+
+  for(c = 0; c < *plen; c++) {
+    if(!(*b)[c]) {
+      (*b)[c] = p;
+      break;
+    }
+    printf("%d: name = %s\n", c, (*b)[c]->name);
+  }
+  fflush(stdout);
+  if(c == *plen) {
+    /* didn't find a free slot -- double the array */
+    int newlen = 2 * (*plen) + 1;
+   struct lp_param **new = calloc(newlen, sizeof(struct lp_param *));
+   memcpy(new, *b, (*plen) * sizeof(struct lp_param *));
+   (*b) = new;
+    (*b)[(*plen)] = p;
+    *plen = newlen;
+  }
+
+  return 0;
+}
+
+/* copy all of the params in parent not defined in child into
+ * child */
+int lp_setup_subtype(struct lp_block *parent,
+		     struct lp_block *child)
+{
+  int c, d;
+
+  for(c = 0; c < parent->params_len; c++) {
+    int found = 0;
+    for(d = 0; d < child->params_len; d++) {
+      if(!strcmp(child->params[d]->name, parent->params[c]->name)) {
+	found = 1;
+      }
+    }
+    if(!found) {
+      lp_add_param(&child->params, &child->params_len, parent->params[c]);
+    }
+  }
+
+  return 0;
+}
+
+
+
+
+void lp_init_typetbl(void) {
+  int c;
+  lp_typetbl = calloc(lp_max_mod, sizeof(struct subtype *));
+
+
+  for(c = 0; c < lp_max_mod; c++) {
+
+    lp_typetbl[c] = calloc(sizeof(struct lp_subtype),1);
+    bzero(lp_typetbl[c], sizeof(struct lp_subtype));
+    lp_typetbl[c]->sub = strdup(lp_modules[c]->name);
+  }
+
+  lp_typetbl_len = lp_max_mod;
+}
+
+void lp_release_typetbl(void) {
+  int c;
+
+  for(c = 0; c < lp_typetbl_len; c++) {
+    if(!lp_typetbl[c]) continue;
+
+    if(lp_typetbl[c]->spec)
+      destroy_block(lp_typetbl[c]->spec);
+
+    if(lp_typetbl[c]->sub)
+      free(lp_typetbl[c]->sub);
+
+    if(lp_typetbl[c]->super) 
+      free(lp_typetbl[c]->super); 
+
+    free(lp_typetbl[c]);
+  }
+
+  free(lp_typetbl);
+}
+
+
+
+/* splits s into a trailing number (i) and the leading part */
+int dumb_split(char *s, char **t, int *i) {
+  int c = strlen(s) - 1;
+  
+  while(c && isdigit(s[c])) c--;
+  if(!c) return -1;
+  c++;
+  (*i) = atoi(&s[c]);
+  *t = strdup(s);
+  (*t)[c] = 0;
+  return 0;
+}
+
+/* separate 'foo:bar' into 'foo' and 'bar' */
+int dumb_split2(char *s, char **s1, char **s2) {
+  int c = 0;
+  (*s1) = strdup(s);
+  while(s[c] && (s[c] != ':')) c++;
+  (*s1)[c] = 0;
+  if(s[c]) (*s2) = strdup(s + c + 1);
+  else return -1;
+
+  return 0;
+}
+
+
+
+
+
+static int param_override(struct lp_block *b, 
+			  char *pname,
+			  char *pval) 
+{
+  int c;
+  
+  for(c = 0; c < b->params_len; c++) {
+    if(!b->params[c]) continue;
+    if(!strcmp(b->params[c]->name, pname)) {
+      switch(b->params[c]->v->t) {
+      case I:
+	b->params[c]->v->v.i = atoi(pval);
+	break;
+      case D:
+	b->params[c]->v->v.d = atof(pval);
+	break;
+      case S:
+	free(b->params[c]->v->v.s);
+	b->params[c]->v->v.s = strdup(pval);
+	return 0;
+	break;
+
+      default:
+	ddbg_assert(0);
+      }
+
+      return -1;
+    } 
+  }
+
+  
+  return -1;
+}
+
+			  
+
+int range_match(char *range, char *name) {
+  char *base1, *base2, *base3;
+  char r1[128], r2[128];
+  int i1, i2, i3;
+
+  if(!strcmp(range, name)) { return 1; }
+
+  if(!strcmp(range, "*")) return 1;
+
+  if(sscanf(range, "%s .. %s", r1, r2) != 2) { 
+    char *prefix; int junk;
+
+    dumb_split(name, &prefix, &junk);
+
+    /* i.e. driver* matches driver2 and driver and driver2344 but not
+     * driverqux 
+     */
+    if((strlen(range) == ( strlen(prefix) + 1)) &&
+       !strncmp(range,prefix,strlen(prefix)) &&
+       (range[strlen(prefix)] == '*')) return 1;
+
+    return 0; 
+  }
+
+  
+  dumb_split(r1, &base1, &i1);
+  dumb_split(r2, &base2, &i2);
+  if(strcmp(base1, base2) || (i1 < 0) || (i2 < i1)) {
+    fprintf(stderr, "*** error: bad range \"%s .. %s\"\n", r1, r2);
+    return 0;
+  }
+
+  dumb_split(name, &base3, &i3);
+  if(!strcmp(base3, base2) && (i3 >= i1) && (i3 <= i2)) {
+    return 1;
+  }
+  else {
+    return 0;
+  }
+}
+
+
+/* instantiate a component with overrides 
+ * tname type to instantiate,
+ * cname name of instantiated component
+ * loader is the module loader function for tname
+ */
+int *lp_override_inst(struct lp_block *spec, 
+		  char *cname, 
+		  lp_modloader_t loader,
+		  char **overrides,
+		  int overrides_len)
+{
+  int c, d;
+  struct lp_block *spec_copy;
+  char *p1, *p2; 
+  int *result;
+  
+  spec_copy = copy_block(spec);
+
+  for(c = 0; c < overrides_len; c += 3) {
+    if(range_match(overrides[c], cname)) {
+      
+      /* overrides[c+2] could be an int, a real, a string or a list or
+       * a block.  need parser to deal with lists and blocks
+       * reasonably so we aren't going to deal with them here */
+     
+      if(!dumb_split2(overrides[c+1], &p1, &p2)) {
+	/* descend hierarchy */
+	for(d = 0; d < spec_copy->params_len; d++) {
+	  if(!spec_copy->params[d]) continue;
+	  if(!strcmp(p1, spec_copy->params[d]->name)) {
+	    if(spec_copy->params[d]->v->t != BLOCK) {
+	      fprintf(stderr, "*** error: tried to recurse through non-block parameter.\n");
+	      return 0;
+	    }
+	    else {
+	      param_override(spec_copy->params[d]->v->v.b, p2, 
+			     overrides[c+2]);
+	    }
+	  }
+	}
+
+      }
+      else {
+	param_override(spec_copy, 
+		       overrides[c+1], 
+		       overrides[c+2]);
+	
+      }
+    }
+  }
+
+
+
+  if(!check_types(spec_copy)) {
+    result = loader(spec_copy, 0);
+  }
+
+  // XXX don't leak (segfaults)
+  //  destroy_block(spec_copy);
+  return result; 
+}
+
+
+extern void libparamparse(void);
+
+int lp_loadfile(FILE *in, 
+		struct lp_tlt ***tlts, 
+		int *tlts_len, 
+		char *infile,
+		char **cli_overrides,
+		int cli_overrides_len) {
+
+  char *lp_sp;
+  char *dirc;
+  char *dir;
+  
+  int stdout_save;
+  int devnull;
+  top_file = 0;
+  lp_lineno = 1;
+
+  dirc = strdup(infile);
+  dir = dirname(dirc);
+
+  lp_filename = infile;
+  lp_cwd = dir;
+  libparamin = in;
+
+  overrides = cli_overrides;
+  overrides_len = cli_overrides_len;
+
+  // do the searchpath
+#ifdef WIN32
+  lp_sp = strdup(getenv("LP_PATH"));
+#else
+  lp_sp = getenv("LP_PATH");
+#endif
+  if(lp_sp) {
+    char *p = lp_sp;
+    char *colon;
+    
+    lp_searchpath = calloc(LP_MAX_SP, sizeof(char*));
+#ifdef WIN32
+    lp_searchpath_len = 0;
+#endif
+
+    while(*p) {
+#ifdef _WIN32 /* colons can occur in win32 filenames, so use semicolon separator */
+	  colon = strchr(p,';');
+#else
+      colon = strchr(p, ':');
+#endif
+      if(colon) {
+	char *next;
+
+  	*colon = 0;
+
+	next = colon+1;
+	lp_searchpath[lp_searchpath_len++] = strdup(p);
+
+  	p = next;
+      }
+      else {
+	lp_searchpath[lp_searchpath_len++] = strdup(p);
+	break;
+      }
+    }
+  }
+
+#ifdef WIN32
+  free(lp_sp);
+  lp_sp = NULL;
+#endif
+
+  // this creates a fresh array every time its run so caller 
+  // is responsible for freeing it
+  lp_tlts = 0;
+  lp_tlts_len = 0;
+  
+  fflush(stdout);
+  stdout_save = dup(1);
+#ifndef WIN32
+  devnull = open("/dev/null", O_RDONLY);
+  dup2(devnull, 1);
+#endif
+
+  libparamparse();
+
+  fflush(stdout);
+
+#ifndef WIN32
+  dup2(stdout_save, 1);
+  close(devnull);
+  close(stdout_save);
+#endif
+
+  if(tlts) {
+    *tlts = lp_tlts;
+  }
+  if(tlts_len) {
+    *tlts_len = lp_tlts_len;
+  }
+
+  return 0;
+}
+
+
+
+#define LP_STACK_MAX 32
+int
+lp_loadparams(void *it, struct lp_block *b, struct lp_mod *m) {
+  int c;
+  int needed = 0;
+  int param_stack[LP_STACK_MAX];
+  int stack_ptr = 0;  // index of first free slot
+  // XXX not static size
+  char *paramvec = calloc(m->modvars_len, sizeof(char));
+
+
+  // This is pretty gross; there should be a better solution.
+  // dirname() munges its operand.  Its result may also be a static
+  // buffer somewhere, hence the 2 copies.
+  char *tmp = strdup(b->source_file);
+  lp_cwd = strdup(dirname(tmp));
+  //  free(tmp);
+ 
+  for(c = 0; c < b->params_len; c++) {
+    int pnum, deps;
+    
+    if(!b->params[c]) continue;
+    
+  TOP:
+    pnum = lp_param_name(lp_mod_name(m->name), b->params[c]->name);
+    
+    // Don't initialize things more than once.
+    // Should warn here, probably.
+    if(BIT_TEST(paramvec, pnum)) continue;
+    
+    
+    if(stack_ptr > 0) {
+      for(c = 0; c < b->params_len; c++) {
+	if(lp_param_name(lp_mod_name(m->name), b->params[c]->name) == needed)
+	  goto FOUND;
+      }
+      break;
+    }
+
+
+  FOUND:
+  
+    deps = m->param_deps[pnum](paramvec);
+    if(deps > -1) {
+      ddbg_assert(stack_ptr < LP_STACK_MAX);
+      param_stack[stack_ptr++] = c;
+      needed = deps;
+      continue;
+    }
+    else {
+      switch(PTYPE(b->params[c])) {
+      case I:     
+	((lp_paramloader_int)m->param_loaders[pnum])(it, IVAL(b->params[c])); 
+	break; 
+      case D:     
+	((lp_paramloader_double)m->param_loaders[pnum])(it, DVAL(b->params[c])); 
+	break; 
+      case S:     
+	((lp_paramloader_string)m->param_loaders[pnum])(it, SVAL(b->params[c])); 
+	break; 
+      case LIST:  
+	((lp_paramloader_list)m->param_loaders[pnum])(it, LVAL(b->params[c])); 
+	 break; 
+	 
+      case BLOCK:
+      default:    
+	((lp_paramloader_block)m->param_loaders[pnum])(it, BVAL(b->params[c])); 
+	break; 
+      }
+    }
+
+    BIT_SET(paramvec, pnum);
+    if(stack_ptr > 0) { 
+      c = param_stack[--stack_ptr]; 
+      goto TOP;  
+    }
+  }
+
+  for(c = 0; c < m->modvars_len; c++) {
+    if(m->modvars[c].req && !BIT_TEST(paramvec,c)) {
+      fprintf(stderr, "*** error: in %s spec -- missing required parameter %s\n", m->name, m->modvars[c].name);
+      break;
+    }
+  }
+
+  free(paramvec);
+
+  return 0; // ???
+}
+
+
+char *
+lp_search_path(char *cwd, char *name)
+{
+  char *cand = calloc(LP_PATH_MAX, sizeof(char));
+#ifdef _WIN32
+  struct _stat s;
+#else
+  struct stat s;
+#endif
+  int i;
+  
+#ifndef _WIN32
+  if(name[0] == '/')
+    if(stat(name, &s))
+      goto fail;
+    else
+      goto succ;
+
+  snprintf(cand, LP_PATH_MAX, "%s/%s", cwd, name);
+  
+#else
+  if(name[0] == '\\')
+    if(stat(name, &s))
+      goto fail;
+    else
+      goto succ;
+
+  if (strcmp(cwd, "") == 0)
+      cwd = ".";
+  
+  snprintf(cand, LP_PATH_MAX, "%s\\%s", cwd, name);
+
+  /* use \ separator instead of / */
+    {
+        char *sep = cand;
+        while (*sep)
+        {
+            if (*sep == '/') *sep = '\\';
+            sep++;
+        }
+    }
+#endif
+
+  if(!stat(cand, &s))
+    goto succ;
+    
+  for(i = 0; i < lp_searchpath_len; i++) {
+    snprintf(cand, LP_PATH_MAX, 
+	     "%s/%s", lp_searchpath[i], name);
+
+    if(!stat(cand, &s)) {
+      goto succ;
+    }
+  }
+
+ fail:
+  free(cand);
+  return 0;
+
+ succ:
+  return cand;
+
+}
+
diff -uNr disksim-4.0/.paths disksim-4.0-x64/.paths
--- disksim-4.0/.paths	2016-03-23 20:10:28.878755948 +0800
+++ disksim-4.0-x64/.paths	2016-03-23 19:55:51.918713000 +0800
@@ -1,47 +1,47 @@
 # libdisksim
-export LIBDISKSIM_PREFIX=
+export LIBDISKSIM_PREFIX=../
 export LIBDISKSIM_INCL=$(LIBDISKSIM_PREFIX)/include
 export LIBDISKSIM_CFLAGS=-I$(LIBDISKSIM_INCL)
 export LIBDISKSIM_LDPATH=$(LIBDISKSIM_PREFIX)/lib
 export LIBDISKSIM_LDFLAGS=-L$(LIBDISKSIM_LDPATH) -ldisksim
 
 # disksim internals (for memsmodel, etc)
-export DISKSIM_PREFIX=src/
+export DISKSIM_PREFIX=../src/
 export DISKSIM_INCL=$(DISKSIM_PREFIX)/
 export DISKSIM_CFLAGS=-I$(DISKSIM_INCL)
 export DISKSIM_LDPATH=$(DISKSIM_PREFIX)/
 export DISKSIM_LDFLAGS=-L$(DISKSIM_LDPATH) -ldisksim
 
 # path to diskmodel
-export DISKMODEL_PREFIX=diskmodel
+export DISKMODEL_PREFIX=../diskmodel
 export DISKMODEL_INCL=$(DISKMODEL_PREFIX)/include
 export DISKMODEL_CFLAGS=-I$(DISKMODEL_INCL)
 export DISKMODEL_LDPATH=$(DISKMODEL_PREFIX)/lib
 export DISKMODEL_LDFLAGS=-L$(DISKMODEL_LDPATH) -ldiskmodel
 
 # path to libparam
-export LIBPARAM_PREFIX=libparam
+export LIBPARAM_PREFIX=../libparam
 export LIBPARAM_INCL=$(LIBPARAM_PREFIX)/include
 export LIBPARAM_CFLAGS=-I$(LIBPARAM_INCL)
 export LIBPARAM_LDPATH=$(LIBPARAM_PREFIX)/lib
 export LIBPARAM_LDFLAGS=-L$(LIBPARAM_LDPATH) -lparam
 
 # libtrace
-export LIBDDBG_PREFIX=libddbg
+export LIBDDBG_PREFIX=../libddbg
 export LIBDDBG_INCL=$(LIBDDBG_PREFIX)/include
 export LIBDDBG_CFLAGS=-I$(LIBDDBG_INCL)
 export LIBDDBG_LDPATH=$(LIBDDBG_PREFIX)/lib
 export LIBDDBG_LDFLAGS=-L$(LIBDDBG_LDPATH) -lddbg
 
 # path to memsmodel
-export MEMSMODEL_PREFIX=memsmodel
+export MEMSMODEL_PREFIX=../memsmodel
 export MEMSMODEL_INCL=$(MEMSMODEL_PREFIX)/include
 export MEMSMODEL_CFLAGS=-I$(MEMSMODEL_INCL)
 export MEMSMODEL_LDPATH=$(MEMSMODEL_PREFIX)/lib
 export MEMSMODEL_LDFLAGS=-L$(MEMSMODEL_LDPATH) -lmemsmodel
 
 # path to ssdmodel
-export SSDMODEL_PREFIX=ssdmodel
+export SSDMODEL_PREFIX=../ssdmodel
 export SSDMODEL_INCL=$(SSDMODEL_PREFIX)/include
 export SSDMODEL_CFLAGS=-I$(SSDMODEL_INCL)
 export SSDMODEL_LDPATH=$(SSDMODEL_PREFIX)/lib
diff -uNr disksim-4.0/.paths~ disksim-4.0-x64/.paths~
--- disksim-4.0/.paths~	1970-01-01 08:00:00.000000000 +0800
+++ disksim-4.0-x64/.paths~	2016-03-23 18:31:20.443809000 +0800
@@ -0,0 +1,48 @@
+# libdisksim
+export LIBDISKSIM_PREFIX=
+export LIBDISKSIM_INCL=$(LIBDISKSIM_PREFIX)/include
+export LIBDISKSIM_CFLAGS=-I$(LIBDISKSIM_INCL)
+export LIBDISKSIM_LDPATH=$(LIBDISKSIM_PREFIX)/lib
+export LIBDISKSIM_LDFLAGS=-L$(LIBDISKSIM_LDPATH) -ldisksim
+
+# disksim internals (for memsmodel, etc)
+export DISKSIM_PREFIX=src/
+export DISKSIM_INCL=$(DISKSIM_PREFIX)/
+export DISKSIM_CFLAGS=-I$(DISKSIM_INCL)
+export DISKSIM_LDPATH=$(DISKSIM_PREFIX)/
+export DISKSIM_LDFLAGS=-L$(DISKSIM_LDPATH) -ldisksim
+
+# path to diskmodel
+export DISKMODEL_PREFIX=diskmodel
+export DISKMODEL_INCL=$(DISKMODEL_PREFIX)/include
+export DISKMODEL_CFLAGS=-I$(DISKMODEL_INCL)
+export DISKMODEL_LDPATH=$(DISKMODEL_PREFIX)/lib
+export DISKMODEL_LDFLAGS=-L$(DISKMODEL_LDPATH) -ldiskmodel
+
+# path to libparam
+export LIBPARAM_PREFIX=libparam
+export LIBPARAM_INCL=$(LIBPARAM_PREFIX)/include
+export LIBPARAM_CFLAGS=-I$(LIBPARAM_INCL)
+export LIBPARAM_LDPATH=$(LIBPARAM_PREFIX)/lib
+export LIBPARAM_LDFLAGS=-L$(LIBPARAM_LDPATH) -lparam
+
+# libtrace
+export LIBDDBG_PREFIX=libddbg
+export LIBDDBG_INCL=$(LIBDDBG_PREFIX)/include
+export LIBDDBG_CFLAGS=-I$(LIBDDBG_INCL)
+export LIBDDBG_LDPATH=$(LIBDDBG_PREFIX)/lib
+export LIBDDBG_LDFLAGS=-L$(LIBDDBG_LDPATH) -lddbg
+
+# path to memsmodel
+export MEMSMODEL_PREFIX=memsmodel
+export MEMSMODEL_INCL=$(MEMSMODEL_PREFIX)/include
+export MEMSMODEL_CFLAGS=-I$(MEMSMODEL_INCL)
+export MEMSMODEL_LDPATH=$(MEMSMODEL_PREFIX)/lib
+export MEMSMODEL_LDFLAGS=-L$(MEMSMODEL_LDPATH) -lmemsmodel
+
+# path to ssdmodel
+export SSDMODEL_PREFIX=ssdmodel
+export SSDMODEL_INCL=$(SSDMODEL_PREFIX)/include
+export SSDMODEL_CFLAGS=-I$(SSDMODEL_INCL)
+export SSDMODEL_LDPATH=$(SSDMODEL_PREFIX)/lib
+export SSDMODEL_LDFLAGS=-L$(SSDMODEL_LDPATH) -lssdmodel
diff -uNr disksim-4.0/.paths.in disksim-4.0-x64/.paths.in
--- disksim-4.0/.paths.in	2003-01-10 03:47:45.000000000 +0800
+++ disksim-4.0-x64/.paths.in	2016-03-23 19:57:07.730717000 +0800
@@ -1,21 +1,2 @@
-
-# path to diskmodel
-export DISKMODEL_PREFIX=
-export DISKMODEL_INCL=$(DISKMODEL_PREFIX)/include
-export DISKMODEL_CFLAGS=-I$(DISKMODEL_INCL)
-export DISKMODEL_LDPATH=$(DISKMODEL_PREFIX)/lib
-export DISKMODEL_LDFLAGS=-L$(DISKMODEL_LDPATH) -ldiskmodel
-
-# path to libparam
-export LIBPARAM_PREFIX=
-export LIBPARAM_INCL=$(LIBPARAM_PREFIX)/include
-export LIBPARAM_CFLAGS=-I$(LIBPARAM_INCL)
-export LIBPARAM_LDPATH=$(LIBPARAM_PREFIX)/lib
-export LIBPARAM_LDFLAGS=-L$(LIBPARAM_LDPATH) -lparam
-
-# libtrace
 export LIBDDBG_PREFIX=
 export LIBDDBG_INCL=$(LIBDDBG_PREFIX)/include
-export LIBDDBG_CFLAGS=-I$(LIBDDBG_INCL)
-export LIBDDBG_LDPATH=$(LIBDDBG_PREFIX)/lib
-export LIBDDBG_LDFLAGS=-L$(LIBDDBG_LDPATH) -lddbg
diff -uNr disksim-4.0/.paths.in~ disksim-4.0-x64/.paths.in~
--- disksim-4.0/.paths.in~	1970-01-01 08:00:00.000000000 +0800
+++ disksim-4.0-x64/.paths.in~	2016-03-23 19:57:05.202717000 +0800
@@ -0,0 +1,3 @@
+export LIBDDBG_PREFIX=
+export LIBDDBG_INCL=$(LIBDDBG_PREFIX)/include
+
diff -uNr disksim-4.0/src/disksim_device.c disksim-4.0-x64/src/disksim_device.c
--- disksim-4.0/src/disksim_device.c	2016-03-23 20:10:28.890755949 +0800
+++ disksim-4.0-x64/src/disksim_device.c	2016-03-23 19:52:19.738703000 +0800
@@ -143,31 +143,26 @@
   /* note that numdisks must be equal to diskinfo->disks_len */
   newlen = numdevices ? (2 * numdevices) : 2;
   zerocnt = (newlen == 2) ? 2 : (newlen/2);
-  disksim->deviceinfo->devicenames = 
-    realloc(disksim->deviceinfo->devicenames, newlen * sizeof(char *));
-  bzero(disksim->deviceinfo->devicenames + c, zerocnt * sizeof(char *));
-
-  devicenos = realloc(devicenos, newlen*sizeof(int));
-#ifndef WIN32
-  bzero(devicenos + c, zerocnt * sizeof(int));
-#else
-  bzero(devicenos + c, zerocnt * sizeof(*(devicenos)));
-#endif
-
-  devicetypes = realloc(devicetypes, newlen*sizeof(int));
-#ifndef WIN32
-  bzero(devicetypes + c, zerocnt * sizeof(int));
-#else
-  bzero(devicetypes + c, zerocnt * sizeof(*(devicetypes)));
-#endif
-
-  disksim->deviceinfo->devices = realloc(disksim->deviceinfo->devices, 
-					 newlen*sizeof(int));
-#ifndef WIN32
-  bzero(disksim->deviceinfo->devices + c, zerocnt * sizeof(int));
-#else
-  bzero(disksim->deviceinfo->devices + c, zerocnt * sizeof(*(disksim->deviceinfo->devices)));
-#endif
+ 
+char **tmpdevname = calloc(newlen, sizeof(char *));
+  int *newdevnos    = calloc(newlen, sizeof(int));
+  int *newdevtypes  = calloc(newlen, sizeof(int));
+  struct deviceheader **newdevs = calloc(newlen, sizeof(struct deviceheader *));
+
+  if (numdevices){
+    memcpy(tmpdevname, disksim->deviceinfo->devicenames, numdevices * sizeof(char*));
+    memcpy(newdevnos, devicenos, numdevices * sizeof(int));
+    memcpy(newdevtypes, devicetypes, numdevices * sizeof(int));
+    memcpy(newdevs, disksim->deviceinfo->devices,
+    numdevices * sizeof(struct deviceheader *));
+  }
+
+  disksim->deviceinfo->devicenames = tmpdevname;
+  devicenos = newdevnos;
+  devicetypes = newdevtypes;
+  disksim->deviceinfo->devices = newdevs;
+
+
 
   disksim->deviceinfo->devs_len = newlen;
 
diff -uNr disksim-4.0/src/disksim_device.c~ disksim-4.0-x64/src/disksim_device.c~
--- disksim-4.0/src/disksim_device.c~	1970-01-01 08:00:00.000000000 +0800
+++ disksim-4.0-x64/src/disksim_device.c~	2016-03-23 19:42:20.762675000 +0800
@@ -0,0 +1,501 @@
+/*
+ * DiskSim Storage Subsystem Simulation Environment (Version 4.0)
+ * Revision Authors: John Bucy, Greg Ganger
+ * Contributors: John Griffin, Jiri Schindler, Steve Schlosser
+ *
+ * Copyright (c) of Carnegie Mellon University, 2001-2008.
+ *
+ * This software is being provided by the copyright holders under the
+ * following license. By obtaining, using and/or copying this software,
+ * you agree that you have read, understood, and will comply with the
+ * following terms and conditions:
+ *
+ * Permission to reproduce, use, and prepare derivative works of this
+ * software is granted provided the copyright and "No Warranty" statements
+ * are included with all reproductions and derivative works and associated
+ * documentation. This software may also be redistributed without charge
+ * provided that the copyright and "No Warranty" statements are included
+ * in all redistributions.
+ *
+ * NO WARRANTY. THIS SOFTWARE IS FURNISHED ON AN "AS IS" BASIS.
+ * CARNEGIE MELLON UNIVERSITY MAKES NO WARRANTIES OF ANY KIND, EITHER
+ * EXPRESSED OR IMPLIED AS TO THE MATTER INCLUDING, BUT NOT LIMITED
+ * TO: WARRANTY OF FITNESS FOR PURPOSE OR MERCHANTABILITY, EXCLUSIVITY
+ * OF RESULTS OR RESULTS OBTAINED FROM USE OF THIS SOFTWARE. CARNEGIE
+ * MELLON UNIVERSITY DOES NOT MAKE ANY WARRANTY OF ANY KIND WITH RESPECT
+ * TO FREEDOM FROM PATENT, TRADEMARK, OR COPYRIGHT INFRINGEMENT.
+ * COPYRIGHT HOLDERS WILL BEAR NO LIABILITY FOR ANY USE OF THIS SOFTWARE
+ * OR DOCUMENTATION.
+ *
+ */
+
+
+
+/*
+ * DiskSim Storage Subsystem Simulation Environment (Version 2.0)
+ * Revision Authors: Greg Ganger
+ * Contributors: Ross Cohen, John Griffin, Steve Schlosser
+ *
+ * Copyright (c) of Carnegie Mellon University, 1999.
+ *
+ * Permission to reproduce, use, and prepare derivative works of
+ * this software for internal use is granted provided the copyright
+ * and "No Warranty" statements are included with all reproductions
+ * and derivative works. This software may also be redistributed
+ * without charge provided that the copyright and "No Warranty"
+ * statements are included in all redistributions.
+ *
+ * NO WARRANTY. THIS SOFTWARE IS FURNISHED ON AN "AS IS" BASIS.
+ * CARNEGIE MELLON UNIVERSITY MAKES NO WARRANTIES OF ANY KIND, EITHER
+ * EXPRESSED OR IMPLIED AS TO THE MATTER INCLUDING, BUT NOT LIMITED
+ * TO: WARRANTY OF FITNESS FOR PURPOSE OR MERCHANTABILITY, EXCLUSIVITY
+ * OF RESULTS OR RESULTS OBTAINED FROM USE OF THIS SOFTWARE. CARNEGIE
+ * MELLON UNIVERSITY DOES NOT MAKE ANY WARRANTY OF ANY KIND WITH RESPECT
+ * TO FREEDOM FROM PATENT, TRADEMARK, OR COPYRIGHT INFRINGEMENT.
+ */
+
+
+#include "disksim_global.h"
+#include "disksim_iosim.h"
+#include "disksim_device.h"
+#include "disksim_disk.h"
+#include "disksim_simpledisk.h"
+#include "memsmodel/mems_global.h"
+#include "memsmodel/mems_disksim.h"
+#include "ssdmodel/ssd.h"  /* SSD: */
+#include "config.h"
+
+#include "modules/modules.h"
+
+
+/* This remaps device numbers amongst multiple types of devices (each */
+/* of which keeps internal arrays based on the remapped numbers). So, */
+/* the device implementations need to be careful to call back to get  */
+/* the remapping info...                                              */
+
+/* To avoid the corresponding confusion, we will simply remap devnos  */
+/* to themselves for now.  So, each device implementation should      */
+/* allocate MAXDEVICES structures and track which of them are used.   */
+
+
+/* private remapping #defines for variables from device_info_t */
+#define numdevices                  (disksim->deviceinfo->numdevices)
+	/* per-devno device type */
+#define devicetypes                 (disksim->deviceinfo->devicetypes)
+	/* per-devno device number (for when remapping them) */
+#define devicenos                   (disksim->deviceinfo->devicenos)
+	/* number of devices of each type */
+#define maxdeviceno                 (disksim->deviceinfo->maxdeviceno)
+
+
+struct device_header *
+getdevbyname(char *name, 
+	     int *gdevnum, /* global device number */
+	     int *ldevnum, /* type-specific device number */
+	     int *type)    /* device type */
+{
+  int c;
+  for(c = 0; c < disksim->deviceinfo->devs_len; c++) {
+    if(!disksim->deviceinfo->devicenames[c]) continue;
+    if(!strcmp(name, disksim->deviceinfo->devicenames[c])) {
+
+      if(gdevnum) *gdevnum = c;
+      if(ldevnum) *ldevnum = devicenos[c];
+      if(type)    *type = devicetypes[c];
+      switch(devicetypes[c]) {
+      case DEVICETYPE_DISK:
+	return (struct device_header *)getdisk(devicenos[c]);
+	break;
+      case DEVICETYPE_SIMPLEDISK:
+	return (struct device_header *)getsimpledisk(devicenos[c]);
+	break;
+      case DEVICETYPE_MEMS:
+	return (struct device_header *)getmems(devicenos[c]);
+	break;
+      case DEVICETYPE_SSD: /* SSD: */
+	return (struct device_header *)getssd(devicenos[c]);
+	break;
+      }
+    }
+  }
+  return 0;
+}
+
+void device_initialize_deviceinfo (void)
+{
+   if (disksim->deviceinfo == NULL) {
+      disksim->deviceinfo = malloc (sizeof(device_info_t));
+      bzero ((char *)disksim->deviceinfo, sizeof(device_info_t));
+   }
+}
+
+void device_add(struct device_header *d, int ldevno) {
+  int c, newlen;
+  int zerocnt;
+  device_initialize_deviceinfo();
+  
+  for(c = 0; c < disksim->deviceinfo->devs_len; c++) {
+    if(!disksim->deviceinfo->devicenames[c]) {
+      goto foundslot;
+    }
+  }
+
+  /* note that numdisks must be equal to diskinfo->disks_len */
+  newlen = numdevices ? (2 * numdevices) : 2;
+  zerocnt = (newlen == 2) ? 2 : (newlen/2);
+ 
+char **tmpdevname = calloc(newlen, sizeof(char *));
+  int *newdevnos    = calloc(newlen, sizeof(int));
+  int *newdevtypes  = calloc(newlen, sizeof(int));
+  struct deviceheader **newdevs = calloc(newlen, sizeof(struct deviceheader *));
+
+  if (numdevices){
+    memcpy(tmpdevname, disksim->deviceinfo->devicenames, numdevices * sizeof(char*));
+    memcpy(newdevnos, devicenos, numdevices * sizeof(int));
+    memcpy(newdevtypes, devicetypes, numdevices * sizeof(int));
+    memcpy(newdevs, disksim->deviceinfo->devices,
+    numdevices * sizeof(struct deviceheader *));
+  }
+
+  disksim->deviceinfo->devicenames = tmpdevname;
+  devicenos = newdevnos;
+  devicetypes = newdevtypes;
+  disksim->deviceinfo->devices = newdevs;
+
+
+
+  disksim->deviceinfo->devs_len = newlen;
+
+ foundslot:
+  disksim->deviceinfo->devicenames[c] = d->device_name;
+  devicetypes[c] = d->device_type;
+  devicenos[c] = ldevno;
+  if(maxdeviceno[devicetypes[c]] < devicenos[c]) {
+    maxdeviceno[devicetypes[c]] = devicenos[c];
+  }
+  disksim->deviceinfo->devices[c] = d;
+
+  numdevices+;
+}
+
+
+
+int disksim_device_stats_loadparams(struct lp_block *b) {
+
+  device_initialize_deviceinfo();
+    
+/*    unparse_block(b, outputfile); */
+
+  //#include "modules/disksim_device_stats_param.c"
+  lp_loadparams(0, b, &disksim_device_stats_mod);
+
+  /* none of the devices currently have dev-specific stats so we aren't
+   * going to look for them here for now */
+  
+  return 1;
+}
+
+
+
+
+
+void device_setcallbacks (void)
+{
+   /* call for each type of device */
+   disk_setcallbacks ();
+   simpledisk_setcallbacks ();
+   /* mems checkpointing not supported */
+   fprintf(stderr,"Warning: mems checkpointing not supported (yet)!\n");
+}
+
+
+void device_initialize (void)
+{
+   /* call for each type of device */
+  disk_initialize ();
+  simpledisk_initialize ();
+  mems_initialize ();
+  ssd_initialize ();
+}
+
+void device_resetstats (void)
+{
+   /* call for each type of device */
+   disk_resetstats ();
+   simpledisk_resetstats ();
+   mems_resetstats ();
+   ssd_resetstats ();
+}
+
+
+void device_printstats (void)
+{
+   /* call for each type of device */
+   disk_printstats ();
+   simpledisk_printstats ();
+   mems_printstats ();
+   ssd_printstats ();
+}
+
+
+void device_printsetstats (int *set, int setsize, char *sourcestr)
+{
+   int i;
+   int devicetype = devicetypes[set[0]];
+
+   /* verify that all set members are of same device type */
+   for (i=0; i<setsize; i++) {
+      if (devicetypes[set[i]] != devicetype) {
+         // fprintf(stderr, "Can't have mismatching devicetypes in device_printsetstats (%d != %d)\n", devicetypes[set[i]], devicetype);
+         /* Might want to just return (and put this message in the output */
+         /* file) rather than exiting...                                  */
+         // exit(1);
+         return;
+      }
+   }
+
+   /* call the appropriate one */
+   switch(devicetype) {
+   case DEVICETYPE_DISK:
+      disk_printsetstats (set, setsize, sourcestr);
+      break;
+   case DEVICETYPE_SIMPLEDISK:
+      simpledisk_printsetstats (set, setsize, sourcestr);
+      break;
+   case DEVICETYPE_MEMS:
+      mems_printsetstats (set, setsize, sourcestr);
+      break;
+   case DEVICETYPE_SSD:
+      ssd_printsetstats (set, setsize, sourcestr);
+      break;
+   default:
+      fprintf(stderr, "Unknown value for device type: devicetype %d\n", devicetype);
+      assert(0);
+   }
+}
+
+
+void device_cleanstats (void)
+{
+   /* call for each type of device */
+   disk_cleanstats ();
+   simpledisk_cleanstats ();
+   mems_cleanstats ();
+}
+
+
+INLINE int device_set_depth (int devno, int inbusno, int depth, int slotno)
+{
+   ASSERT1 ((devno >= 0) && (devno < numdevices), "devno", devno);
+   return disksim->deviceinfo->devices[devno]->set_depth(devicenos[devno], inbusno, depth, slotno);
+}
+
+
+INLINE int device_get_depth (int devno)
+{
+   ASSERT1 ((devno >= 0) && (devno < numdevices), "devno", devno);
+   return disksim->deviceinfo->devices[devno]->get_depth(devno);
+}
+
+
+INLINE int device_get_inbus (int devno)
+{
+   ASSERT1 ((devno >= 0) && (devno < numdevices), "devno", devno);
+   return disksim->deviceinfo->devices[devno]->get_inbus(devno);
+}
+
+
+INLINE int device_get_busno (ioreq_event *curr)
+{
+   ASSERT1 ((curr->devno >= 0) && (curr->devno < numdevices), "curr->devno", curr->devno);
+   return disksim->deviceinfo->devices[curr->devno]->get_busno(curr);
+}
+
+
+INLINE int device_get_slotno (int devno)
+{
+   ASSERT1 ((devno >= 0) && (devno < numdevices), "devno", devno);
+   return disksim->deviceinfo->devices[devno]->get_slotno(devno);
+}
+
+
+INLINE int device_get_number_of_blocks (int devno)
+{
+   ASSERT1 ((devno >= 0) && (devno < numdevices), "devno", devno);
+   return disksim->deviceinfo->devices[devno]->get_number_of_blocks(devno);
+}
+
+
+INLINE int device_get_maxoutstanding (int devno)
+{
+   ASSERT1 ((devno >= 0) && (devno < numdevices), "devno", devno);
+   return disksim->deviceinfo->devices[devno]->get_maxoutstanding(devno);
+}
+
+
+int device_get_numdevices (void)
+{
+   return ( numdevices );
+}
+
+
+INLINE int device_get_numcyls (int devno)
+{
+   ASSERT1 ((devno >= 0) && (devno < numdevices), "devno", devno);
+   return disksim->deviceinfo->devices[devno]->get_numcyls(devno);
+}
+
+
+INLINE double device_get_blktranstime (ioreq_event *curr)
+{
+   ASSERT1 ((curr->devno >= 0) && (curr->devno < numdevices), "curr->devno", curr->devno);
+   return disksim->deviceinfo->devices[curr->devno]->get_blktranstime(curr);
+}
+
+
+INLINE int device_get_avg_sectpercyl (int devno)
+{
+   ASSERT1 ((devno >= 0) && (devno < numdevices), "devno", devno);
+   return disksim->deviceinfo->devices[devno]->get_avg_sectpercyl(devno);
+}
+
+
+INLINE void device_get_mapping (int maptype, 
+				int devno, 
+				int blkno, 
+				int *cylptr, 
+				int *surfaceptr, 
+				int *blkptr)
+{
+   ASSERT1 ((devno >= 0) && (devno < numdevices), "devno", devno);
+   return disksim->deviceinfo->devices[devno]->get_mapping(maptype, 
+							   devno, 
+							   blkno, 
+							   cylptr, 
+							   surfaceptr, 
+							   blkptr);
+}
+
+
+INLINE void device_event_arrive (ioreq_event *curr)
+{
+   ASSERT1 ((curr->devno >= 0) && (curr->devno < numdevices), "curr->devno", curr->devno);
+   return disksim->deviceinfo->devices[curr->devno]->event_arrive(curr);
+}
+
+
+INLINE int device_get_distance (int devno, 
+				ioreq_event *req, 
+				int exact, 
+				int direction)
+{
+   ASSERT1 ((devno >= 0) && (devno < numdevices), "devno", devno);
+   return disksim->deviceinfo->devices[devno]->get_distance(devno,
+							    req,
+							    exact,
+							    direction);
+}
+
+
+INLINE double device_get_servtime (int devno, 
+				   ioreq_event *req, 
+				   int checkcache, 
+				   double maxtime)
+{
+   ASSERT1 ((devno >= 0) && (devno < numdevices), "devno", devno);
+   return disksim->deviceinfo->devices[devno]->get_servtime(devno,
+							    req,
+							    checkcache,
+							    maxtime);
+}
+
+double device_get_seektime (int devno, 
+			    ioreq_event *req, 
+			    int checkcache, 
+			    double maxtime)
+{
+   ASSERT1 ((devno >= 0) && (devno < numdevices), "devno", devno);
+
+   return disksim->deviceinfo->devices[devno]->get_seektime(devno,
+							    req,
+							    checkcache,
+							    maxtime);
+}
+
+
+INLINE double device_get_acctime (int devno, 
+				  ioreq_event *req, 
+				  double maxtime)
+{
+   ASSERT1 ((devno >= 0) && (devno < numdevices), "devno", devno);
+
+   return disksim->deviceinfo->devices[devno]->get_acctime(devno,
+							   req,
+							   maxtime);
+}
+
+
+INLINE void device_bus_delay_complete (int devno, 
+				       ioreq_event *curr, 
+				       int sentbusno)
+{
+   ASSERT1 ((devno >= 0) && (devno < numdevices), "devno", devno);
+   return disksim->deviceinfo->devices[devno]->bus_delay_complete(devno,
+								  curr,
+								  sentbusno);
+}
+
+
+INLINE void device_bus_ownership_grant (int devno, 
+					ioreq_event *curr, 
+					int busno, 
+					double arbdelay)
+{
+   ASSERT1 ((devno >= 0) && (devno < numdevices), "devno", devno);
+   return disksim->deviceinfo->devices[devno]->bus_ownership_grant(devno,
+								   curr,
+								   busno,
+								   arbdelay);
+}
+
+/* dummy */
+void disksim_device_loadparams(void) {
+  ddbg_assert2(0, "this is a dummy that isn't supposed to be called");
+}
+
+
+int disksim_syncset_loadparams(struct lp_block *b)
+{
+
+  int c;
+    
+  unparse_block(b, outputfile);
+  for(c = 0; c < b->params_len; c++) {
+    if(!b->params[c]) continue;
+    if(PTYPE(b->params[c]) != S) continue;
+    if(strcmp(b->params[c]->name, "type")) continue;
+    else {
+      if(!strcmp(SVAL(b->params[c]), "simpledisk")) {
+	fprintf(stderr, "*** warning: no simpledisk syncsets\n");
+/*  	simpledisk_load_syncsets(b); */
+      }
+      else if(!strcmp(SVAL(b->params[c]), "disk")) {
+	return disk_load_syncsets(b);
+      }
+      else if(!strcmp(SVAL(b->params[c]), "mems")) {
+	fprintf(stderr, "*** warning: no mems syncsets\n");
+/*  	mems_load_syncsets(b); */
+      }
+      else {
+      }
+    }
+  }
+  return 1;
+}
+
+
+INLINE int dev_map_devno(int n)
+{ 
+  assert((n < numdevices) && (n >=0));
+  return devicenos[n];
+}
diff -uNr disksim-4.0/src/disksim_global.h disksim-4.0-x64/src/disksim_global.h
--- disksim-4.0/src/disksim_global.h	2016-03-23 20:10:28.894755949 +0800
+++ disksim-4.0-x64/src/disksim_global.h	2016-03-23 19:44:01.554679000 +0800
@@ -253,7 +253,7 @@
    int    temp;
 } foo;
 
-#define DISKSIM_EVENT_SIZE	128
+#define DISKSIM_EVENT_SIZE	200
 #define DISKSIM_EVENT_SPACESIZE	(DISKSIM_EVENT_SIZE - sizeof(struct foo))
 
 typedef struct ev {
diff -uNr disksim-4.0/src/disksim_global.h~ disksim-4.0-x64/src/disksim_global.h~
--- disksim-4.0/src/disksim_global.h~	1970-01-01 08:00:00.000000000 +0800
+++ disksim-4.0-x64/src/disksim_global.h~	2016-03-23 18:31:20.455809000 +0800
@@ -0,0 +1,512 @@
+/*
+ * DiskSim Storage Subsystem Simulation Environment (Version 4.0)
+ * Revision Authors: John Bucy, Greg Ganger
+ * Contributors: John Griffin, Jiri Schindler, Steve Schlosser
+ *
+ * Copyright (c) of Carnegie Mellon University, 2001-2008.
+ *
+ * This software is being provided by the copyright holders under the
+ * following license. By obtaining, using and/or copying this software,
+ * you agree that you have read, understood, and will comply with the
+ * following terms and conditions:
+ *
+ * Permission to reproduce, use, and prepare derivative works of this
+ * software is granted provided the copyright and "No Warranty" statements
+ * are included with all reproductions and derivative works and associated
+ * documentation. This software may also be redistributed without charge
+ * provided that the copyright and "No Warranty" statements are included
+ * in all redistributions.
+ *
+ * NO WARRANTY. THIS SOFTWARE IS FURNISHED ON AN "AS IS" BASIS.
+ * CARNEGIE MELLON UNIVERSITY MAKES NO WARRANTIES OF ANY KIND, EITHER
+ * EXPRESSED OR IMPLIED AS TO THE MATTER INCLUDING, BUT NOT LIMITED
+ * TO: WARRANTY OF FITNESS FOR PURPOSE OR MERCHANTABILITY, EXCLUSIVITY
+ * OF RESULTS OR RESULTS OBTAINED FROM USE OF THIS SOFTWARE. CARNEGIE
+ * MELLON UNIVERSITY DOES NOT MAKE ANY WARRANTY OF ANY KIND WITH RESPECT
+ * TO FREEDOM FROM PATENT, TRADEMARK, OR COPYRIGHT INFRINGEMENT.
+ * COPYRIGHT HOLDERS WILL BEAR NO LIABILITY FOR ANY USE OF THIS SOFTWARE
+ * OR DOCUMENTATION.
+ *
+ */
+
+
+
+/*
+ * DiskSim Storage Subsystem Simulation Environment (Version 2.0)
+ * Revision Authors: Greg Ganger
+ * Contributors: Ross Cohen, John Griffin, Steve Schlosser
+ *
+ * Copyright (c) of Carnegie Mellon University, 1999.
+ *
+ * Permission to reproduce, use, and prepare derivative works of
+ * this software for internal use is granted provided the copyright
+ * and "No Warranty" statements are included with all reproductions
+ * and derivative works. This software may also be redistributed
+ * without charge provided that the copyright and "No Warranty"
+ * statements are included in all redistributions.
+ *
+ * NO WARRANTY. THIS SOFTWARE IS FURNISHED ON AN "AS IS" BASIS.
+ * CARNEGIE MELLON UNIVERSITY MAKES NO WARRANTIES OF ANY KIND, EITHER
+ * EXPRESSED OR IMPLIED AS TO THE MATTER INCLUDING, BUT NOT LIMITED
+ * TO: WARRANTY OF FITNESS FOR PURPOSE OR MERCHANTABILITY, EXCLUSIVITY
+ * OF RESULTS OR RESULTS OBTAINED FROM USE OF THIS SOFTWARE. CARNEGIE
+ * MELLON UNIVERSITY DOES NOT MAKE ANY WARRANTY OF ANY KIND WITH RESPECT
+ * TO FREEDOM FROM PATENT, TRADEMARK, OR COPYRIGHT INFRINGEMENT.
+ */
+
+/*
+ * DiskSim Storage Subsystem Simulation Environment
+ * Authors: Greg Ganger, Bruce Worthington, Yale Patt
+ *
+ * Copyright (C) 1993, 1995, 1997 The Regents of the University of Michigan 
+ *
+ * This software is being provided by the copyright holders under the
+ * following license. By obtaining, using and/or copying this software,
+ * you agree that you have read, understood, and will comply with the
+ * following terms and conditions:
+ *
+ * Permission to use, copy, modify, distribute, and sell this software
+ * and its documentation for any purpose and without fee or royalty is
+ * hereby granted, provided that the full text of this NOTICE appears on
+ * ALL copies of the software and documentation or portions thereof,
+ * including modifications, that you make.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS," AND COPYRIGHT HOLDERS MAKE NO
+ * REPRESENTATIONS OR WARRANTIES, EXPRESS OR IMPLIED. BY WAY OF EXAMPLE,
+ * BUT NOT LIMITATION, COPYRIGHT HOLDERS MAKE NO REPRESENTATIONS OR
+ * WARRANTIES OF MERCHANTABILITY OR FITNESS FOR ANY PARTICULAR PURPOSE OR
+ * THAT THE USE OF THE SOFTWARE OR DOCUMENTATION WILL NOT INFRINGE ANY
+ * THIRD PARTY PATENTS, COPYRIGHTS, TRADEMARKS OR OTHER RIGHTS. COPYRIGHT
+ * HOLDERS WILL BEAR NO LIABILITY FOR ANY USE OF THIS SOFTWARE OR
+ * DOCUMENTATION.
+ *
+ *  This software is provided AS IS, WITHOUT REPRESENTATION FROM THE
+ * UNIVERSITY OF MICHIGAN AS TO ITS FITNESS FOR ANY PURPOSE, AND
+ * WITHOUT WARRANTY BY THE UNIVERSITY OF MICHIGAN OF ANY KIND, EITHER
+ * EXPRESSED OR IMPLIED, INCLUDING WITHOUT LIMITATION THE IMPLIED
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE REGENTS
+ * OF THE UNIVERSITY OF MICHIGAN SHALL NOT BE LIABLE FOR ANY DAMAGES,
+ * INCLUDING SPECIAL , INDIRECT, INCIDENTAL, OR CONSEQUENTIAL DAMAGES,
+ * WITH RESPECT TO ANY CLAIM ARISING OUT OF OR IN CONNECTION WITH THE
+ * USE OF OR IN CONNECTION WITH THE USE OF THE SOFTWARE, EVEN IF IT HAS
+ * BEEN OR IS HEREAFTER ADVISED OF THE POSSIBILITY OF SUCH DAMAGES
+ *
+ * The names and trademarks of copyright holders or authors may NOT be
+ * used in advertising or publicity pertaining to the software without
+ * specific, written prior permission. Title to copyright in this software
+ * and any associated documentation will at all times remain with copyright
+ * holders.
+ */
+
+#ifndef DISKSIM_GLOBAL_H
+#define DISKSIM_GLOBAL_H
+
+#include "disksim_rand48.h"
+#include "disksim_malloc.h"
+#include "disksim_bitstring.h"
+#include "inline.h"
+
+#include <sys/types.h>
+#include <stdio.h>
+
+#ifdef _WIN32
+#define u_int		unsigned int
+#define u_int64_t	unsigned __int64
+#endif
+
+/* must enable this on Suns and Alphas */
+#ifndef _WIN32
+#define u_int32_t	unsigned int
+#define int32_t		int
+#else
+#define u_int32_t       unsigned long
+#define int32_t         long
+#endif
+
+#ifndef _WIN32
+#define SUPPORT_CHECKPOINTS
+#endif
+
+#include <stdlib.h>
+#include <string.h>
+#include <math.h>
+#include <time.h>
+
+#define DISKSIM_time()		time(NULL)
+
+#ifndef MAXINT
+#define MAXINT	0x7FFFFFFF
+#endif
+
+#include "disksim_assertlib.h"
+
+#ifdef __cplusplus
+extern "C" {
+typedef      unsigned u_int;
+#endif
+
+#define ALLOCSIZE	8192
+
+#ifndef TRUE
+#define TRUE	1
+#endif
+#ifndef FALSE
+#define FALSE	0
+#endif
+
+#define BITS_PER_INT_MASK	0x0000001F
+#define INV_BITS_PER_INT_MASK	0xFFFFFFE0
+
+#define _BIG_ENDIAN	1
+#define _LITTLE_ENDIAN	2
+
+/* Trace Formats */
+
+#define ASCII		1
+#define HPL		2
+#define DEC		3
+#define VALIDATE	4
+#define RAW		5
+#define ATABUS          6
+#define IPEAK           7
+#define POSTGRES        8
+#define EMCSYMM         9
+#define EMCBACKEND      10
+#define BATCH           11
+#define DEFAULT		ASCII
+
+/* Time conversions */
+
+#define MILLI	1000
+#define MICRO	1000000
+#define NANO	1000000000
+
+#define SECONDS_PER_MINUTE	60
+#define SECONDS_PER_HOUR	3600
+#define SECONDS_PER_DAY		86400
+
+/* Flags components */
+
+#include "disksim_reqflags.h"
+
+#define WRITE		DISKSIM_WRITE		
+#define READ		DISKSIM_READ		
+#define TIME_CRITICAL	DISKSIM_TIME_CRITICAL	
+#define TIME_LIMITED	DISKSIM_TIME_LIMITED	
+#define TIMED_OUT	DISKSIM_TIMED_OUT	
+#define HALF_OUT	DISKSIM_HALF_OUT	
+#define MAPPED		DISKSIM_MAPPED		
+#define READ_AFTR_WRITE DISKSIM_READ_AFTR_WRITE 
+#define SYNCHRONOUS	DISKSIM_SYNC
+#define ASYNCHRONOUS	DISKSIM_ASYNC
+#define IO_FLAG_PAGEIO	DISKSIM_IO_FLAG_PAGEIO	
+#define SEQ		DISKSIM_SEQ		
+#define LOCAL           DISKSIM_LOCAL	     
+#define BATCH_COMPLETE  DISKSIM_BATCH_COMPLETE  
+
+/* Event Type Ranges */
+
+#define NULL_EVENT      	0
+#define PF_MIN_EVENT    	1
+#define PF_MAX_EVENT    	97
+#define INTR_EVENT		98
+#define INTEND_EVENT		99
+#define IO_MIN_EVENT		100
+#define IO_MAX_EVENT		120
+#define TIMER_EXPIRED		121
+#define CHECKPOINT		122
+#define STOP_SIM		123
+#define EXIT_DISKSIM		124
+#define MEMS_MIN_EVENT		200
+#define MEMS_MAX_EVENT		220
+#define SSD_MIN_EVENT		300
+#define SSD_MAX_EVENT		320
+
+/* Interrupt vector types */
+
+#define CLOCK_INTERRUPT		100
+#define SUBCLOCK_INTERRUPT	101
+#define IO_INTERRUPT    	102
+#define CPUSWAP_INTERRUPT    	103
+
+#define MSECS_PER_MIN		60000
+
+/* 
+   this threshold allows some difference between disksim's
+   internal time and simos' time.  it was determined by
+   trial and error and may require some adjustment.
+*/
+#define DISKSIM_TIME_THRESHOLD  0.0013
+
+typedef union {
+   u_int32_t	value;
+   char		byte[4];
+} intchar;
+
+#define StaticAssert(c) switch (c) case 0: case (c):
+
+typedef struct foo {
+   double time;
+   int type;
+   struct ev *next;
+   struct ev *prev;
+   int    temp;
+} foo;
+
+#define DISKSIM_EVENT_SIZE	128
+#define DISKSIM_EVENT_SPACESIZE	(DISKSIM_EVENT_SIZE - sizeof(struct foo))
+
+typedef struct ev {
+   double time;
+   int type;
+   struct ev *next;
+   struct ev *prev;
+   int    temp;
+   char space[DISKSIM_EVENT_SPACESIZE];
+} event;
+
+typedef struct ioreq_ev {
+   double time;
+   int    type;
+   struct ioreq_ev *next;
+   struct ioreq_ev *prev;
+   int    bcount;
+   int    blkno;
+   u_int  flags;
+   u_int  busno;
+   u_int  slotno;
+   int    devno;
+   int    opid;
+   void  *buf;
+   int    cause;
+   int    tempint1;
+   int    tempint2;
+   void  *tempptr1;
+   void  *tempptr2;
+   void  *mems_sled;	 /* mems sled associated with a particular event */
+   void  *mems_reqinfo; /* per-request info for mems subsystem */
+   int    ssd_elem_num;	 /* SSD: element to which this request went */
+   int    ssd_gang_num ; /* SSD: gang to which this request went */
+   double start_time;    /* temporary; used for memulator timing */
+   int    batchno;
+   int    batch_complete;
+   int    batch_size;
+   struct ioreq_ev *batch_next;
+   struct ioreq_ev *batch_prev;
+} ioreq_event;
+
+typedef struct timer_ev {
+   double time;
+   int type;
+   struct timer_ev *next;
+   struct timer_ev *prev;
+   void (**func)(struct timer_ev *);
+   int    val;
+   void  *ptr;
+} timer_event;
+
+typedef struct intr_ev {
+   double time;
+   int    type;
+   struct intr_ev * next;
+   struct intr_ev * prev;
+   int    vector;
+   int    oldstate;
+   int    flags;
+   event  *eventlist;
+   event  *infoptr;
+   double runtime;
+} intr_event;
+
+
+/* place-holding definitions for structure types; placed here because */
+/* some compilers can't handle them being inside other structure defs */
+
+struct cacheevent;
+struct ioq;
+struct iosim_info;
+struct device_info;
+struct disk_info;
+struct simpledisk_info;
+struct mems_info;
+struct iodriver_info;
+struct businfo;
+struct ctlrinfo;
+struct pf_info;
+struct synthio_info;
+struct iotrace_info;
+struct rand48_info;
+
+typedef event*(*disksim_iodone_notify_t)(ioreq_event *, void *ctx);
+
+typedef struct disksim {
+   void * startaddr;
+   int    totallength;
+   int    curroffset;
+   int    totalreqs;
+   int    closedios;
+   double closedthinktime;
+   int    warmup_iocnt;
+   double warmuptime;
+   timer_event *warmup_event;
+   double simtime;
+   int    checkpoint_disable;
+   int    checkpoint_iocnt;
+   double checkpoint_interval;
+   event *checkpoint_event;
+   int    traceformat;
+   int    endian;
+   int    traceendian;
+   int    traceheader;
+   int    iotrace;
+   int    synthgen;
+   int    external_control;
+
+   disksim_iodone_notify_t external_io_done_notify;
+   void *notify_ctx;
+
+   FILE * parfile;
+   FILE * iotracefile;
+   FILE * statdeffile;
+   FILE * outputfile;
+   FILE * outios;
+   char   iotracefilename[256];
+   char   outputfilename[256];
+   char   outiosfilename[256];
+   char   checkpointfilename[256];
+   fpos_t iotracefileposition;
+   fpos_t outputfileposition;
+   fpos_t outiosfileposition;
+   event *intq;
+   event *intqhint;
+   event *extraq;
+   int    intqlen;
+   int    extraqlen;
+   int    stop_sim;
+   int    seedval;
+   double lastphystime;
+
+/* call-back indirections for allowing checkpoint restores to deal with */
+/* functions whose addresses change on recompilation.                   */
+   void         (*issuefunc_ctlrsmart)     (void *, ioreq_event *);
+   struct ioq * (*queuefind_ctlrsmart)     (void *, int);
+   void         (*wakeupfunc_ctlrsmart)    (void *, struct cacheevent *);
+   void         (*donefunc_ctlrsmart_read) (void *, ioreq_event *);
+   void         (*donefunc_ctlrsmart_write)(void *, ioreq_event *);
+   void         (*donefunc_cachemem_empty) (void *, ioreq_event *);
+   void         (*donefunc_cachedev_empty) (void *, ioreq_event *);
+   void         (*idlework_cachemem)       (void *, int);
+   void         (*idlework_cachedev)       (void *, int);
+   int          (*concatok_cachemem)       (void *, int, int, int, int);
+   int          (*enablement_disk)         (ioreq_event *);
+   void         (*timerfunc_disksim)       (timer_event *);
+   void         (*timerfunc_ioqueue)       (timer_event *);
+   void         (*timerfunc_cachemem)      (timer_event *);
+   void         (*timerfunc_cachedev)      (timer_event *);
+
+/* opaque structures for different modules */
+   struct iosim_info *iosim_info;
+   struct device_info *deviceinfo;
+   struct disk_info *diskinfo;
+   struct simpledisk_info *simplediskinfo;
+   struct mems_info *memsinfo;
+   struct ssd_info *ssdinfo;  /* SSD: ssd specific plugin */
+   struct iodriver_info *iodriver_info;
+   struct businfo *businfo;
+   struct ctlrinfo *ctlrinfo;
+   struct pf_info *pf_info;
+   struct synthio_info *synthio_info;
+   struct iotrace_info *iotrace_info;
+   struct rand48_info *rand48_info;
+
+   char **overrides;
+   int overrides_len;
+   int verbosity;
+
+  int tracepipes[2];
+  enum { DISKSIM_MASTER, DISKSIM_SLAVE, DISKSIM_NONE } trace_mode;
+
+  FILE *exectrace;
+  char *exectrace_fn;
+
+} disksim_t;
+
+extern disksim_t *disksim;
+
+/* remapping #defines for some of the variables in disksim_t */
+#define warmuptime       (disksim->warmuptime)
+#define simtime	         (disksim->simtime)
+#define statdeffile      (disksim->statdeffile)
+#define outputfile       (disksim->outputfile)
+#define outios           (disksim->outios)
+
+
+#ifndef _WIN32
+#define	min(x,y)	((x) < (y) ? (x) : (y))
+
+#define	max(x,y)	((x) < (y) ? (y) : (x))
+#endif
+
+#define	wrap(x,y)	((y) < (x) ? 1 : 0)
+
+#define diff(x,y)	((x) < (y) ? (y)-(x) : (x)-(y))
+
+#define rounduptomult(val,mult)	((val) + ((mult) - (((val)-1) % (mult))) - 1)
+
+/* translate from the deprecated but convenient bzero function to memset */
+#define bzero(ptr,size)  memset(ptr,0,size)
+
+
+/* Global disksim_intr.c functions */
+
+void intr_request(event *curr);
+void intr_acknowledge (event *intrp);
+
+
+/* Global disksim.c functions */
+
+void resetstats (void);
+void disksim_simstop (void);
+void disksim_register_checkpoint (double atsimtime);
+INLINE void addtoextraq (event *temp);
+void addlisttoextraq (event **headptr);
+INLINE event * getfromextraq (void);
+event * event_copy (event *orig);
+INLINE void addtointq (event *temp);
+INLINE int removefromintq (event *curr);
+void scanparam_int (char *parline, char *parname, int *parptr, int parchecks, int parminval, int parmaxval);
+void getparam_int (FILE *parfile, char *parname, int *parptr, int parchecks, int parminval, int parmaxval);
+void getparam_double (FILE *parfile, char *parname, double *parptr, int parchecks, double parminval, double parmaxval);
+void getparam_bool (FILE *parfile, char *parname, int *parptr);
+event * io_done_notify (ioreq_event *curr);
+
+
+/* disksim.c functions used for external control */
+
+
+
+int disksim_initialize_disksim_structure (struct disksim *);
+int disksim_loadparams(char *inputfile, int synthgen);
+void disksim_setup_disksim (int argc, char **argv);
+void disksim_set_external_io_done_notify (disksim_iodone_notify_t);
+void disksim_cleanup_and_printstats (void);
+void disksim_cleanstats (void);
+void disksim_printstats2 (void);
+void disksim_simulate_event (int);
+void disksim_restore_from_checkpoint (char *filename);
+void disksim_run_simulation ();
+
+void disksim_printstats(void);
+
+// destructor
+void disksim_cleanup(void);
+
+void disksim_exectrace(char *fmt,...);
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif  /* DISKSIM_GLOBAL_H */
+
diff -uNr disksim-4.0/src/disksim_iosim.c disksim-4.0-x64/src/disksim_iosim.c
--- disksim-4.0/src/disksim_iosim.c	2016-03-23 20:10:28.894755949 +0800
+++ disksim-4.0-x64/src/disksim_iosim.c	2016-03-23 19:44:45.982682000 +0800
@@ -356,7 +356,7 @@
 
 
 
-static int iosim_load_map(struct lp_block *b, int n) {
+static int iosim_load_map(struct lp_block *b, int64_t n) {
   int c;
   int i = 0;
   char *s = 0; 
diff -uNr disksim-4.0/src/disksim_iosim.c~ disksim-4.0-x64/src/disksim_iosim.c~
--- disksim-4.0/src/disksim_iosim.c~	1970-01-01 08:00:00.000000000 +0800
+++ disksim-4.0-x64/src/disksim_iosim.c~	2016-03-23 18:31:20.455809000 +0800
@@ -0,0 +1,738 @@
+/*
+ * DiskSim Storage Subsystem Simulation Environment (Version 4.0)
+ * Revision Authors: John Bucy, Greg Ganger
+ * Contributors: John Griffin, Jiri Schindler, Steve Schlosser
+ *
+ * Copyright (c) of Carnegie Mellon University, 2001-2008.
+ *
+ * This software is being provided by the copyright holders under the
+ * following license. By obtaining, using and/or copying this software,
+ * you agree that you have read, understood, and will comply with the
+ * following terms and conditions:
+ *
+ * Permission to reproduce, use, and prepare derivative works of this
+ * software is granted provided the copyright and "No Warranty" statements
+ * are included with all reproductions and derivative works and associated
+ * documentation. This software may also be redistributed without charge
+ * provided that the copyright and "No Warranty" statements are included
+ * in all redistributions.
+ *
+ * NO WARRANTY. THIS SOFTWARE IS FURNISHED ON AN "AS IS" BASIS.
+ * CARNEGIE MELLON UNIVERSITY MAKES NO WARRANTIES OF ANY KIND, EITHER
+ * EXPRESSED OR IMPLIED AS TO THE MATTER INCLUDING, BUT NOT LIMITED
+ * TO: WARRANTY OF FITNESS FOR PURPOSE OR MERCHANTABILITY, EXCLUSIVITY
+ * OF RESULTS OR RESULTS OBTAINED FROM USE OF THIS SOFTWARE. CARNEGIE
+ * MELLON UNIVERSITY DOES NOT MAKE ANY WARRANTY OF ANY KIND WITH RESPECT
+ * TO FREEDOM FROM PATENT, TRADEMARK, OR COPYRIGHT INFRINGEMENT.
+ * COPYRIGHT HOLDERS WILL BEAR NO LIABILITY FOR ANY USE OF THIS SOFTWARE
+ * OR DOCUMENTATION.
+ *
+ */
+
+
+
+/*
+ * DiskSim Storage Subsystem Simulation Environment (Version 2.0)
+ * Revision Authors: Greg Ganger
+ * Contributors: Ross Cohen, John Griffin, Steve Schlosser
+ *
+ * Copyright (c) of Carnegie Mellon University, 1999.
+ *
+ * Permission to reproduce, use, and prepare derivative works of
+ * this software for internal use is granted provided the copyright
+ * and "No Warranty" statements are included with all reproductions
+ * and derivative works. This software may also be redistributed
+ * without charge provided that the copyright and "No Warranty"
+ * statements are included in all redistributions.
+ *
+ * NO WARRANTY. THIS SOFTWARE IS FURNISHED ON AN "AS IS" BASIS.
+ * CARNEGIE MELLON UNIVERSITY MAKES NO WARRANTIES OF ANY KIND, EITHER
+ * EXPRESSED OR IMPLIED AS TO THE MATTER INCLUDING, BUT NOT LIMITED
+ * TO: WARRANTY OF FITNESS FOR PURPOSE OR MERCHANTABILITY, EXCLUSIVITY
+ * OF RESULTS OR RESULTS OBTAINED FROM USE OF THIS SOFTWARE. CARNEGIE
+ * MELLON UNIVERSITY DOES NOT MAKE ANY WARRANTY OF ANY KIND WITH RESPECT
+ * TO FREEDOM FROM PATENT, TRADEMARK, OR COPYRIGHT INFRINGEMENT.
+ */
+
+/*
+ * DiskSim Storage Subsystem Simulation Environment
+ * Authors: Greg Ganger, Bruce Worthington, Yale Patt
+ *
+ * Copyright (C) 1993, 1995, 1997 The Regents of the University of Michigan 
+ *
+ * This software is being provided by the copyright holders under the
+ * following license. By obtaining, using and/or copying this software,
+ * you agree that you have read, understood, and will comply with the
+ * following terms and conditions:
+ *
+ * Permission to use, copy, modify, distribute, and sell this software
+ * and its documentation for any purpose and without fee or royalty is
+ * hereby granted, provided that the full text of this NOTICE appears on
+ * ALL copies of the software and documentation or portions thereof,
+ * including modifications, that you make.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS," AND COPYRIGHT HOLDERS MAKE NO
+ * REPRESENTATIONS OR WARRANTIES, EXPRESS OR IMPLIED. BY WAY OF EXAMPLE,
+ * BUT NOT LIMITATION, COPYRIGHT HOLDERS MAKE NO REPRESENTATIONS OR
+ * WARRANTIES OF MERCHANTABILITY OR FITNESS FOR ANY PARTICULAR PURPOSE OR
+ * THAT THE USE OF THE SOFTWARE OR DOCUMENTATION WILL NOT INFRINGE ANY
+ * THIRD PARTY PATENTS, COPYRIGHTS, TRADEMARKS OR OTHER RIGHTS. COPYRIGHT
+ * HOLDERS WILL BEAR NO LIABILITY FOR ANY USE OF THIS SOFTWARE OR
+ * DOCUMENTATION.
+ *
+ *  This software is provided AS IS, WITHOUT REPRESENTATION FROM THE
+ * UNIVERSITY OF MICHIGAN AS TO ITS FITNESS FOR ANY PURPOSE, AND
+ * WITHOUT WARRANTY BY THE UNIVERSITY OF MICHIGAN OF ANY KIND, EITHER
+ * EXPRESSED OR IMPLIED, INCLUDING WITHOUT LIMITATION THE IMPLIED
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE REGENTS
+ * OF THE UNIVERSITY OF MICHIGAN SHALL NOT BE LIABLE FOR ANY DAMAGES,
+ * INCLUDING SPECIAL , INDIRECT, INCIDENTAL, OR CONSEQUENTIAL DAMAGES,
+ * WITH RESPECT TO ANY CLAIM ARISING OUT OF OR IN CONNECTION WITH THE
+ * USE OF OR IN CONNECTION WITH THE USE OF THE SOFTWARE, EVEN IF IT HAS
+ * BEEN OR IS HEREAFTER ADVISED OF THE POSSIBILITY OF SUCH DAMAGES
+ *
+ * The names and trademarks of copyright holders or authors may NOT be
+ * used in advertising or publicity pertaining to the software without
+ * specific, written prior permission. Title to copyright in this software
+ * and any associated documentation will at all times remain with copyright
+ * holders.
+ */
+
+
+#include "disksim_iosim.h"
+
+#include "modules/modules.h"
+
+
+
+
+
+void iosim_initialize_iosim_info (void)
+{
+   disksim->iosim_info = DISKSIM_malloc (sizeof(iosim_info_t));
+   bzero ((char *)disksim->iosim_info, sizeof(iosim_info_t));
+
+   /* initializations that get remapped into iosim_info */
+   ioscale = 1.0;
+   last_request_arrive = 0.0;
+   constintarrtime = 0.0;
+}
+
+
+ioreq_event * ioreq_copy (ioreq_event *old)
+{
+   ioreq_event *new = (ioreq_event *) getfromextraq();
+   memmove ((char *)new, (char *)old, sizeof(ioreq_event));
+   /* bcopy ((char *)old, (char *)new, sizeof (ioreq_event)); */
+   return(new);
+}
+
+
+int ioreq_compare (ioreq_event *first, ioreq_event *second)
+{
+   int diff = 0;
+   diff |= first->time != second->time;
+   diff |= first->type != second->type;
+   //diff |= first->next != second->next;
+   //diff |= first->prev != second->prev;
+   diff |= first->bcount != second->bcount;
+   diff |= first->blkno != second->blkno;
+   diff |= first->flags != second->flags;
+   diff |= first->busno != second->busno;
+   diff |= first->slotno != second->slotno;
+   diff |= first->devno != second->devno;
+   diff |= first->opid != second->opid;
+   diff |= first->buf != second->buf;
+   diff |= first->cause != second->cause;
+   diff |= first->tempint1 != second->tempint1;
+   diff |= first->tempint2 != second->tempint2;
+   diff |= first->tempptr1 != second->tempptr1;
+   diff |= first->tempptr2 != second->tempptr2;
+   return(diff);
+}
+
+
+void io_catch_stray_events (ioreq_event *curr)
+{
+   switch (curr->type) {
+   case DEVICE_DATA_TRANSFER_COMPLETE:
+     curr->time = device_get_blktranstime(curr);
+     curr->time = simtime + (curr->time * (double) curr->bcount);
+     addtointq((event *) curr);
+     break;
+     
+   default:
+     fprintf(stderr, "Unknown event type at io_catch_stray_events\n");
+     exit(1);
+   }
+}
+
+
+event * io_request (ioreq_event *curr)
+{
+   curr->type = IO_REQUEST_ARRIVE;
+   return (iodriver_request(0, curr));
+}
+
+
+void io_schedule (ioreq_event *curr)
+{
+   curr->type = IO_ACCESS_ARRIVE;
+   iodriver_schedule(0, curr);
+}
+
+
+double io_tick()
+{
+   return (iodriver_tick());
+}
+
+
+double io_raise_priority (int opid, int devno, int blkno, void *chan)
+{
+   return (iodriver_raise_priority(0, opid, devno, blkno, chan));
+}
+
+
+void io_interrupt_arrive (ioreq_event *intrp)
+{
+   intrp->type = IO_INTERRUPT_ARRIVE;
+   iodriver_interrupt_arrive (0, (intr_event *)intrp);
+}
+
+
+void io_interrupt_complete (ioreq_event *intrp)
+{
+   intrp->type = IO_INTERRUPT_COMPLETE;
+   iodriver_interrupt_complete (0, (intr_event *)intrp);
+}
+
+
+void io_internal_event(ioreq_event *curr)
+{
+   ASSERT(curr != NULL);
+/*
+fprintf (outputfile, "%f: io_internal_event entered with event type %d, %f\n", curr->time, curr->type, simtime);
+*/
+   switch (curr->type) {
+   case IO_REQUEST_ARRIVE:
+     iodriver_request(0, curr);
+     break;
+     
+   case IO_ACCESS_ARRIVE:
+     iodriver_schedule(0, curr);
+     break;
+     
+   case IO_INTERRUPT_ARRIVE:
+     iodriver_interrupt_arrive(0, (intr_event *) curr);
+     break;
+
+   case IO_RESPOND_TO_DEVICE:
+     iodriver_respond_to_device(0, (intr_event *) curr->tempptr1);
+     addtoextraq((event *) curr);
+     break;
+     
+   case IO_ACCESS_COMPLETE:
+     iodriver_access_complete(0, (intr_event *) curr->tempptr1);
+     addtoextraq((event *) curr);
+     break;
+     
+   case IO_INTERRUPT_COMPLETE:
+     iodriver_interrupt_complete(0, (intr_event *) curr);
+     break;
+
+   case DEVICE_OVERHEAD_COMPLETE:
+   case DEVICE_ACCESS_COMPLETE:
+   case DEVICE_DATA_TRANSFER_COMPLETE:
+   case DEVICE_PREPARE_FOR_DATA_TRANSFER:
+   case DEVICE_BUFFER_SEEKDONE:
+   case DEVICE_BUFFER_TRACKACC_DONE:
+   case DEVICE_BUFFER_SECTOR_DONE:
+   case DEVICE_GOT_REMAPPED_SECTOR:
+   case DEVICE_GOTO_REMAPPED_SECTOR:
+   case MEMS_SLED_SCHEDULE:
+   case MEMS_SLED_SEEK:
+   case MEMS_SLED_SERVO:
+   case MEMS_SLED_DATA:
+   case MEMS_SLED_UPDATE:
+   case MEMS_BUS_INITIATE:
+   case MEMS_BUS_TRANSFER:
+   case MEMS_BUS_UPDATE:
+   case SSD_CLEAN_ELEMENT:
+   case SSD_CLEAN_GANG:
+     device_event_arrive(curr);
+     break;
+
+   case BUS_OWNERSHIP_GRANTED:
+   case BUS_DELAY_COMPLETE:
+     bus_event_arrive(curr);
+     break;
+
+   case CONTROLLER_DATA_TRANSFER_COMPLETE:
+     controller_event_arrive(curr->tempint2, curr);
+     break;
+
+   case TIMESTAMP_LOGORG:
+     logorg_timestamp(curr);
+     break;
+
+   case IO_TRACE_REQUEST_START:
+     iodriver_trace_request_start(0, curr);
+     break;
+
+   default:
+     fprintf(stderr, "Unknown event type passed to io_internal_events\n");
+     exit(1);
+   }
+   /*
+     fprintf (outputfile, "Leaving io_internal_event\n");
+   */
+}
+
+
+void iosim_get_path_to_controller (int iodriverno, int ctlno, intchar *buspath, intchar *slotpath)
+{
+   int depth;
+   int currbus;
+   char inslotno;
+   char outslotno;
+   int master;
+
+   depth = controller_get_depth(ctlno);
+   currbus = controller_get_inbus(ctlno);
+   inslotno = (char) controller_get_slotno(ctlno);
+   master = controller_get_bus_master(currbus);
+   while (depth > 0) {
+/*
+fprintf (outputfile, "ctlno %d, depth %d, currbus %d, inslotno %d, master %d\n", ctl->ctlno, depth, currbus, inslotno, master);
+*/
+      outslotno = (char) controller_get_outslot(master, currbus);
+      buspath->byte[depth] = (char) currbus;
+      slotpath->byte[depth] = (inslotno & 0x0F) | (outslotno << 4);
+      depth--;
+      currbus = controller_get_inbus(master);
+      inslotno = (char) controller_get_slotno(master);
+      master = controller_get_bus_master(currbus);
+          /* Bus must have at least one controller */
+      ASSERT1((master != -1) || (depth <= 0), "currbus", currbus);
+   }
+   outslotno = (char) iodriverno;
+   buspath->byte[depth] = currbus;
+   slotpath->byte[depth] = (inslotno & 0x0F) | (outslotno << 4);
+}
+
+
+void iosim_get_path_to_device (int iodriverno, int devno, intchar *buspath, intchar *slotpath)
+{
+   int depth;
+   int currbus;
+   char inslotno;
+   char outslotno;
+   int master;
+
+   depth = device_get_depth(devno);
+   currbus = device_get_inbus(devno);
+   inslotno = (char) device_get_slotno(devno);
+   master = controller_get_bus_master(currbus);
+   while (depth > 0) {
+/*
+fprintf (outputfile, "devno %d, depth %d, currbus %d, inslotno %d, master %d\n", devno, depth, currbus, inslotno, master);
+*/
+      outslotno = (char) controller_get_outslot(master, currbus);
+      buspath->byte[depth] = (char) currbus;
+      slotpath->byte[depth] = (inslotno & 0x0F) | (outslotno << 4);
+      depth--;
+      currbus = controller_get_inbus(master);
+      inslotno = (char) controller_get_slotno(master);
+      master = controller_get_bus_master(currbus);
+          /* Bus must have at least one controller */
+      ASSERT1((master != -1) || (depth <= 0), "currbus", currbus);
+   }
+   outslotno = (char) iodriverno;
+   buspath->byte[depth] = currbus;
+   slotpath->byte[depth] = (inslotno & 0x0F) | (outslotno << 4);
+}
+
+
+
+
+static int iosim_load_map(struct lp_block *b, int n) {
+  int c;
+  int i = 0;
+  char *s = 0; 
+
+
+  //#include "modules/disksim_iomap_param.c"
+  lp_loadparams((void *)n, b, &disksim_iomap_mod);
+
+  if (tracemap2[n] == 512) {
+    tracemap2[n] = 0;
+  } 
+  else if (tracemap2[n] > 512) {
+    tracemap2[n] = -(tracemap2[n] / 512);
+  } 
+  else {
+    tracemap2[n] = 512 / tracemap2[n];
+  }
+  
+
+  return 1;
+}
+
+int iosim_load_mappings(struct lp_list *l) {
+  int c; 
+  int mapno = 0;
+
+  if(l->values_len > TRACEMAPPINGS) {
+    fprintf(stderr, "*** error: too many io mappings.\n");
+    return -1;
+  }
+
+  for(c = 0; c < l->values_len; c++) {
+    if(!l->values[c]) continue;
+
+    if(l->values[c]->t == BLOCK) {
+      assert(iosim_load_map(l->values[c]->v.b, mapno));
+      tracemappings++;
+    }
+
+    mapno++;
+  }
+
+  return 1;
+}
+
+int disksim_iomap_loadparams(struct lp_block *b) { 
+  ddbg_assert2(0, "this is a dummy and isn't supposed to be called");
+  return 0;
+}
+
+
+int disksim_iosim_loadparams(struct lp_block *b) {
+
+  if(!disksim->iosim_info) 
+    iosim_initialize_iosim_info();
+
+  //#include "modules/disksim_iosim_param.c"
+  lp_loadparams(0, b, &disksim_iosim_mod);
+
+
+  return 1;
+}
+
+
+
+
+
+/* OBSELETE */
+void io_readparams (FILE *parfile)
+{
+  ddbg_assert(0);
+/*     fscanf(parfile, "\nI/O Subsystem Input Parameters\n"); */
+/*     fprintf(outputfile, "\nI/O Subsystem Input Parameters\n"); */
+/*     fscanf(parfile, "------------------------------\n"); */
+/*     fprintf(outputfile, "------------------------------\n"); */
+
+/*     fscanf(parfile, "\nPRINTED I/O SUBSYSTEM STATISTICS\n\n"); */
+/*     fprintf(outputfile, "\nPRINTED I/O SUBSYSTEM STATISTICS\n\n"); */
+
+/*     iodriver_read_toprints(parfile); */
+/*     bus_read_toprints(parfile); */
+/*     controller_read_toprints(parfile); */
+/*     device_read_toprints(parfile); */
+
+/*     fscanf(parfile, "\nGENERAL I/O SUBSYSTEM PARAMETERS\n\n"); */
+/*     fprintf(outputfile, "\nGENERAL I/O SUBSYSTEM PARAMETERS\n\n"); */
+
+/*     io_read_generalparms(parfile); */
+
+/*     fscanf(parfile, "\nCOMPONENT SPECIFICATIONS\n"); */
+/*     fprintf(outputfile, "\nCOMPONENT SPECIFICATIONS\n"); */
+
+/*     iodriver_read_specs(parfile); */
+/*     bus_read_specs(parfile); */
+/*     controller_read_specs(parfile); */
+/*     device_read_specs(parfile); */
+
+/*     fscanf(parfile, "\nPHYSICAL ORGANIZATION\n"); */
+/*     fprintf(outputfile, "\nPHYSICAL ORGANIZATION\n"); */
+
+/*     iodriver_read_physorg(parfile); */
+/*     controller_read_physorg(parfile); */
+/*     bus_read_physorg(parfile); */
+
+/*     fscanf(parfile, "\nSYNCHRONIZATION\n"); */
+/*     fprintf(outputfile, "\nSYNCHRONIZATION\n"); */
+
+/*     device_read_syncsets(parfile); */
+
+/*     fscanf(parfile, "\nLOGICAL ORGANIZATION\n"); */
+/*     fprintf(outputfile, "\nLOGICAL ORGANIZATION\n"); */
+
+/*     iodriver_read_logorg(parfile); */
+/*     controller_read_logorg(parfile); */
+/*
+   bus_print_phys_config();
+*/
+}
+
+
+void io_validate_do_stats1 ()
+{
+   int i;
+
+   if (tracestats2 == NULL) {
+      tracestats2 = (statgen *)DISKSIM_malloc(sizeof(statgen));
+      tracestats3 = (statgen *)DISKSIM_malloc(sizeof(statgen));
+      tracestats4 = (statgen *)DISKSIM_malloc(sizeof(statgen));
+      tracestats5 = (statgen *)DISKSIM_malloc(sizeof(statgen));
+
+      stat_initialize(statdeffile, statdesc_traceaccstats, tracestats2);
+      stat_initialize(statdeffile, statdesc_traceaccdiffstats, tracestats3);
+      stat_initialize(statdeffile, statdesc_traceaccwritestats, tracestats4);
+      stat_initialize(statdeffile, statdesc_traceaccdiffwritestats, tracestats5);
+      for (i=0; i<10; i++) {
+	 validatebuf[i] = 0;
+      }
+   } else {
+      stat_update(tracestats3, (validate_lastserv - disksim->lastphystime));
+      if (!validate_lastread) {
+         stat_update(tracestats5, (validate_lastserv - disksim->lastphystime));
+      }
+   }
+}
+
+
+void io_validate_do_stats2 (ioreq_event *new)
+{
+   stat_update(tracestats2, validate_lastserv);
+   if (new->flags == WRITE) {
+      stat_update(tracestats4, validate_lastserv);
+   }
+   if (strcmp(validate_buffaction, "Doub") == 0) {
+      validatebuf[0]++;
+   } else if (strcmp(validate_buffaction, "Trip") == 0) {
+      validatebuf[1]++;
+   } else if (strcmp(validate_buffaction, "Miss") == 0) {
+      validatebuf[2]++;
+   } else if (strcmp(validate_buffaction, "Hit") == 0) {
+      validatebuf[3]++;
+   } else {
+      fprintf(stderr, "Unrecognized buffaction in validate trace: %s\n", validate_buffaction);
+      exit(1);
+   }
+}
+
+
+static void io_hpl_do_stats1 ()
+{
+   int i;
+
+   if (tracestats == NULL) {
+      tracestats  = (statgen *)DISKSIM_malloc(tracemappings * sizeof(statgen));
+      tracestats1 = (statgen *)DISKSIM_malloc(tracemappings * sizeof(statgen));
+      tracestats2 = (statgen *)DISKSIM_malloc(tracemappings * sizeof(statgen));
+      tracestats3 = (statgen *)DISKSIM_malloc(tracemappings * sizeof(statgen));
+      tracestats4 = (statgen *)DISKSIM_malloc(tracemappings * sizeof(statgen));
+
+      for (i=0; i<tracemappings; i++) {
+         stat_initialize(statdeffile, statdesc_tracequeuestats, &tracestats[i]);
+         stat_initialize(statdeffile, statdesc_tracerespstats, &tracestats1[i]);
+         stat_initialize(statdeffile, statdesc_traceaccstats, &tracestats2[i]);
+         stat_initialize(statdeffile, statdesc_traceqlenstats, &tracestats3[i]);
+         stat_initialize(statdeffile, statdesc_tracenoqstats, &tracestats4[i]);
+      }
+   }
+}
+
+
+void io_map_trace_request (ioreq_event *temp)
+{
+   int i;
+
+   for (i=0; i<tracemappings; i++) {
+      if (temp->devno == tracemap[i]) {
+	 temp->devno = tracemap1[i];
+	 if (tracemap2[i]) {
+	    if (tracemap2[i] < 1) {
+	       temp->blkno *= -tracemap2[i];
+	    } else {
+	       if (temp->blkno % tracemap2[i]) {
+	          fprintf(stderr, "Small sector size disk using odd sector number: %d\n", temp->blkno);
+	          exit(1);
+	       }
+/*
+	       fprintf (outputfile, "mapping block number %d to %d\n", temp->blkno, (temp->blkno / tracemap2[i]));
+*/
+	       temp->blkno /= tracemap2[i];
+	    }
+	 }
+	 temp->bcount *= tracemap3[i];
+	 temp->blkno += tracemap4[i];
+	 if (tracestats) {
+	    stat_update(&tracestats[i], ((double) temp->tempint1 / (double) 1000));
+	    stat_update(&tracestats1[i],((double) (temp->tempint1 + temp->tempint2) / (double) 1000));
+	    stat_update(&tracestats2[i],((double) temp->tempint2 / (double) 1000));
+	    stat_update(&tracestats3[i], (double) temp->slotno);
+	    if (temp->slotno == 1) {
+	       stat_update(&tracestats4[i], ((double) temp->tempint1 / (double) 1000));
+	    }
+	 }
+	 return;
+      }
+   }
+/*
+   fprintf(stderr, "Requested device not mapped - %x\n", temp->devno);
+   exit(1);
+*/
+}
+
+
+event * io_get_next_external_event (FILE *iotracefile)
+{
+   ioreq_event *temp;
+
+   ASSERT(io_extq == NULL);
+
+   //fprintf (outputfile, "Near beginning of io_get_next_external_event\n");
+
+   temp = (ioreq_event *) getfromextraq();
+
+   switch (disksim->traceformat) {
+      case VALIDATE: io_validate_do_stats1();
+		     break;
+      case HPL: io_hpl_do_stats1();
+                break;
+   }
+
+   temp = iotrace_get_ioreq_event(iotracefile, disksim->traceformat, temp);
+   if (temp) {
+      switch (disksim->traceformat) {
+         case VALIDATE: io_validate_do_stats2 (temp);
+		        break;
+      }
+      temp->type = IO_REQUEST_ARRIVE;
+      if (constintarrtime > 0.0) {
+	 temp->time = last_request_arrive + constintarrtime;
+	 last_request_arrive = temp->time;
+      }
+      temp->time = (temp->time * ioscale) + tracebasetime;
+      if ((temp->time < simtime) && (!disksim->closedios)) {
+         fprintf(stderr, "Trace event appears out of time order in trace - simtime %f, time %f\n", simtime, temp->time);
+	 fprintf(stderr, "ioscale %f, tracebasetime %f\n", ioscale, tracebasetime);
+	 fprintf(stderr, "devno %d, blkno %d, bcount %d, flags %d\n", temp->devno, temp->blkno, temp->bcount, temp->flags);
+         exit(1);
+      }
+      if (tracemappings) {
+         io_map_trace_request(temp);
+      }
+      io_extq = (event *)temp;
+      io_extq_type = temp->type;
+   }
+/*
+fprintf (outputfile, "leaving io_get_next_external_event\n");
+*/
+   return ((event *)temp);
+}
+
+
+int io_using_external_event (event *curr)
+{
+   if (io_extq == curr) {
+      curr->type = io_extq_type;
+      io_extq = NULL;
+      return(1);
+   }
+   return(0);
+}
+
+
+void io_printstats()
+{
+   int i;
+   int cnt = 0;
+   char prefix[80];
+
+   fprintf (outputfile, "\nSTORAGE SUBSYSTEM STATISTICS\n");
+   fprintf (outputfile, "----------------------------\n");
+
+   iotrace_printstats (outputfile);
+
+   if ((tracestats) && (PRINTTRACESTATS)) {
+      /* info relevant to HPL traces */
+      for (i=0; i<tracemappings; i++) {
+         sprintf(prefix, "Mapped disk #%d ", i);
+         stat_print(&tracestats[i], prefix);
+         stat_print(&tracestats1[i], prefix);
+         stat_print(&tracestats2[i], prefix);
+         stat_print(&tracestats3[i], prefix);
+         stat_print(&tracestats4[i], prefix);
+      }
+   } else if ((tracestats2) && (PRINTTRACESTATS)) {
+      /* info to help with validation */
+      fprintf (outputfile, "\n");
+      stat_print(tracestats2, "VALIDATE ");
+      stat_print(tracestats3, "VALIDATE ");
+      stat_print(tracestats4, "VALIDATE ");
+      stat_print(tracestats5, "VALIDATE ");
+      for (i=0; i<10; i++) {
+	 cnt += validatebuf[i];
+      }
+      fprintf (outputfile, "VALIDATE double disconnects:  %5d  \t%f\n", validatebuf[0], ((double) validatebuf[0] / (double) cnt));
+      fprintf (outputfile, "VALIDATE triple disconnects:  %5d  \t%f\n", validatebuf[1], ((double) validatebuf[1] / (double) cnt));
+      fprintf (outputfile, "VALIDATE read buffer hits:    %5d  \t%f\n", validatebuf[3], ((double) validatebuf[3] / (double) cnt));
+      fprintf (outputfile, "VALIDATE buffer misses:       %5d  \t%f\n", validatebuf[2], ((double) validatebuf[2] / (double) cnt));
+   }
+
+   iodriver_printstats();
+   device_printstats();
+   controller_printstats();
+   bus_printstats();
+}
+
+
+
+
+void io_setcallbacks ()
+{
+   device_setcallbacks ();
+   bus_setcallbacks ();
+   controller_setcallbacks ();
+   iodriver_setcallbacks ();
+}
+
+
+void io_initialize (int standalone)
+{
+   if (disksim->iosim_info == NULL) {
+      iosim_initialize_iosim_info ();
+   }
+
+   bus_set_depths();
+   // fprintf (outputfile, "Back from bus_set_depths\n");
+
+   StaticAssert (sizeof(ioreq_event) <= DISKSIM_EVENT_SIZE);
+   device_initialize();
+   bus_initialize();
+   controller_initialize();
+   iodriver_initialize(standalone);
+}
+
+
+void io_resetstats()
+{
+   iodriver_resetstats();
+   device_resetstats();
+   bus_resetstats();
+   controller_resetstats();
+}
+
+
+void io_cleanstats()
+{
+   iodriver_cleanstats();
+   device_cleanstats();
+   bus_cleanstats();
+   controller_cleanstats();
+}
+
diff -uNr disksim-4.0/src/Makefile disksim-4.0-x64/src/Makefile
--- disksim-4.0/src/Makefile	2016-03-23 20:12:14.742761020 +0800
+++ disksim-4.0-x64/src/Makefile	2016-03-23 20:01:42.670730000 +0800
@@ -120,7 +120,7 @@
 	$(CC) $< -o $@
 
 libdisksim.a: $(MODULEDEPS) $(DISKSIM_OBJ) disksim_interface.o
-	ar cru $@ $(DISKSIM_OBJ) disksim_interface.o modules/*.o
+	ar crus $@ $(DISKSIM_OBJ) disksim_interface.o modules/*.o
 	ranlib $@
 	mkdir -p ../lib
 	cp libdisksim.a ../lib
diff -uNr disksim-4.0/src/Makefile~ disksim-4.0-x64/src/Makefile~
--- disksim-4.0/src/Makefile~	2016-03-23 20:12:14.742761020 +0800
+++ disksim-4.0-x64/src/Makefile~	2016-03-23 20:01:41.478730000 +0800
@@ -120,7 +120,7 @@
 	$(CC) $< -o $@
 
 libdisksim.a: $(MODULEDEPS) $(DISKSIM_OBJ) disksim_interface.o
-	ar cru $@ $(DISKSIM_OBJ) disksim_interface.o modules/*.o
+	ar crus $@ $(DISKSIM_OBJ) disksim_interface.o modules/*.o
 	ranlib $@
 	mkdir -p ../lib
 	cp libdisksim.a ../lib
diff -uNr disksim-4.0/ssdmodel/ssd.h disksim-4.0-x64/ssdmodel/ssd.h
--- disksim-4.0/ssdmodel/ssd.h	2008-08-14 19:05:52.000000000 +0800
+++ disksim-4.0-x64/ssdmodel/ssd.h	2016-03-23 19:46:06.294685000 +0800
@@ -1,5 +1,5 @@
 // DiskSim SSD support
-// 2008 Microsoft Corporation. All Rights Reserved
+// \A92008 Microsoft Corporation. All Rights Reserved
 
 #include "disksim_global.h"
 #include "disksim_iosim.h"
@@ -127,7 +127,7 @@
     int *lba_table;                 // a table mapping the lba to the physical pages
                                     // on the chip.
 
-    char *free_blocks;              // each bit indicates whether a block in the
+    unsigned char *free_blocks;              // each bit indicates whether a block in the
                                     // ssd_element is free or in use. number of bits
                                     // in free_blocks is given by
                                     // (struct ssd*)->params.blocks_per_element
diff -uNr disksim-4.0/ssdmodel/ssd.h~ disksim-4.0-x64/ssdmodel/ssd.h~
--- disksim-4.0/ssdmodel/ssd.h~	1970-01-01 08:00:00.000000000 +0800
+++ disksim-4.0-x64/ssdmodel/ssd.h~	2008-08-14 19:05:52.000000000 +0800
@@ -0,0 +1,457 @@
+// DiskSim SSD support
+// 2008 Microsoft Corporation. All Rights Reserved
+
+#include "disksim_global.h"
+#include "disksim_iosim.h"
+#include "disksim_stat.h"
+#include "disksim_ioqueue.h"
+#include "disksim_bus.h"
+#include "config.h"
+
+#ifndef DISKSIM_SSD_H
+#define DISKSIM_SSD_H
+
+struct ssd *getssd (int devno);
+
+/* default ssd dev header */
+extern struct device_header ssd_hdr_initializer;
+
+//#define SSD_ASSERT_ALL                1
+
+#define SSD_MAX_ELEMENTS            64
+#define SSD_MAX_PLANES_PER_ELEM     16
+#define SSD_MAX_PARUNITS_PER_ELEM   SSD_MAX_PLANES_PER_ELEM
+#define SSD_MAX_ELEMS_PER_GANG      SSD_MAX_ELEMENTS// if you're changing this, do change the following bits too
+#define SSD_BITS_ELEMS_PER_GANG     8
+
+
+typedef struct {
+   statgen acctimestats;
+   double  requestedbus;
+   double  waitingforbus;
+   int     numbuswaits;
+} ssd_stat_t;
+
+/*
+ * statistics per ssd element
+ */
+typedef struct _ssd_element_stat {
+    int num_clean;                  // no of times cleaning has been invoked on this element
+    int pages_moved;                // no of pages moved due to cleaning
+    double tot_xfer_cost;           // total transfer cost across planes (must be 0 for cpbk)
+    int avg_lifetime;               // average remaining lifetime on all the blocks
+    int tot_reqs_issued;            // total requests issued at this chip
+    double tot_time_taken;          // sum of access time of each req
+    double tot_clean_time;          // sum of cleaning time
+} ssd_element_stat;
+
+/*
+ * different states a block can be in.
+ */
+typedef enum {
+  SSD_BLOCK_CLEAN,
+  SSD_BLOCK_INUSE,
+  SSD_BLOCK_SEALED
+} SSD_BLOCK_STATES;
+
+
+/*
+ * this is the metadata stored on each block.
+ * it contains a list of valid pages (in the real system,
+ * we can find if a page in a block is valid by comparing
+ * a version number stored on each block) and some stat
+ * about its remaining lifetime to help wear-leveling and
+ * cleaning program.
+ */
+typedef struct _block_metadata {
+    int         block_num;              //
+    int         plane_num;              // the plane to which this block belongs to
+
+    int         *page;                  // size of the array = pages_per_block
+                                        // holds all the valid logical page numbers present
+                                        // in a block
+
+    int         num_valid;              // represents the no of valid pages in the block (that is,
+                                        // the no of non '-1' entries in the above page array)
+                                        // don't use it as an index to add pages in the above array.
+
+    int         rem_lifetime;           // remaining life time for this block. when the system
+                                        // starts for the first time, this value will be initialized
+                                        // to total num of erasures that can be performed on a block.
+                                        // after every time this block is erased, this count is
+                                        // decremented.
+
+    double      time_of_last_erasure;   // holds the time when the last erasure was performed.
+
+    int         state;                  // state of the block
+                                        // a block could be in one of the following states:
+                                        // CLEAN - when the block is erased and clean to take new writes
+                                        // INUSE - when its pages are being filled
+                                        // SEALED - when all the free pages are written and the block
+                                        // is sealed for future writes
+
+    unsigned int    bsn;                // block sequence number (version number for blocks)
+} block_metadata;
+
+
+/*
+ * holds the plane specific metadata
+ */
+typedef struct _plane_metadata {
+
+    int free_blocks;                // num of free blocks in this plane
+
+    int valid_pages;                // num of valid pages (note that a block might not
+                                    // be free but not all its pages should be valid)
+
+    unsigned int active_page;       // this points to the next page to write inside an
+                                    // active block.
+
+    int clean_in_progress;          // a flag that is set to 1 when some cleaning is
+                                    // going on in this plane
+    int clean_in_block;             // which block is being cleaned?
+    int block_alloc_pos;            // block allocation position in a plane
+    int parunit_num;                // parallel unit number
+    int num_cleans;                 // number of times cleaning was invoked on this
+} plane_metadata;
+
+typedef struct _parunit {
+    int plane_to_clean;
+} parunit;
+
+/*
+ * defining a structure to hold the metadata
+ * of each ssd element.
+ */
+typedef struct _ssd_element_metadata {
+    int *lba_table;                 // a table mapping the lba to the physical pages
+                                    // on the chip.
+
+    char *free_blocks;              // each bit indicates whether a block in the
+                                    // ssd_element is free or in use. number of bits
+                                    // in free_blocks is given by
+                                    // (struct ssd*)->params.blocks_per_element
+
+    unsigned int tot_free_blocks;   // total number of free blocks in the system. i'm
+                                    // having this variable just for convenience. it can be
+                                    // computed from the above free_blocks list.
+
+    unsigned int active_page;       // this points to the next page to write inside an
+                                    // active block.
+
+    plane_metadata plane_meta[SSD_MAX_PLANES_PER_ELEM];
+
+    block_metadata *block_usage;    // contains the number of valid pages in each block.
+                                    // we also store the valid page numbers here. this is useful
+                                    // during cleaning.
+
+    unsigned int bsn;               // block sequence number for this ssd element
+
+    int plane_to_clean;             // which plane to clean?
+    int plane_to_write;             // which plane to write next?
+    int block_alloc_pos;            // start allocating block from this position
+
+    parunit parunits[SSD_MAX_PARUNITS_PER_ELEM];
+
+    int gang_num;                   // the gang to which this element belongs
+    int reqs_waiting;               //
+    int tot_migrations;             //
+    int tot_pgs_migrated;           //
+    double mig_cost;                //
+} ssd_element_metadata;
+
+/*
+ * a ssd plane consists of a bunch of blocks (2048 according to Samsung specifications)
+ * and a register for transferring data in and out.
+ */
+typedef struct _ssd_plane {
+    //struct ioq *queue;                // requests that are active on this plane
+    //struct ioq *completion_queue;     // requests that complete in this plane
+
+    int media_busy;                 // tells you whether the plane is currently being used or not
+    int pair_plane;                 // certain planes are paired (in Samsung chips) and two-plane
+                                    // operations can be performed only within a plane-pair.
+    int num_blocks;                 // no of blocks in this plane.
+} ssd_plane;
+
+
+/*
+ * the ssd element (a single package) internally consists of multiple
+ * planes and the entire package has only one set of pins. so, when
+ * transfering data to/from the package, the access to the pins must
+ * be serialized. however, operations on multiple planes can be
+ * performed concurrently.
+ */
+typedef struct _ssd_element {
+   struct ioq *queue;
+   int media_busy;
+   ssd_element_metadata metadata;               // contains the mapping info b/w lba and flash pages
+   ssd_element_stat stat;                       // statistics about each ssd element
+
+   int pin_busy;                                // state to hold the busy state of the package pins
+   int num_planes;                              // number of planes in this package
+   ssd_plane plane[SSD_MAX_PLANES_PER_ELEM];    // an array of flash planes
+} ssd_element;
+
+typedef struct _ssd_elem_number {
+    int e:SSD_BITS_ELEMS_PER_GANG;
+} ssd_elem_number;
+
+typedef struct _gang_metadata {
+    struct ioq *queue;
+    int cleaning;                               // set to 1 if cleaning is in progress
+    int busy;                                   // set to 1 if at least one element is busy in this gang
+    int reqs_waiting;                           // num of reqs waiting in this gang
+    double oldest;                              // time at which the oldest of the waiting reqs arrived
+    int elem_free_pages[SSD_MAX_ELEMENTS];      // free pages on each element
+    ssd_elem_number *pg2elem;
+} gang_metadata;
+
+
+#define SSD_SIMPLE_MODEL                        1
+#define SSD_SIMPLE_DW_MODEL                     2
+#define SSD_LOGDISK_MODEL                       3
+
+//vp - different write policies
+#define DISKSIM_SSD_MAX_WRITE_POLICIES          2
+#define DISKSIM_SSD_WRITE_POLICY_SIMPLE         1
+#define DISKSIM_SSD_WRITE_POLICY_OSR            2
+
+//vp - maximum percentage of pages one can reserve
+//we don't want someone to set 100% of the space to reserve
+#define DISKSIM_SSD_MAX_RESERVE                 50
+
+//vp - sector size and metadata size per sector
+#define SSD_DATA_BYTES_PER_SECTOR               512
+#define SSD_MDATA_BYTES_PER_SECTOR              16
+#define SSD_BYTES_PER_SECTOR                    (SSD_DATA_BYTES_PER_SECTOR + SSD_MDATA_BYTES_PER_SECTOR)
+
+//vp - summary page size
+#define SSD_SECTORS_PER_SUMMARY_PAGE            1
+
+/////////////////////////////////////////////////////////////////
+//vp - blocks in a plane can be arranged in different ways
+
+// blocks can be concatenated (chained) from each plane
+//
+// plane 0    plane 1    plane 2    plane 3
+// ------------------------------------------
+// blk 0      blk 2048   blk 4096   blk 6144
+// blk 1      blk 2049   blk 4097   blk 6145
+// ...        ...
+// blk 2047   blk 4095   blk 6143   blk 8191
+#define PLANE_BLOCKS_CONCAT                 1
+
+
+// blocks can be stripped across every pair of planes
+// this is how samsung has designed its dies.
+// according to the samsung chip design, blocks are
+// stripped across every pair of planes. that is, the
+// block numbers are arranged as follows.
+//
+// plane 0    plane 1    plane 2    plane 3
+// ------------------------------------------
+// blk 0      blk 1      blk 4096   blk 4097
+// blk 2      blk 3      blk 4098   blk 4099
+// ...        ...
+// blk 4094   blk 4095   blk 8190   blk 8191
+#define PLANE_BLOCKS_PAIRWISE_STRIPE        2
+
+
+// blocks can be stripped across all the planes
+//
+// plane 0    plane 1    plane 2    plane 3
+// ------------------------------------------
+// blk 0      blk 1      blk 2      blk 3
+// blk 4      blk 5      blk 6      blk 7
+// ...        ...
+// blk 8188   blk 8189   blk 8190   blk 8191
+//
+#define PLANE_BLOCKS_FULL_STRIPE            3
+
+
+//vp - how many active pages are in an element
+#define SSD_COPY_BACK_DISABLE                   0
+#define SSD_COPY_BACK_ENABLE                    1
+
+// how we define the allocation pool size
+#define SSD_ALLOC_POOL_GANG                     0
+#define SSD_ALLOC_POOL_CHIP                     1   // each element is an allocation pool
+#define SSD_ALLOC_POOL_PLANE                    2
+
+// what do the gangs share?
+#define SSD_SHARED_BUS_GANG                     1  // shares both data and control
+#define SSD_SHARED_CONTROL_GANG                 2  // shares only the control
+
+typedef struct _ssd_timing_params {
+    int    ssd_model;                   // e.g. SSD_*_MODEL above
+    int    nelements;                   // how many concurrent entities (chips)
+    int    page_size;                   // sectors per page
+    int    pages_per_block;             // pages per block
+    int    blocks_per_element;          // total blocks per chip
+    int    element_stride_pages;        // usually 1 or 2
+
+    //vp - changing the chip_xfer_latency to per byte transfer cost
+    //instead of per sector transfer cost to make more accurate estimate
+    double chip_xfer_latency;           // time to get a byte to/from the chip register
+    double page_read_latency;           // time to read a page into chip register
+    double page_write_latency;          // time to write a page from chip register
+    double block_erase_latency;         // time to erase a block
+
+    int     write_policy;               // policy followed when writing a block
+                                        // follow the above definitions
+                                        // (e.g., DISKSIM_SSD_WRITE_POLICY_SIMPLE)
+
+    int     reserve_blocks;             // percentage of blocks to reserve
+
+    int     min_freeblks_percent;       // min free blocks percentage
+
+    int     cleaning_policy;            // cleaning & wear-leveling policy used to
+                                        // clean blocks
+
+    int     planes_per_pkg;             // num of planes in a single SSD package
+
+    unsigned int    blocks_per_plane;   // num of flash blocks in a single plane
+
+    int     plane_block_mapping;        // how blocks are mapped in a plane
+
+    int     copy_back;      // how active pages are assigned in an element
+
+    int     num_parunits;               // number of parallel units in each element
+
+    int     elements_per_gang;          // number of packages in a gang
+
+    int     gang_share;                 // is this a shared bus or shared control gang?
+
+    int     cleaning_in_background;     // do we want to do the cleaning in foreground/background?
+
+    int     alloc_pool_logic;           // static or dynamic allocation
+} ssd_timing_params;
+
+struct _ssd_timing_t;    // forward def for timing module.
+//typedef struct _ssd_timing_t *ssd_timing_t;
+
+typedef struct ssd {
+   struct device_header hdr;
+   ssd_timing_params  params;
+    struct _ssd_timing_t   *timing_t;
+
+   double overhead;
+   double bus_transaction_latency;
+   int numblocks;
+   int devno;
+   int inited;
+   int reconnect_reason;
+
+   ioreq_event *channel_activity;
+   ioreq_event *completion_queue;
+   struct ioq *queue;
+
+   ssd_element elements[SSD_MAX_ELEMENTS];
+
+   // for ganging elements
+   unsigned int data_pages_per_elem;    // number of pages that can be used to store data
+   gang_metadata gang_meta[SSD_MAX_ELEMENTS];
+
+   double blktranstime;
+   int maxqlen;
+   int busowned;
+   ioreq_event *buswait;
+   int neverdisconnect;
+   int numinbuses;
+   int inbuses[MAXINBUSES];
+   int depth[MAXINBUSES];
+   int slotno[MAXINBUSES];
+
+   int printstats;
+   ssd_stat_t stat;
+} ssd_t;
+
+typedef struct ssd_info {
+   struct ssd **ssds;
+   int numssds;
+  int ssds_len; /* allocated size of ssds */
+} ssdinfo_t;
+
+/* request structure */
+typedef struct _ssd_req {
+    int blk;
+    int count;
+    int is_read;
+    int plane_num;
+    ioreq_event *org_req;
+    double acctime;
+    double schtime;         // when to schedule this event?
+    int include;            // should we include its cost in acctime stats
+                            // if we're getting parallel ios, then we don't need to include all of 'em
+} ssd_req;
+
+/* some more definitions */
+#define SSD_PAGE_TO_BLOCK(pnum, s)      ((pnum)/(s->params.pages_per_block))
+#define SSD_PAGES_PER_ELEM(s)           ((s)->params.blocks_per_element * (s)->params.pages_per_block)
+#define ADDRESSABLE_PAGES_PER_ELEM(s)   ((s)->data_pages_per_elem)
+#define SSD_PLANES_PER_ELEM(s)          ((s)->params.planes_per_pkg)
+#define SSD_PARUNITS_PER_ELEM(s)        ((s)->params.num_parunits)
+#define SSD_PLANES_PER_PARUNIT(s)       (SSD_PLANES_PER_ELEM(s)/SSD_PARUNITS_PER_ELEM(s))
+#define SSD_DATA_PAGES_PER_BLOCK(s)     ((s)->params.pages_per_block - 1)
+#define SSD_GANG_PAGE_SIZE(s)           ((s)->params.elements_per_gang * (s)->params.page_size)
+#define numssds                         (disksim->ssdinfo->numssds)
+
+#define ALLOC_UNIT_GANG             1
+#define ALLOC_UNIT_ELEM             2
+#define SSD_NUM_GANG(s)             ((s)->params.nelements / (s)->params.elements_per_gang)
+#define SSD_GANG_SIZE(s)            (ADDRESSABLE_PAGES_PER_ELEM(s) * (s)->params.elements_per_gang)
+#define MIN_REQS                    99999999
+#define MAX_REQS                    100
+#define MAX_REQS_ELEM_QUEUE         100
+#define SYNC_GANG                   1
+#define MIGRATE                     1
+
+/* externalized disksim_ssd.c functions */
+void    ssd_read_toprints (FILE *parfile);
+void    ssd_read_specs (FILE *parfile, int devno, int copies);
+void    ssd_set_syncset (int setstart, int setend);
+void    ssd_param_override (char *paramname, char *paramval, int first, int last);
+void    ssd_setcallbacks (void);
+void    ssd_initialize (void);
+void    ssd_resetstats (void);
+void    ssd_printstats (void);
+void    ssd_printsetstats (int *set, int setsize, char *sourcestr);
+void    ssd_cleanstats (void);
+int     ssd_set_depth (int devno, int inbusno, int depth, int slotno);
+int     ssd_get_depth (int devno);
+int     ssd_get_inbus (int devno);
+int     ssd_get_busno (ioreq_event *curr);
+int     ssd_get_slotno (int devno);
+int     ssd_get_number_of_blocks (int devno);
+int     ssd_get_maxoutstanding (int devno);
+int     ssd_get_numdisks (void);
+int     ssd_get_numcyls (int devno);
+double  ssd_get_blktranstime (ioreq_event *curr);
+int     ssd_get_avg_sectpercyl (int devno);
+void    ssd_get_mapping (int maptype, int devno, int blkno, int *cylptr, int *surfaceptr, int *blkptr);
+void    ssd_event_arrive (ioreq_event *curr);
+int     ssd_get_distance (int devno, ioreq_event *req, int exact, int direction);
+double  ssd_get_servtime (int devno, ioreq_event *req, int checkcache, double maxtime);
+double  ssd_get_acctime (int devno, ioreq_event *req, double maxtime);
+void    ssd_bus_delay_complete (int devno, ioreq_event *curr, int sentbusno);
+void    ssd_bus_ownership_grant (int devno, ioreq_event *curr, int busno, double arbdelay);
+
+void    ssd_assert_free_blocks(ssd_t *s, ssd_element_metadata *metadata);
+void    ssd_assert_valid_pages(int plane_num, ssd_element_metadata *metadata, ssd_t *s);
+double  ssd_data_transfer_cost(ssd_t *s, int sectors_count);
+int     ssd_last_page_in_block(int page_num, ssd_t *s);
+double  _ssd_write_page_osr(ssd_t *s, ssd_element_metadata *metadata, int lpn);
+int     ssd_logical_pageno(int blkno, ssd_t *s);
+int     ssd_block_to_bitpos(ssd_t *currdisk, int block);
+int     ssd_bitpos_to_block(int bitpos, ssd_t *s);
+void    _ssd_alloc_active_block(int plane_num, int elem_num, ssd_t *s);
+int     ssd_free_bits(int plane_num, int elem_num, ssd_element_metadata *metadata, ssd_t *s);
+void    ssd_assert_plane_freebits(int plane_num, int elem_num, ssd_element_metadata *metadata, ssd_t *s);
+double  ssd_read_policy_simple(int count, ssd_t *s);
+void    ssd_complete_parent(ioreq_event *curr, ssd_t *currdisk);
+double _ssd_invoke_element_cleaning(int elem_num, ssd_t *s);
+int     ssd_already_present(ssd_req **reqs, int total, ioreq_event *req);
+
+#endif   /* DISKSIM_ssd_H */
+
diff -uNr disksim-4.0/ssdmodel/ssd_init.c disksim-4.0-x64/ssdmodel/ssd_init.c
--- disksim-4.0/ssdmodel/ssd_init.c	2008-08-16 14:10:34.000000000 +0800
+++ disksim-4.0-x64/ssdmodel/ssd_init.c	2016-03-23 19:47:14.334689000 +0800
@@ -1,5 +1,5 @@
 // DiskSim SSD support
-// 2008 Microsoft Corporation. All Rights Reserved
+// \A92008 Microsoft Corporation. All Rights Reserved
 
 #include "ssd.h"
 #include "ssd_timing.h"
@@ -445,7 +445,7 @@
 
 void ssd_initialize (void)
 {
-    static print1 = 1;
+    //static print1 = 1;
    int i, j;
 
    if (disksim->ssdinfo == NULL) {
diff -uNr disksim-4.0/ssdmodel/ssd_init.c~ disksim-4.0-x64/ssdmodel/ssd_init.c~
--- disksim-4.0/ssdmodel/ssd_init.c~	1970-01-01 08:00:00.000000000 +0800
+++ disksim-4.0-x64/ssdmodel/ssd_init.c~	2008-08-16 14:10:34.000000000 +0800
@@ -0,0 +1,544 @@
+// DiskSim SSD support
+// 2008 Microsoft Corporation. All Rights Reserved
+
+#include "ssd.h"
+#include "ssd_timing.h"
+#include "ssd_clean.h"
+#include "ssd_utils.h"
+#include "ssd_init.h"
+
+/* read-only globals used during readparams phase */
+static char *statdesc_acctimestats  =   "Access time";
+
+static void ssd_statinit (int devno, int firsttime)
+{
+   ssd_t *currdisk;
+
+   currdisk = getssd (devno);
+   if (firsttime) {
+      stat_initialize(statdeffile, statdesc_acctimestats, &currdisk->stat.acctimestats);
+   } else {
+      stat_reset(&currdisk->stat.acctimestats);
+   }
+
+   currdisk->stat.requestedbus = 0.0;
+   currdisk->stat.waitingforbus = 0.0;
+   currdisk->stat.numbuswaits = 0;
+}
+
+void ssd_initialize_diskinfo ()
+{
+   disksim->ssdinfo = malloc (sizeof(ssdinfo_t));
+   bzero ((char *)disksim->ssdinfo, sizeof(ssdinfo_t));
+   disksim->ssdinfo->ssds = malloc(MAXDEVICES * (sizeof(ssd_t)));
+   disksim->ssdinfo->ssds_len = MAXDEVICES;
+   bzero ((char *)disksim->ssdinfo->ssds, (MAXDEVICES * (sizeof(ssd_t))));
+}
+
+
+static int ssd_first_page_in_next_block(int ppage, ssd_t *currdisk)
+{
+    int skip_by = ppage % currdisk->params.pages_per_block;
+    ppage += currdisk->params.pages_per_block - skip_by;
+    return ppage;
+}
+
+int ssd_elem_export_size(ssd_t *currdisk)
+{
+    unsigned int reserved_blocks, usable_blocks;
+    unsigned int reserved_blocks_per_plane, usable_blocks_per_plane;
+
+    reserved_blocks_per_plane = (currdisk->params.reserve_blocks * currdisk->params.blocks_per_plane) / 100;
+    usable_blocks_per_plane = currdisk->params.blocks_per_plane - reserved_blocks_per_plane;
+    reserved_blocks = reserved_blocks_per_plane * currdisk->params.planes_per_pkg;
+    usable_blocks = usable_blocks_per_plane * currdisk->params.planes_per_pkg;
+
+    return (usable_blocks * SSD_DATA_PAGES_PER_BLOCK(currdisk));
+}
+
+/*
+ * vp
+ * description: this routine allocates and initializes the ssd element metadata
+ * structures. FIXME: if the systems is powered up, this init routine has to
+ * populate the structures by scanning the summary pages (to implement this,
+ * we can read from a disk checkpoint file). but, this is future work.
+*/
+void ssd_element_metadata_init(int elem_number, ssd_element_metadata *metadata, ssd_t *currdisk)
+{
+    gang_metadata *g;
+    unsigned int ppage;
+    unsigned int i;
+    unsigned int bytes_to_alloc;
+    unsigned int tot_blocks = currdisk->params.blocks_per_element;
+    unsigned int tot_pages = tot_blocks * currdisk->params.pages_per_block;
+    unsigned int reserved_blocks, usable_blocks, export_size;
+    unsigned int reserved_blocks_per_plane, usable_blocks_per_plane;
+    unsigned int bitpos;
+    unsigned int active_block;
+    unsigned int elem_index;
+    unsigned int bsn = 1;
+    int plane_block_mapping = currdisk->params.plane_block_mapping;
+
+    //////////////////////////////////////////////////////////////////////////////
+    // active page starts at the 1st page on the reserved section
+    reserved_blocks_per_plane = (currdisk->params.reserve_blocks * currdisk->params.blocks_per_plane) / 100;
+    usable_blocks_per_plane = currdisk->params.blocks_per_plane - reserved_blocks_per_plane;
+    reserved_blocks = reserved_blocks_per_plane * currdisk->params.planes_per_pkg;
+    usable_blocks = usable_blocks_per_plane * currdisk->params.planes_per_pkg;
+
+    //////////////////////////////////////////////////////////////////////////////
+    // initialize the free blocks and free pages
+    metadata->tot_free_blocks = reserved_blocks;
+
+    //////////////////////////////////////////////////////////////////////////////
+    // assign the gang and init the element's free pages
+    metadata->gang_num = elem_number / currdisk->params.elements_per_gang;
+    currdisk->gang_meta[metadata->gang_num].elem_free_pages[elem_number] = \
+        metadata->tot_free_blocks * SSD_DATA_PAGES_PER_BLOCK(currdisk);
+    g = &currdisk->gang_meta[metadata->gang_num];
+    elem_index = elem_number % currdisk->params.elements_per_gang;
+
+    //////////////////////////////////////////////////////////////////////////////
+    // let's begin cleaning with the first plane
+    metadata->plane_to_clean = 0;
+    metadata->plane_to_write = 0;
+    metadata->block_alloc_pos = 0;
+    metadata->reqs_waiting = 0;
+    metadata->tot_migrations = 0;
+    metadata->tot_pgs_migrated = 0;
+    metadata->mig_cost = 0;
+
+    //////////////////////////////////////////////////////////////////////////////
+    // init the plane metadata
+    for (i = 0; i < (unsigned int)currdisk->params.planes_per_pkg; i ++) {
+        int blocks_to_skip;
+
+        switch(plane_block_mapping) {
+            case PLANE_BLOCKS_CONCAT:
+                blocks_to_skip = (i*currdisk->params.blocks_per_plane + usable_blocks_per_plane);
+                break;
+
+            case PLANE_BLOCKS_PAIRWISE_STRIPE:
+                blocks_to_skip = (i/2)*(2*currdisk->params.blocks_per_plane) + (2*usable_blocks_per_plane) + i%2;
+                break;
+
+            case PLANE_BLOCKS_FULL_STRIPE:
+                blocks_to_skip = (currdisk->params.planes_per_pkg * usable_blocks_per_plane) + i;
+                break;
+
+            default:
+                fprintf(stderr, "Error: unknown plane_block_mapping %d\n", plane_block_mapping);
+                exit(1);
+        }
+
+        metadata->plane_meta[i].active_page = blocks_to_skip*currdisk->params.pages_per_block;
+        metadata->plane_meta[i].free_blocks = reserved_blocks_per_plane;
+        metadata->plane_meta[i].valid_pages = 0;
+        metadata->plane_meta[i].clean_in_progress = 0;
+        metadata->plane_meta[i].clean_in_block = -1;
+        metadata->plane_meta[i].block_alloc_pos = i*currdisk->params.blocks_per_plane;
+        metadata->plane_meta[i].parunit_num = i / SSD_PLANES_PER_PARUNIT(currdisk);
+        metadata->plane_meta[i].num_cleans = 0;
+    }
+
+    //////////////////////////////////////////////////////////////////////////////
+    // init the next plane to clean in a parunit
+    for (i = 0; i < (unsigned int) SSD_PARUNITS_PER_ELEM(currdisk); i ++) {
+        metadata->parunits[i].plane_to_clean = SSD_PLANES_PER_PARUNIT(currdisk)*i;
+    }
+
+    //////////////////////////////////////////////////////////////////////////////
+    // init the element's active page
+    switch(plane_block_mapping) {
+        case PLANE_BLOCKS_CONCAT:
+            metadata->active_page = usable_blocks_per_plane * currdisk->params.pages_per_block;
+            break;
+
+        case PLANE_BLOCKS_PAIRWISE_STRIPE:
+            metadata->active_page = (2 * usable_blocks_per_plane) * currdisk->params.pages_per_block;
+            break;
+
+        case PLANE_BLOCKS_FULL_STRIPE:
+            metadata->active_page = (currdisk->params.planes_per_pkg * usable_blocks_per_plane) * currdisk->params.pages_per_block;
+            break;
+
+        default:
+            fprintf(stderr, "Error: unknown plane_block_mapping %d\n", plane_block_mapping);
+            exit(1);
+    }
+
+    ASSERT(metadata->active_page == metadata->plane_meta[0].active_page);
+    active_block = metadata->active_page / currdisk->params.pages_per_block;
+
+    // since we reserve one page out of every block to store the summary info,
+    // the size exported by the flash disk is little less.
+    export_size = usable_blocks * SSD_DATA_PAGES_PER_BLOCK(currdisk);
+    currdisk->data_pages_per_elem = export_size;
+    //printf("res blks = %d, use blks = %d act page = %d exp size = %d\n",
+    //  reserved_blocks, usable_blocks, metadata->active_page, export_size);
+
+    //////////////////////////////////////////////////////////////////////////////
+    // allocate the lba table
+    if ((metadata->lba_table = (int *)malloc(export_size * sizeof(int))) == NULL) {
+        fprintf(stderr, "Error: malloc to lba table in ssd_element_metadata_init failed\n");
+        fprintf(stderr, "Allocation size = %d\n", export_size * sizeof(int));
+        exit(1);
+    }
+
+    //////////////////////////////////////////////////////////////////////////////
+    // allocate the free blocks bit map
+    // what if the no of blocks is not divisible by 8?
+    if ((tot_blocks % (sizeof(unsigned char) * 8)) != 0) {
+        fprintf(stderr, "This case is not yet handled\n");
+        exit(1);
+    }
+
+    bytes_to_alloc = tot_blocks / (sizeof(unsigned char) * 8);
+    if (!(metadata->free_blocks = (unsigned char *)malloc(bytes_to_alloc))) {
+        fprintf(stderr, "Error: malloc to free_blocks in ssd_element_metadata_init failed\n");
+        fprintf(stderr, "Allocation size = %d\n", bytes_to_alloc);
+        exit(1);
+    }
+    bzero(metadata->free_blocks, bytes_to_alloc);
+
+    //////////////////////////////////////////////////////////////////////////////
+    // allocate the block usage array and initialize it
+    if (!(metadata->block_usage = (block_metadata *)malloc(tot_blocks * sizeof(block_metadata)))) {
+        fprintf(stderr, "Error: malloc to block_usage in ssd_element_metadata_init failed\n");
+        fprintf(stderr, "Allocation size = %d\n", tot_blocks * sizeof(block_metadata));
+        exit(1);
+    }
+    bzero(metadata->block_usage, tot_blocks * sizeof(block_metadata));
+
+    for (i = 0; i < tot_blocks; i ++) {
+        int j;
+
+        metadata->block_usage[i].block_num = i;
+        metadata->block_usage[i].page = (int*)malloc(sizeof(int) * currdisk->params.pages_per_block);
+
+        for (j = 0; j < currdisk->params.pages_per_block; j ++) {
+            metadata->block_usage[i].page[j] = -1;
+        }
+
+        // assign the plane number to each block
+        switch(plane_block_mapping) {
+            case PLANE_BLOCKS_CONCAT:
+                metadata->block_usage[i].plane_num = i / currdisk->params.blocks_per_plane;
+                break;
+
+            case PLANE_BLOCKS_PAIRWISE_STRIPE:
+                metadata->block_usage[i].plane_num = (i/(2*currdisk->params.blocks_per_plane))*2 + i%2;
+                break;
+
+            case PLANE_BLOCKS_FULL_STRIPE:
+                metadata->block_usage[i].plane_num = i % currdisk->params.planes_per_pkg;
+                break;
+
+            default:
+                fprintf(stderr, "Error: unknown plane_block_mapping %d\n", plane_block_mapping);
+                exit(1);
+        }
+
+        // set the remaining life time and time of last erasure
+        metadata->block_usage[i].rem_lifetime = SSD_MAX_ERASURES;
+        metadata->block_usage[i].time_of_last_erasure = simtime;
+
+        // set the block state
+        metadata->block_usage[i].state = SSD_BLOCK_CLEAN;
+
+        // init the bsn to be zero
+        metadata->block_usage[i].bsn = 0;
+    }
+
+    //////////////////////////////////////////////////////////////////////////////
+    // initially, we assume that every logical page is mapped
+    // onto a physical page. we start from the first phy page
+    // and continue to map, leaving the last page of every block
+    // to store the summary information.
+    ppage = 0;
+    i = 0;
+    while (i < export_size) {
+        int pgnum_in_gang;
+        int pp_index;
+        int plane_num;
+        unsigned int block = SSD_PAGE_TO_BLOCK(ppage, currdisk);
+
+        ASSERT(block < (unsigned int)currdisk->params.blocks_per_element);
+
+        // if this is the last page in the block
+        if (ssd_last_page_in_block(ppage, currdisk)) {
+            // leave this physical page for summary page and
+            // seal the block
+            metadata->block_usage[block].state = SSD_BLOCK_SEALED;
+
+            // go to next block
+            ppage ++;
+            block = SSD_PAGE_TO_BLOCK(ppage, currdisk);
+        }
+
+        // if this block is in the reserved section, skip it
+        // and go to the next block.
+        switch(plane_block_mapping) {
+            case PLANE_BLOCKS_CONCAT:
+            {
+                unsigned int block_index = block % currdisk->params.blocks_per_plane;
+                if ((block_index >= usable_blocks_per_plane) && (block_index < currdisk->params.blocks_per_plane)) {
+                    // go to next block
+                    ppage = ssd_first_page_in_next_block(ppage, currdisk);
+                    continue;
+                }
+            }
+            break;
+
+            case PLANE_BLOCKS_PAIRWISE_STRIPE:
+            {
+                unsigned int block_index = block % (2*currdisk->params.blocks_per_plane);
+                if ((block_index >= 2*usable_blocks_per_plane) && (block_index < 2*currdisk->params.blocks_per_plane)) {
+                    ppage = ssd_first_page_in_next_block(ppage, currdisk);
+                    continue;
+                }
+            }
+            break;
+
+            case PLANE_BLOCKS_FULL_STRIPE:
+                // ideally the control should not come here ...
+                if ((block >= usable_blocks) && (block < (unsigned int)currdisk->params.blocks_per_element)) {
+                    printf("Error: the control should not come here ...\n");
+                    ppage = ssd_first_page_in_next_block(ppage, currdisk);
+                    continue;
+                }
+            break;
+
+            default:
+                fprintf(stderr, "Error: unknown plane_block_mapping %d\n", plane_block_mapping);
+                exit(1);
+        }
+
+        // when the control comes here, 'ppage' contains the next page
+        // that can be assigned to a logical page.
+        // find the index of the phy page within the block
+        pp_index = ppage % currdisk->params.pages_per_block;
+
+        // populate the lba table
+        metadata->lba_table[i] = ppage;
+        pgnum_in_gang = elem_index * export_size + i;
+        g->pg2elem[pgnum_in_gang].e = elem_number;
+
+        // mark this block as not free and its state as 'in use'.
+        // note that a block could be not free and its state be 'sealed'.
+        // it is enough if we set it once while working on the first phy page.
+        // also increment the block sequence number.
+        if (pp_index == 0) {
+            bitpos = ssd_block_to_bitpos(currdisk, block);
+            ssd_set_bit(metadata->free_blocks, bitpos);
+            metadata->block_usage[block].state = SSD_BLOCK_INUSE;
+            metadata->block_usage[block].bsn = bsn ++;
+        }
+
+        // increase the usage count per block
+        plane_num = metadata->block_usage[block].plane_num;
+        metadata->block_usage[block].page[pp_index] = i;
+        metadata->block_usage[block].num_valid ++;
+        metadata->plane_meta[plane_num].valid_pages ++;
+
+        // go to the next physical page
+        ppage ++;
+
+        // go to the next logical page
+        i ++;
+    }
+
+    //////////////////////////////////////////////////////////////////////////////
+    // mark the block that corresponds to the active page
+    // as not free and 'in_use'.
+    switch(currdisk->params.copy_back) {
+        case SSD_COPY_BACK_DISABLE:
+            bitpos = ssd_block_to_bitpos(currdisk, active_block);
+            ssd_set_bit(metadata->free_blocks, bitpos);
+            metadata->block_usage[active_block].state = SSD_BLOCK_INUSE;
+            metadata->block_usage[active_block].bsn = bsn ++;
+        break;
+
+        case SSD_COPY_BACK_ENABLE:
+            for (i = 0; i < (unsigned int)currdisk->params.planes_per_pkg; i ++) {
+                int plane_active_block = SSD_PAGE_TO_BLOCK(metadata->plane_meta[i].active_page, currdisk);
+
+                bitpos = ssd_block_to_bitpos(currdisk, plane_active_block);
+                ssd_set_bit(metadata->free_blocks, bitpos);
+                metadata->block_usage[plane_active_block].state = SSD_BLOCK_INUSE;
+                metadata->block_usage[plane_active_block].bsn = bsn ++;
+                metadata->tot_free_blocks --;
+                metadata->plane_meta[i].free_blocks --;
+            }
+        break;
+
+        default:
+            fprintf(stderr, "Error: invalid copy back policy %d\n",
+                currdisk->params.copy_back);
+            exit(1);
+    }
+
+    //////////////////////////////////////////////////////////////////////////////
+    // set the bsn for the ssd element
+    metadata->bsn = bsn;
+    //printf("set the bsn to %d\n", bsn);
+}
+
+void ssd_plane_init(ssd_element *elem, ssd_t *s, int devno)
+{
+    int i;
+
+    // set the num of planes per package
+    elem->num_planes = s->params.planes_per_pkg;
+
+    // init all the planes
+    for (i = 0; i < elem->num_planes; i ++) {
+        elem->plane[i].media_busy = FALSE;
+        elem->plane[i].num_blocks = s->params.blocks_per_plane;
+
+        // just flip the LSB to find the pair
+        elem->plane[i].pair_plane = i ^ 0x1;
+    }
+}
+
+/* vp
+ * verifies if a valid combination of parameters are given.
+ */
+void ssd_verify_parameters(ssd_t *currdisk)
+{
+    //vp - some verifications:
+    ASSERT(currdisk->params.min_freeblks_percent < currdisk->params.reserve_blocks);
+
+    if (currdisk->params.write_policy == 1) {
+        printf("Simple write policy with block-sized pages (256 KB) is not supported\n");
+        ASSERT(0);
+    }
+
+    ASSERT((currdisk->params.planes_per_pkg * currdisk->params.blocks_per_plane) == currdisk->params.blocks_per_element);
+
+    if (currdisk->params.alloc_pool_logic == 2) { // plane specific
+        ASSERT(currdisk->params.copy_back == SSD_COPY_BACK_ENABLE); // we can do GC only w/in a plane
+    }
+}
+
+void ssd_alloc_queues(ssd_t *t)
+{
+   // gross hack !!!!!
+   // copy the queue for the gangs and element queues from the
+   // main queue
+   // printf("Total gang = %d\n", SSD_NUM_GANG(result));
+   int i;
+   for (i = 0; i < SSD_NUM_GANG(t); i ++) {
+          struct ioq *q = malloc(sizeof(ioqueue));
+          memcpy(q, t->queue, sizeof(ioqueue));
+          t->gang_meta[i].queue = q;
+          assert(q != NULL);
+   }
+
+   for (i=0;i<t->params.nelements;i++) {
+          struct ioq *q = malloc(sizeof(ioqueue));
+          memcpy(q, t->queue, sizeof(ioqueue));
+          t->elements[i].queue = q;
+          assert(q != NULL);
+    }
+}
+
+void ssd_initialize (void)
+{
+    static print1 = 1;
+   int i, j;
+
+   if (disksim->ssdinfo == NULL) {
+      ssd_initialize_diskinfo ();
+   }
+/*
+fprintf (outputfile, "Entered ssd_initialize - numssds %d\n", numssds);
+*/
+   ssd_setcallbacks();
+
+   // fprintf(stdout, "MAXDEVICES = %d, numssds %d\n", MAXDEVICES, numssds);
+   // vp - changing the MAXDEVICES in the below 'for' loop to numssds
+   for (i=0; i<numssds; i++) {
+       int exp_size;
+      ssd_t *currdisk = getssd (i);
+      ssd_alloc_queues(currdisk);
+
+      //vp - some verifications:
+      ssd_verify_parameters(currdisk);
+
+      //vp - this was not initialized and caused so many bugs
+      currdisk->devno = i;
+
+      if (!currdisk) continue;
+/*        if (!currdisk->inited) { */
+         currdisk->numblocks = currdisk->params.nelements *
+                   currdisk->params.blocks_per_element *
+                   currdisk->params.pages_per_block *
+                   currdisk->params.page_size;
+         currdisk->reconnect_reason = -1;
+         addlisttoextraq ((event **) &currdisk->buswait);
+         currdisk->busowned = -1;
+         currdisk->completion_queue = NULL;
+         /* hack to init queue structure */
+         ioqueue_initialize (currdisk->queue, i);
+         ssd_statinit(i, TRUE);
+         currdisk->timing_t = ssd_new_timing_t(&currdisk->params);
+
+         // initialize the gang
+         exp_size = ssd_elem_export_size(currdisk);
+         for (j = 0; j < SSD_NUM_GANG(currdisk); j ++) {
+             int tot_pages = exp_size * currdisk->params.elements_per_gang;
+             currdisk->gang_meta[j].busy = 0;
+             currdisk->gang_meta[j].cleaning = 0;
+             currdisk->gang_meta[j].reqs_waiting = 0;
+             currdisk->gang_meta[j].oldest = 0;
+             currdisk->gang_meta[j].pg2elem = malloc(sizeof(ssd_elem_number) * tot_pages);
+             memset(currdisk->gang_meta[j].pg2elem, 0, sizeof(ssd_elem_number) * tot_pages);
+
+             ioqueue_initialize (currdisk->gang_meta[j].queue, i);
+         }
+
+         for (j=0; j<currdisk->params.nelements; j++) {
+             ssd_element *elem = &currdisk->elements[j];
+             ioqueue_initialize (elem->queue, i);
+
+             /* hack to init queue structure */
+             elem->media_busy = FALSE;
+
+             // vp - pins are also free
+             elem->pin_busy = FALSE;
+
+             // vp - initialize the planes in the element
+             ssd_plane_init(elem, currdisk, i);
+
+            // vp - initialize the ssd element metadata
+            // FIXME: where to free these data?
+             memset(&elem->stat, 0, sizeof(elem->stat));
+            if (currdisk->params.write_policy == DISKSIM_SSD_WRITE_POLICY_OSR) {
+                ssd_element_metadata_init(j, &(elem->metadata), currdisk);
+            }
+
+            //vp - initialize the stat structure
+            memset(&elem->stat, 0, sizeof(ssd_element_stat));
+         }
+/*        } */
+   }
+}
+
+void ssd_resetstats (void)
+{
+   int i;
+
+   for (i=0; i<MAXDEVICES; i++) {
+      ssd_t *currdisk = getssd (i);
+      if (currdisk) {
+         int j;
+         ioqueue_resetstats(currdisk->queue);
+         for (j=0; j<currdisk->params.nelements; j++) {
+             ioqueue_resetstats(currdisk->elements[j].queue);
+         }
+         ssd_statinit(i, 0);
+      }
+   }
+}
+
diff -uNr disksim-4.0/utils/params/Makefile disksim-4.0-x64/utils/params/Makefile
--- disksim-4.0/utils/params/Makefile	2008-05-12 05:30:54.000000000 +0800
+++ disksim-4.0-x64/utils/params/Makefile	2016-03-23 20:04:06.054737000 +0800
@@ -31,16 +31,16 @@
 
 include .paths
 
-DISKSIM_CFLAGS=-I../../src
-DISKSIM_LDFLAGS=-L../../src -ldisksim
+DISKSIM_CFLAGS=-m32 -I../../src
+DISKSIM_LDFLAGS=-m32 -L../../src -ldisksim
 
-CFLAGS = -g \
+CFLAGS = -g -m32\
         $(DISKSIM_CFLAGS) \
         $(DISKMODEL_CFLAGS) \
         $(LIBPARAM_CFLAGS) \
         $(LIBDDBG_CFLAGS) 
 
-LDFLAGS = $(DISKSIM_LDFLAGS) \
+LDFLAGS = -m32 $(DISKSIM_LDFLAGS) \
 	  $(DISKMODEL_LDFLAGS) \
           $(LIBPARAM_LDFLAGS) \
           $(LIBDDBG_LDFLAGS) -lm
diff -uNr disksim-4.0/utils/params/Makefile~ disksim-4.0-x64/utils/params/Makefile~
--- disksim-4.0/utils/params/Makefile~	1970-01-01 08:00:00.000000000 +0800
+++ disksim-4.0-x64/utils/params/Makefile~	2016-03-23 20:03:50.822736000 +0800
@@ -0,0 +1,60 @@
+
+# DiskSim Storage Subsystem Simulation Environment (Version 4.0)
+# Revision Authors: John Bucy, Greg Ganger
+# Contributors: John Griffin, Jiri Schindler, Steve Schlosser
+#
+# Copyright (c) of Carnegie Mellon University, 2001-2008.
+#
+# This software is being provided by the copyright holders under the
+# following license. By obtaining, using and/or copying this software,
+# you agree that you have read, understood, and will comply with the
+# following terms and conditions:
+#
+# Permission to reproduce, use, and prepare derivative works of this
+# software is granted provided the copyright and "No Warranty" statements
+# are included with all reproductions and derivative works and associated
+# documentation. This software may also be redistributed without charge
+# provided that the copyright and "No Warranty" statements are included
+# in all redistributions.
+#
+# NO WARRANTY. THIS SOFTWARE IS FURNISHED ON AN "AS IS" BASIS.
+# CARNEGIE MELLON UNIVERSITY MAKES NO WARRANTIES OF ANY KIND, EITHER
+# EXPRESSED OR IMPLIED AS TO THE MATTER INCLUDING, BUT NOT LIMITED
+# TO: WARRANTY OF FITNESS FOR PURPOSE OR MERCHANTABILITY, EXCLUSIVITY
+# OF RESULTS OR RESULTS OBTAINED FROM USE OF THIS SOFTWARE. CARNEGIE
+# MELLON UNIVERSITY DOES NOT MAKE ANY WARRANTY OF ANY KIND WITH RESPECT
+# TO FREEDOM FROM PATENT, TRADEMARK, OR COPYRIGHT INFRINGEMENT.
+# COPYRIGHT HOLDERS WILL BEAR NO LIABILITY FOR ANY USE OF THIS SOFTWARE
+# OR DOCUMENTATION.
+
+all: $(TARGETS)
+
+include .paths
+
+DISKSIM_CFLAGS=-m32 -I../../src
+DISKSIM_LDFLAGS=-m32 -L../../src -ldisksim
+
+CFLAGS = -g -m32\
+        $(DISKSIM_CFLAGS) \
+        $(DISKMODEL_CFLAGS) \
+        $(LIBPARAM_CFLAGS) \
+        $(LIBDDBG_CFLAGS) 
+
+LDFLAGS = $(DISKSIM_LDFLAGS) -m32\
+	  $(DISKMODEL_LDFLAGS) \
+          $(LIBPARAM_LDFLAGS) \
+          $(LIBDDBG_LDFLAGS) -lm
+
+TARGETS = merge_blocks libparam_to_v3
+all: $(TARGETS)
+
+merge_blocks: merge_blocks.o
+	$(CC) $(CFLAGS) $^ -o $@ $(LDFLAGS)
+
+libparam_to_v3: libparam_to_v3.o
+	$(CC) $(CFLAGS) $^ -o $@ $(LDFLAGS)
+
+
+clean:
+	rm -f *.o $(TARGETS)
+distclean: clean
